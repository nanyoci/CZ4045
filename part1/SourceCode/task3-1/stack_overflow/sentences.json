["I am trying to learn hooks and the useState method has made me confused.", "I am assigning an initial value to a state in the form of an array.", "The set method in useState is not working for me even with spread(...) or without spread operator.", "I have made an API on another PC that I am calling and fetching the data which I want to set into the state.", "Here is my code: import React, { useState, useEffect } from \"react\"; import ReactDOM from \"react-dom\"; const StateSelector = () => { const initialValue = [ { category: \"\", photo: \"\", description: \"\", id: 0, name: \"\", rating: 0 } ]; const [movies, setMovies] = useState(initialValue); useEffect(() => { (async function() { try { //const response = await fetch( //`http://192.168.1.164:5000/movies/display` //); //const json = await response.json(); //const result = json.data.result; const result = [ { category: \"cat1\", description: \"desc1\", id: \"1546514491119\", name: \"randomname2\", photo: null, rating: \"3\" }, { category: \"cat2\", description: \"desc1\", id: \"1546837819818\", name: \"randomname1\", rating: \"5\" } ]; console.log(result); setMovies(result); console.log(movies); } catch (e) { console.error(e); } })(); }, []); return <p>hello</p>; }; const rootElement = document.getElementById(\"root\"); ReactDOM.render(<StateSelector />, rootElement); The setMovies(result) as well as setMovies(...result) is not working.", "Could use some help here.", "I expect the result variable to be pushed into the movies array.", "Much like setState in Class components created by extending React.Component or React.PureComponent, the state update using the updater provided by useState hook is also asynchronous, and will not be reflected immediately.", "Also, the main issue here is not just the asynchronous nature but the fact that state values are used by functions based on their current closures, and state updates will reflect in the next re-render by which the existing closures are not affected, but new ones are created.", "Now in the current state, the values within hooks are obtained by existing closures, and when a re-render happens, the closures are updated based on whether the function is recreated again or not.", "Even if you add a setTimeout the function, though the timeout will run after some time by which the re-render would have happened, the setTimeout will still use the value from its previous closure and not the updated one.", "setMovies(result); console.log(movies) // movies here will not be updated If you want to perform an action on state update, you need to use the useEffect hook, much like using componentDidUpdate in class components since the setter returned by useState doesn't have a callback pattern useEffect(() => { // action on update of movies }, [movies]); As far as the syntax to update state is concerned, setMovies(result) will replace the previous movies value in the state with those available from the async request.", "However, if you want to merge the response with the previously existing values, you must use the callback syntax of state updation along with the correct use of spread syntax like setMovies(prevMovies => ([...prevMovies, ...result])); Addional details to the previous answer: While React's setState is asynchronous (both classes and hooks), and it's tempting to use that fact to explain the observed behaviour, it is not the reason why it happens.", "TLDR: The reason is a closure scope around an immutable const value.", "Solutions: read the value in render function (not inside nested functions): useEffect(() => { setMovies(result) }, []) console.log(movies) add the variable into dependencies (and use the react-hooks/exhaustive-deps eslint rule): useEffect(() => { setMovies(result) }, []) useEffect(() => { console.log(movies) }, [movies]) use a mutable reference (when the above is not possible): const moviesRef = useRef(initialValue) useEffect(() => { moviesRef.current = result console.log(moviesRef.current) }, []) Explanation why it happens: If async was the only reason, it would be possible to await setState().", "Howerver, both props and state are assumed to be unchanging during 1 render.", "Treat this.state as if it were immutable.", "With hooks, this assumption is enhanced by using constant values with the const keyword: const [state, setState] = useState('initial') The value might be different between 2 renders, but remains a constant inside the render itself and inside any closures (functions that live longer even after render is finished, e.g.", "useEffect, event handlers, inside any Promise or setTimeout).", "Consider following fake, but synchronous, React-like implementation: // sync implementation: let internalState let renderAgain const setState = (updateFn) => { internalState = updateFn(internalState) renderAgain() } const useState = (defaultState) => { if (!internalState) { internalState = defaultState } return [internalState, setState] } const render = (component, node) => { const {html, handleClick} = component() node.innerHTML = html renderAgain = () => render(component, node) return handleClick } // test: const MyComponent = () => { const [x, setX] = useState(1) console.log('in render:', x) // \u2705 const handleClick = () => { setX(current => current + 1) console.log('in handler/effect/Promise/setTimeout:', x) // \u274c NOT updated } return { html: `<button>${x}</button>`, handleClick } } const triggerClick = render(MyComponent, document.getElementById('root')) triggerClick() triggerClick() triggerClick() <div id=\"root\"></div> I just finished a rewrite with useReducer, following @kentcdobs article (ref below) which really gave me a solid result that suffers not one bit from these closure problems.", "see: https://kentcdodds.com/blog/how-to-use-react-context-effectively I condensed his readable boilerplate to my preferred level of DRYness -- reading his sandbox implementation will show you how it actually works.", "Enjoy, I know I am !!", "import React from 'react' // ref: https://kentcdodds.com/blog/how-to-use-react-context-effectively const ApplicationDispatch = React.createContext() const ApplicationContext = React.createContext() function stateReducer(state, action) { if (state.hasOwnProperty(action.type)) { return { ...state, [action.type]: state[action.type] = action.newValue }; } throw new Error(`Unhandled action type: ${action.type}`); } const initialState = { keyCode: '', testCode: '', testMode: false, phoneNumber: '', resultCode: null, mobileInfo: '', configName: '', appConfig: {}, }; function DispatchProvider({ children }) { const [state, dispatch] = React.useReducer(stateReducer, initialState); return ( <ApplicationDispatch.Provider value={dispatch}> <ApplicationContext.Provider value={state}> {children} </ApplicationContext.Provider> </ApplicationDispatch.Provider> ) } function useDispatchable(stateName) { const context = React.useContext(ApplicationContext); const dispatch = React.useContext(ApplicationDispatch); return [context[stateName], newValue => dispatch({ type: stateName, newValue })]; } function useKeyCode() { return useDispatchable('keyCode'); } function useTestCode() { return useDispatchable('testCode'); } function useTestMode() { return useDispatchable('testMode'); } function usePhoneNumber() { return useDispatchable('phoneNumber'); } function useResultCode() { return useDispatchable('resultCode'); } function useMobileInfo() { return useDispatchable('mobileInfo'); } function useConfigName() { return useDispatchable('configName'); } function useAppConfig() { return useDispatchable('appConfig'); } export { DispatchProvider, useKeyCode, useTestCode, useTestMode, usePhoneNumber, useResultCode, useMobileInfo, useConfigName, useAppConfig, } with a usage similar to this: import { useHistory } from \"react-router-dom\"; // https://react-bootstrap.github.io/components/alerts import { Container, Row } from 'react-bootstrap'; import { useAppConfig, useKeyCode, usePhoneNumber } from '../../ApplicationDispatchProvider'; import { ControlSet } from '../../components/control-set'; import { keypadClass } from '../../utils/style-utils'; import { MaskedEntry } from '../../components/masked-entry'; import { Messaging } from '../../components/messaging'; import { SimpleKeypad, HandleKeyPress, ALT_ID } from '../../components/simple-keypad'; export const AltIdPage = () => { const history = useHistory(); const [keyCode, setKeyCode] = useKeyCode(); const [phoneNumber, setPhoneNumber] = usePhoneNumber(); const [appConfig, setAppConfig] = useAppConfig(); const keyPressed = btn => { const maxLen = appConfig.phoneNumberEntry.entryLen; const newValue = HandleKeyPress(btn, phoneNumber).slice(0, maxLen); setPhoneNumber(newValue); } const doSubmit = () => { history.push('s'); } const disableBtns = phoneNumber.length < appConfig.phoneNumberEntry.entryLen; return ( <Container fluid className=\"text-center\"> <Row> <Messaging {...{ msgColors: appConfig.pageColors, msgLines: appConfig.entryMsgs.altIdMsgs }} /> </Row> <Row> <MaskedEntry {...{ ...appConfig.phoneNumberEntry, entryColors: appConfig.pageColors, entryLine: phoneNumber }} /> </Row> <Row> <SimpleKeypad {...{ keyboardName: ALT_ID, themeName: appConfig.keyTheme, keyPressed, styleClass: keypadClass }} /> </Row> <Row> <ControlSet {...{ btnColors: appConfig.buttonColors, disabled: disableBtns, btns: [{ text: 'Submit', click: doSubmit }] }} /> </Row> </Container> ); }; AltIdPage.propTypes = {}; Now everything persists smoothly everywhere across all my pages Nice!", "Thanks Kent!", "useEffect has its own state/lifecycle, it will not update until you pass a function in parameters or effect destroyed.", "object and array spread or rest will not work inside useEffect.", "React.useEffect(() => { console.log(\"effect\"); (async () => { try { let result = await fetch(\"/query/countries\"); const res = await result.json(); let result1 = await fetch(\"/query/projects\"); const res1 = await result1.json(); let result11 = await fetch(\"/query/regions\"); const res11 = await result11.json(); setData({ countries: res, projects: res1, regions: res11 }); } catch {} })(data) }, [setData]) # or use this useEffect(() => { (async () => { try { await Promise.all([ fetch(\"/query/countries\").then((response) => response.json()), fetch(\"/query/projects\").then((response) => response.json()), fetch(\"/query/regions\").then((response) => response.json()) ]).then(([country, project, region]) => { // console.log(country, project, region); setData({ countries: country, projects: project, regions: region }); }) } catch { console.log(\"data fetch error\") } })() }, [setData]); // replace return <p>hello</p>; // with return <p>{JSON.stringify(movies)}</p>; Now you should see, that your code actually does work.", "What does not work is the console.log(movies).", "This is because movies points to the old state.", "If you move your console.log(movies) outside of useEffect, right above the return, you will see the updated movies object.", "I'm reading Forms section of reactjs documentation and just tried this code to demonstrate onChange usage (JSBIN).", "var React= require('react'); var ControlledForm= React.createClass({ getInitialState: function() { return { value: \"initial value\" }; }, handleChange: function(event) { console.log(this.state.value); this.setState({value: event.target.value}); console.log(this.state.value); }, render: function() { return ( <input type=\"text\" value={this.state.value} onChange={this.handleChange}/> ); } }); React.render( <ControlledForm/>, document.getElementById('mount') ); When I update the <input/> value in the browser, the second console.log inside the handleChange callback prints the same value as the first console.log, Why I can't see the result of this.setState({value: event.target.value}) in the scope of handleChange callback?", "From React's documentation: setState() does not immediately mutate this.state but creates a pending state transition.", "Accessing this.state after calling this method can potentially return the existing value.", "There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.", "If you want a function to be executed after the state change occurs, pass it in as a callback.", "this.setState({value: event.target.value}, function () { console.log(this.state.value); }); As mentioned in the React documentation, there is no guarantee of setState being fired synchronously, so your console.log may return the state prior to it updating.", "Michael Parker mentions passing a callback within the setState.", "Another way to handle the logic after state change is via the componentDidUpdate lifecycle method, which is the method recommended in React docs.", "Generally we recommend using componentDidUpdate() for such logic instead.", "This is particularly useful when there may be successive setStates fired, and you would like to fire the same function after every state change.", "Rather than adding a callback to each setState, you could place the function inside of the componentDidUpdate, with specific logic inside if necessary.", "// example componentDidUpdate(prevProps, prevState) { if (this.state.value > prevState.value) { this.foo(); } } You could try using ES7 async/await.", "For instance using your example: handleChange: async function(event) { console.log(this.state.value); await this.setState({value: event.target.value}); console.log(this.state.value); } Watch out the react lifecycle methods\uff01 http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ https://reactjs.org/docs/react-component.html I worked for several hours to find out that getDerivedStateFromProps will be called after every setState().", "\ud83d\ude02 async-await syntax works perfectly for something like the following... changeStateFunction = () => { // Some Worker.. this.setState((prevState) => ({ year: funcHandleYear(), month: funcHandleMonth() })); goNextMonth = async () => { await this.changeStateFunction(); const history = createBrowserHistory(); history.push(`/calendar?year=${this.state.year}&month=${this.state.month}`); } goPrevMonth = async () => { await this.changeStateFunction(); const history = createBrowserHistory(); history.push(`/calendar?year=${this.state.year}&month=${this.state.month}`); } Simply putting - this.setState({data: value}) is asynchronous in nature that means it moves out of the Call Stack and only comes back to the Call Stack unless it is resolved.", "Please read about Event Loop to have a clear picture about Asynchronous nature in JS and why it takes time to update - https://medium.com/front-end-weekly/javascript-event-loop-explained-4cd26af121d4 Hence - this.setState({data:value}); console.log(this.state.data); // will give undefined or unupdated value as it takes time to update.", "To achieve the above process - this.setState({data:value},function () { console.log(this.state.data); });", "With react-router I can use the Link element to create links which are natively handled by react router.", "I see internally it calls this.context.transitionTo(...).", "I want to do a navigation.", "Not from a link, but from a dropdown selection (as an example).", "How can I do this in code?", "What is this.context?", "I saw the Navigation mixin, but can I do this without mixins?", "React Router v5.1.0 with hooks There is a new useHistory hook in React Router >5.1.0 if you are using React >16.8.0 and functional components.", "import { useHistory } from \"react-router-dom\"; function HomeButton() { const history = useHistory(); function handleClick() { history.push(\"/home\"); } return ( <button type=\"button\" onClick={handleClick}> Go home </button> ); } React Router v4 With v4 of React Router, there are three approaches that you can take to programmatic routing within components.", "Use the withRouter higher-order component.", "Use composition and render a <Route> Use the context.", "React Router is mostly a wrapper around the history library.", "history handles interaction with the browser's window.history for you with its browser and hash histories.", "It also provides a memory history which is useful for environments that don't have a global history.", "This is particularly useful in mobile app development (react-native) and unit testing with Node.", "A history instance has two methods for navigating: push and replace.", "If you think of the history as an array of visited locations, push will add a new location to the array and replace will replace the current location in the array with the new one.", "Typically you will want to use the push method when you are navigating.", "In earlier versions of React Router, you had to create your own history instance, but in v4 the <BrowserRouter>, <HashRouter>, and <MemoryRouter> components will create a browser, hash, and memory instances for you.", "React Router makes the properties and methods of the history instance associated with your router available through the context, under the router object.", "1.", "Use the withRouter higher-order component The withRouter higher-order component will inject the history object as a prop of the component.", "This allows you to access the push and replace methods without having to deal with the context.", "import { withRouter } from 'react-router-dom' // this also works with react-router-native const Button = withRouter(({ history }) => ( <button type='button' onClick={() => { history.push('/new-location') }} > Click Me!", "</button> )) 2.", "Use composition and render a <Route> The <Route> component isn't just for matching locations.", "You can render a pathless route and it will always match the current location.", "The <Route> component passes the same props as withRouter, so you will be able to access the history methods through the history prop.", "import { Route } from 'react-router-dom' const Button = () => ( <Route render={({ history}) => ( <button type='button' onClick={() => { history.push('/new-location') }} > Click Me!", "</button> )} /> ) 3.", "Use the context* But you probably should not The last option is one that you should only use if you feel comfortable working with React's context model (React's Context API is stable as of v16).", "const Button = (props, context) => ( <button type='button' onClick={() => { // context.history.push === history.push context.history.push('/new-location') }} > Click Me!", "</button> ) // you need to specify the context type so that it // is available within the component Button.contextTypes = { history: React.PropTypes.shape({ push: React.PropTypes.func.isRequired }) } 1 and 2 are the simplest choices to implement, so for most use cases, they are your best bets.", "React-Router 5.1.0+ Answer (using hooks and React >16.8) You can use the new useHistory hook on Functional Components and Programmatically navigate: import { useHistory } from \"react-router-dom\"; function HomeButton() { let history = useHistory(); // use history.push('/some/path') here }; React-Router 4.0.0+ Answer In 4.0 and above, use the history as a prop of your component.", "class Example extends React.Component { // use `this.props.history.push('/some/path')` here }; NOTE: this.props.history does not exist in the case your component was not rendered by <Route>.", "You should use <Route path=\"...\" component={YourComponent}/> to have this.props.history in YourComponent React-Router 3.0.0+ Answer In 3.0 and above, use the router as a prop of your component.", "class Example extends React.Component { // use `this.props.router.push('/some/path')` here }; React-Router 2.4.0+ Answer In 2.4 and above, use a higher order component to get the router as a prop of your component.", "import { withRouter } from 'react-router'; class Example extends React.Component { // use `this.props.router.push('/some/path')` here }; // Export the decorated class var DecoratedExample = withRouter(Example); // PropTypes Example.propTypes = { router: React.PropTypes.shape({ push: React.PropTypes.func.isRequired }).isRequired }; React-Router 2.0.0+ Answer This version is backwards compatible with 1.x so there's no need to an Upgrade Guide.", "Just going through the examples should be good enough.", "That said, if you wish to switch to the new pattern, there's a browserHistory module inside the router that you can access with import { browserHistory } from 'react-router' Now you have access to your browser history, so you can do things like push, replace, etc... Like: browserHistory.push('/some/path') Further reading: Histories and Navigation React-Router 1.x.x Answer I will not go into upgrading details.", "You can read about that in the Upgrade Guide The main change about the question here is the change from Navigation mixin to History.", "Now it's using the browser historyAPI to change route so we will use pushState() from now on.", "Here's an exemple using Mixin: var Example = React.createClass({ mixins: [ History ], navigateToHelpPage () { this.history.pushState(null, `/help`); } }) Note that this History comes from rackt/history project.", "Not from React-Router itself.", "If you don't want to use Mixin for some reason (maybe because of ES6 class), then you can access the history that you get from the router from this.props.history.", "It will be only accessible for the components rendered by your Router.", "So, if you want to use it in any child components it needs to be passed down as an attribute via props.", "You can read more about the new release at their 1.0.x documentation Here is a help page specifically about navigating outside your component It recommends grabbing a reference history = createHistory() and calling replaceState on that.", "React-Router 0.13.x Answer I got into the same problem and could only find the solution with the Navigation mixin that comes with react-router.", "Here's how I did it import React from 'react'; import {Navigation} from 'react-router'; let Authentication = React.createClass({ mixins: [Navigation], handleClick(e) { e.preventDefault(); this.transitionTo('/'); }, render(){ return (<div onClick={this.handleClick}>Click me!</div>); } }); I was able to call transitionTo() without the need to access .context Or you could try the fancy ES6 class import React from 'react'; export default class Authentication extends React.Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } handleClick(e) { e.preventDefault(); this.context.router.transitionTo('/'); } render(){ return (<div onClick={this.handleClick}>Click me!</div>); } } Authentication.contextTypes = { router: React.PropTypes.func.isRequired }; React-Router-Redux Note: if you're using Redux, there is another project called React-Router-Redux that gives you redux bindings for ReactRouter, using somewhat the same approach that React-Redux does React-Router-Redux has a few methods available that allow for simple navigating from inside action creators.", "These can be particularly useful for people that have existing architecture in React Native, and they wish to utilize the same patterns in React Web with minimal boilerplate overhead.", "Explore the following methods: push(location) replace(location) go(number) goBack() goForward() Here is an example usage, with Redux-Thunk: ./actioncreators.js import { goBack } from 'react-router-redux' export const onBackPress = () => (dispatch) => dispatch(goBack()) ./viewcomponent.js <button disabled={submitting} className=\"cancel_button\" onClick={(e) => { e.preventDefault() this.props.onBackPress() }} > CANCEL </button> React-Router v2 For the most recent release (v2.0.0-rc5), the recommended navigation method is by directly pushing onto the history singleton.", "You can see that in action in the Navigating outside of Components doc.", "Relevant excerpt: import { browserHistory } from 'react-router'; browserHistory.push('/some/path'); If using the newer react-router API, you need to make use of the history from this.props when inside of components so: this.props.history.push('/some/path'); It also offers pushState but that is deprecated per logged warnings.", "If using react-router-redux, it offers a push function you can dispatch like so: import { push } from 'react-router-redux'; this.props.dispatch(push('/some/path')); However this may be only used to change the URL, not to actually navigate to the page.", "Here's how you do this with react-router v2.0.0 with ES6.", "react-router has moved away from mixins.", "import React from 'react'; export default class MyComponent extends React.Component { navigateToPage = () => { this.context.router.push('/my-route') }; render() { return ( <button onClick={this.navigateToPage}>Go!</button> ); } } MyComponent.contextTypes = { router: React.PropTypes.object.isRequired } React-Router 4.x Answer : On my end, I like to have a single history object that I can carry even outside components.", "What I like to do is to have a single history.js file that I import on demand, and just manipulate it.", "You just have to change BrowserRouter to Router, and specify the history prop.", "This doesn't change anything for you except that you have your own history object that you can manipulate as you want.", "You need to install history, the library used by react-router.", "Example usage, ES6 notation : history.js import createBrowserHistory from 'history/createBrowserHistory' export default createBrowserHistory() BasicComponent.js import React, { Component } from 'react'; import history from './history'; class BasicComponent extends Component { goToIndex(e){ e.preventDefault(); history.push('/'); } render(){ return <a href=\"#\" onClick={this.goToIndex}>Previous</a>; } } EDIT April 16th, 2018 : If you have to navigate from a component that is actually rendered from a Route component, you can also access history from props, like that : BasicComponent.js import React, { Component } from 'react'; class BasicComponent extends Component { navigate(e){ e.preventDefault(); this.props.history.push('/url'); } render(){ return <a href=\"#\" onClick={this.navigate}>Previous</a>; } } For this one, who does not control the server side and because of this is using hash router v2: Place your history into separate file (e.g.", "app_history.js ES6): import { useRouterHistory } from 'react-router' import { createHashHistory } from 'history' const appHistory = useRouterHistory(createHashHistory)({ queryKey: false }); export default appHistory; And use it everywhere!", "Your entry point for react-router (app.js ES6): import React from 'react' import { render } from 'react-dom' import { Router, Route, Redirect } from 'react-router' import appHistory from './app_history' ... const render(( <Router history={appHistory}> ... </Router> ), document.querySelector('[data-role=\"app\"]')); Your navigation inside any component (ES6): import appHistory from '../app_history' ... ajaxLogin('/login', (err, data) => { if (err) { console.error(err); // login failed } else { // logged in appHistory.replace('/dashboard'); // or .push() if you don't need .replace() } }) EDIT: React Router v6 I haven't touched React in a while, but want to thank and highlight the comment below by @Shimrit Snapir on React-Router 6.0 <Redirect /> changed to <Navigate /> React Router V4 tl:dr; if (navigate) { return <Redirect to=\"/\" push={true} /> } The simple and declarative answer is that you need to use <Redirect to={URL} push={boolean} /> in combination with setState() push: boolean - when true, redirecting will push a new entry onto the history instead of replacing the current one.", "import { Redirect } from 'react-router' class FooBar extends React.Component { state = { navigate: false } render() { const { navigate } = this.state // here is the important part if (navigate) { return <Redirect to=\"/\" push={true} /> } // ^^^^^^^^^^^^^^^^^^^^^^^ return ( <div> <button onClick={() => this.setState({ navigate: true })}> Home </button> </div> ) } } Full example here.", "Read more here.", "PS.", "The example uses ES7+ Property Initializers to initialise state.", "Look here as well, if you're interested.", "Warning: this answer covers only ReactRouter versions before 1.0 I will update this answer with 1.0.0-rc1 use cases after!", "You can do this without mixins too.", "let Authentication = React.createClass({ contextTypes: { router: React.PropTypes.func }, handleClick(e) { e.preventDefault(); this.context.router.transitionTo('/'); }, render(){ return (<div onClick={this.handleClick}>Click me!</div>); } }); The gotcha with contexts is that it is not accessible unless you define the contextTypes on the class.", "As for what is context, it is an object, like props, that are passed down from parent to child, but it is passed down implicitly, without having to redeclare props each time.", "See https://www.tildedave.com/2014/11/15/introduction-to-contexts-in-react-js.html I tried at least 10 ways of doing this before something worked right!", "@Felipe Skinner's withRouter answer was a bit overwhelming to me, and I wasn't sure I wanted to make new \"ExportedWithRouter\" class names.", "Here's the simplest and cleanest way to do it, circa current React-Router 3.0.0 and ES6: React-Router 3.x.x with ES6: import { withRouter } from 'react-router'; class Example extends React.Component { // use `this.props.router.push('/some/path')` here }; // Export the decorated class export default withRouter(Example); or, if it's not your default class, export like: withRouter(Example); export { Example }; Note that in 3.x.x, the <Link> component itself is using router.push, so you can pass it anything you would pass the <Link to= tag, like: this.props.router.push({pathname: '/some/path', query: {key1: 'val1', key2: 'val2'})' To do the navigation programmatically, you need to push a new history to the props.history in your component, so something like this can do the work for you: //using ES6 import React from 'react'; class App extends React.Component { constructor(props) { super(props) this.handleClick = this.handleClick.bind(this) } handleClick(e) { e.preventDefault() /* Look at here, you can add it here */ this.props.history.push('/redirected'); } render() { return ( <div> <button onClick={this.handleClick}> Redirect!!!", "</button> </div> ) } } export default App; May not be the best approach but...", "Using react-router v4, the following Typescript could give an idea for some.", "In the rendered component below, e.g.", "LoginPage, router object is accessible and just call router.transitionTo('/homepage') to navigate.", "Navigation code was taken from.", "\"react-router\": \"^4.0.0-2\", \"react\": \"^15.3.1\", import Router from 'react-router/BrowserRouter'; import { History } from 'react-history/BrowserHistory'; import createHistory from 'history/createBrowserHistory'; const history = createHistory(); interface MatchWithPropsInterface { component: typeof React.Component, router: Router, history: History, exactly?", ": any, pattern: string } class MatchWithProps extends React.Component<MatchWithPropsInterface,any> { render() { return( <Match {...this.props} render={(matchProps) => ( React.createElement(this.props.component, this.props) )} /> ) } } ReactDOM.render( <Router> {({ router }) => ( <div> <MatchWithProps exactly pattern=\"/\" component={LoginPage} router={router} history={history} /> <MatchWithProps pattern=\"/login\" component={LoginPage} router={router} history={history} /> <MatchWithProps pattern=\"/homepage\" component={HomePage} router={router} history={history} /> <Miss component={NotFoundView} /> </div> )} </Router>, document.getElementById('app') ); For ES6 + React components, the following solution worked for me.", "I followed Felippe skinner, but added an end to end solution to help beginners like me.", "Below are the versions I used: \"react-router\": \"^2.7.0\" \"react\": \"^15.3.1\" Below is my react component where I used programmatic navigation using react-router: import React from 'react'; class loginComp extends React.Component { constructor( context) { super(context); this.state = { uname: '', pwd: '' }; } redirectToMainPage(){ this.context.router.replace('/home'); } render(){ return <div> // skipping html code <button onClick={this.redirectToMainPage.bind(this)}>Redirect</button> </div>; } }; loginComp.contextTypes = { router: React.PropTypes.object.isRequired } module.exports = loginComp; Below is the configuration for my router: import { Router, Route, IndexRedirect, browserHistory } from 'react-router' render(<Router history={browserHistory}> <Route path='/' component={ParentComp}> <IndexRedirect to = \"/login\"/> <Route path='/login' component={LoginComp}/> <Route path='/home' component={HomeComp}/> <Route path='/repair' component={RepairJobComp} /> <Route path='/service' component={ServiceJobComp} /> </Route> </Router>, document.getElementById('root')); In React-Router v4 and ES6 You can use withRouter and this.props.history.push.", "import {withRouter} from 'react-router-dom'; class Home extends Component { componentDidMount() { this.props.history.push('/redirect-to'); } } export default withRouter(Home); To use withRouter with a class-based component, try something like this below.", "Don't forget to change the export statement to use withRouter: import { withRouter } from 'react-router-dom' class YourClass extends React.Component { yourFunction = () => { doSomeAsyncAction(() => this.props.history.push('/other_location') ) } render() { return ( <div> <Form onSubmit={ this.yourFunction } /> </div> ) } } export default withRouter(YourClass); with React-Router v4 on the horizon, there is now a new way of doing this.", "import { MemoryRouter, BrowserRouter } from 'react-router'; const navigator = global && global.navigator && global.navigator.userAgent; const hasWindow = typeof window !== 'undefined'; const isBrowser = typeof navigator !== 'undefined' && navigator.indexOf('Node.js') === -1; const Router = isBrowser ?", "BrowserRouter : MemoryRouter; <Router location=\"/page-to-go-to\"/> react-lego is an example app that shows how to use/update react-router and it includes example functional tests which navigate the app.", "based on the previous answer from Jos\u00c3\u00a9 Antonio Postigo and Ben Wheeler the novelty?", "is to be written in Typescript and the use of decorators OR static property/field import * as React from \"react\"; import Component = React.Component; import { withRouter } from \"react-router\"; export interface INavigatorProps { router?", ": ReactRouter.History.History; } /** * Note: goes great with mobx * @inject(\"something\") @withRouter @observer */ @withRouter export class Navigator extends Component<INavigatorProps, {}>{ navigate: (to: string) => void; constructor(props: INavigatorProps) { super(props); let self = this; this.navigate = (to) => self.props.router.push(to); } render() { return ( <ul> <li onClick={() => this.navigate(\"/home\")}> Home </li> <li onClick={() => this.navigate(\"/about\")}> About </li> </ul> ) } } /** * Non decorated */ export class Navigator2 extends Component<INavigatorProps, {}> { static contextTypes = { router: React.PropTypes.object.isRequired, }; navigate: (to: string) => void; constructor(props: INavigatorProps, context: any) { super(props, context); let s = this; this.navigate = (to) => s.context.router.push(to); } render() { return ( <ul> <li onClick={() => this.navigate(\"/home\")}> Home </li> <li onClick={() => this.navigate(\"/about\")}> About </li> </ul> ) } } with whatever npm installed today.", "\"react-router\": \"^3.0.0\" and \"@types/react-router\": \"^2.0.41\" In react router v4.", "I follow this two way to route programmatically.", "1. this.props.history.push(\"/something/something\") 2. this.props.history.replace(\"/something/something\") Number two Replaces the current entry on the history stack To get history in props you may have to wrap your component with withRouter If you are using hash or browser history then you can do hashHistory.push('/login'); browserHistory.push('/login'); With the current React version (15.3), this.props.history.push('/location'); worked for me, but it showed the following warning: browser.js:49 Warning: [react-router] props.history and context.history are deprecated.", "Please use context.router.", "and I solved it using context.router like this: import React from 'react'; class MyComponent extends React.Component { constructor(props) { super(props); this.backPressed = this.backPressed.bind(this); } backPressed() { this.context.router.push('/back-location'); } ... } MyComponent.contextTypes = { router: React.PropTypes.object.isRequired }; export default MyComponent; React-Router V4 if you're using version 4 then you can use my library (Shameless plug) where you simply dispatch an action and everything just works!", "dispatch(navigateTo(\"/aboutUs\")); trippler Those who are facing issues in implementing this on react-router v4.", "Here is a working solution for navigating through the react app from redux actions.", "history.js import createHistory from 'history/createBrowserHistory' export default createHistory() App.js/Route.jsx import { Router, Route } from 'react-router-dom' import history from './history' ... <Router history={history}> <Route path=\"/test\" component={Test}/> </Router> another_file.js OR redux file import history from './history' history.push('/test') // this should change the url and re-render Test component All thanks to this comment: ReactTraining issues comment You can also use the useHistory hook in a stateless component.", "Example from the docs.", "import { useHistory } from \"react-router\" function HomeButton() { const history = useHistory() return ( <button type=\"button\" onClick={() => history.push(\"/home\")}> Go home </button> ) } Note: Hooks were added in react-router@5.1.0 and require react@>=16.8 The right answer was for me at the time of writing this.context.router.history.push('/'); But you need to add PropTypes to your component Header.contextTypes = { router: PropTypes.object.isRequired } export default Header; Don't forget to import PropTypes import PropTypes from 'prop-types'; Maybe not the best solution but it gets the job done: import { Link } from 'react-router-dom'; // create functional component Post export default Post = () => ( <div className=\"component post\"> <button className=\"button delete-post\" onClick={() => { // ... delete post // then redirect, without page reload, by triggering a hidden Link document.querySelector('.trigger.go-home').click(); }}>Delete Post</button> <Link to=\"/\" className=\"trigger go-home hidden\"></Link> </div> ); Basically, a logic tied to one action (in this case a post deletion) will end up calling a trigger for redirect.", "This is not ideal because you will add a DOM node 'trigger' to your markup just so you can conveniently call it when needed.", "Also, you will directly interact with the DOM, which in a React component may not be desired.", "Still, this type of redirect is not required that often.", "So one or two extra, hidden links in your component markup would not hurt that much, especially if you give them meaningful names.", "If happen to pair RR4 w/ redux through react-router-redux, use the routing action creators from react-router-redux is a option as well.", "import { push, replace, ... } from 'react-router-redux' class WrappedComponent extends React.Component { handleRedirect(url, replaceState = true) { replaceState ?", "this.props.dispatch(replace(url)) : this.props.dispatch(push(url)) } render() { ... } } export default connect(null)(WrappedComponent) If use redux thunk/saga to manage async flow, import the above action creators in redux actions and hook to react components using mapDispatchToProps might be better.", "Update : React Router v6 with hooks import {useNavigate} from 'react-router-dom'; let navigate = useNavigate(); navigate('home'); And to move across the browser history, navigate(-1); ---> Go back navigate(1); ---> Go forward navigate(-2); ---> Move two steps backward.", "This worked for me, no special imports needed: <input type=\"button\" name=\"back\" id=\"back\" class=\"btn btn-primary\" value=\"Back\" onClick={() => { this.props.history.goBack() }} /> Try hookrouter instead, \"the modern alternative to react-router\" https://www.npmjs.com/package/hookrouter import { useRoutes, usePath, A} from \"hookrouter\"; to answer OP question about linking through select box you can do it: navigate('/about'); *** UPDATED ANSWER *** I think hook-router was a good starter kit and helped me learn about routing but have since updated to react-router for it's history and query parameter handling.", "import { useLocation, useHistory } from 'react-router-dom'; const Component = (props) => { const history = useHistory(); // Programmatically navigate history.push(newUrlString); } You push where you want to navigate into the location.history.", "For React Router v4+ Assuming that you won't be needing to navigate during the initial render itself (for which you can use <Redirect> component), this is what we are doing in our app.", "Define an empty route which returns null, this will allow you to get the access to the history object.", "You need to do this at the top level where your Router is defined.", "Now you can do all the things that can be done on history like history.push(), history.replace(), history.go(-1) etc!", "import React from 'react'; import { HashRouter, Route } from 'react-router-dom'; let routeHistory = null; export function navigateTo(path) { if(routeHistory !== null) { routeHistory.push(path); } } export default function App(props) { return ( <HashRouter hashType=\"noslash\"> <Route render={({ history }) => { routeHistory = history; return null; }} /> {/* Rest of the App */} </HashRouter> ); } react-router-dom: 5.1.2 This site has 3 pages, all of which are rendered dynamically in the browser.", "Although the page does not ever refresh, notice how React Router keeps the URL up to date as you navigate through the site.", "This preserves the browser history, making sure things like the back button and bookmarks work properly A Switch looks through all its children elements and renders the first one whose path matches the current URL.", "Use a any time you have multiple routes, but you want only one of them to render at a time import React from \"react\"; import { BrowserRouter as Router, Switch, Route, Link } from \"react-router-dom\"; export default function BasicExample() { return ( <Router> <div> <ul> <li> <Link to=\"/\">Home</Link> </li> <li> <Link to=\"/about\">About</Link> </li> <li> <Link to=\"/dashboard\">Dashboard</Link> </li> </ul> <hr /> <Switch> <Route exact path=\"/\"> <Home /> </Route> <Route path=\"/about\"> <About /> </Route> <Route path=\"/dashboard\"> <Dashboard /> </Route> </Switch> </div> </Router> ); } // You can think of these components as \"pages\" // in your app.", "function Home() { return ( <div> <h2>Home</h2> </div> ); } function About() { return ( <div> <h2>About</h2> </div> ); } function Dashboard() { return ( <div> <h2>Dashboard</h2> </div> ); }```", "I'm using React-router and it works fine while I'm clicking on link buttons, but when I refresh my webpage it does not load what I want.", "For instance, I am in localhost/joblist and everything is fine because I arrived here pressing a link.", "But If I refresh the webpage I get: Cannot GET /joblist By default, it didn't work like this.", "Initially I had my URL as localhost/#/ and localhost/#/joblist and they worked perfectly fine.", "But I don't like this kind of URL, so trying to erase that #, I wrote: Router.run(routes, Router.HistoryLocation, function (Handler) { React.render(<Handler/>, document.body); }); This problem does not happen with localhost/, this one always returns what I want.", "EDIT: This app is single-page, so /joblist doesn't need to ask anything to any server.", "EDIT2: My entire router.", "var routes = ( <Route name=\"app\" path=\"/\" handler={App}> <Route name=\"joblist\" path=\"/joblist\" handler={JobList}/> <DefaultRoute handler={Dashboard}/> <NotFoundRoute handler={NotFound}/> </Route> ); Router.run(routes, Router.HistoryLocation, function (Handler) { React.render(<Handler/>, document.body); }); Looking at the comments on the accepted answer and the generic nature of this question ('don't work'), I thought this might be a good place for some general explanations about the issues involved here.", "So this answer is intended as background info / elaboration on the specific use case of the OP.", "Please bear with me.", "Server-side vs Client-side The first big thing to understand about this is that there are now 2 places where the URL is interpreted, whereas there used to be only 1 in 'the old days'.", "In the past, when life was simple, some user sent a request for http://example.com/about to the server, which inspected the path part of the URL, determined the user was requesting the about page and then sent back that page.", "With client-side routing, which is what React-Router provides, things are less simple.", "At first, the client does not have any JS code loaded yet.", "So the very first request will always be to the server.", "That will then return a page that contains the needed script tags to load React and React Router etc.", "Only when those scripts have loaded does phase 2 start.", "In phase 2, when the user clicks on the 'About us' navigation link for example, the URL is changed locally only to http://example.com/about (made possible by the History API), but no request to the server is made.", "Instead, React Router does its thing on the client side, determines which React view to render and renders it.", "Assuming your about page does not need to make any REST calls, it's done already.", "You have transitioned from Home to About Us without any server request having fired.", "So basically when you click a link, some Javascript runs that manipulates the URL in the address bar, without causing a page refresh, which in turn causes React Router to perform a page transition on the client side.", "But now consider what happens if you copy-paste the URL in the address bar and e-mail it to a friend.", "Your friend has not loaded your website yet.", "In other words, she is still in phase 1.", "No React Router is running on her machine yet.", "So her browser will make a server request to http://example.com/about.", "And this is where your trouble starts.", "Until now, you could get away with just placing a static HTML at the webroot of your server.", "But that would give 404 errors for all other URLs when requested from the server.", "Those same URLs work fine on the client side, because there React Router is doing the routing for you, but they fail on the server side unless you make your server understand them.", "Combining server- and client-side routing If you want the http://example.com/about URL to work on both the server- and the client-side, you need to set up routes for it on both the server- and the client side.", "Makes sense right?", "And this is where your choices begin.", "Solutions range from bypassing the problem altogether, via a catch-all route that returns the bootstrap HTML, to the full-on isomorphic approach where both the server and the client run the same JS code.", ".", "Bypassing the problem altogether: Hash History With Hash History instead of Browser History, your URL for the about page would look something like this: http://example.com/#/about The part after the hash (#) symbol is not sent to the server.", "So the server only sees http://example.com/ and sends the index page as expected.", "React-Router will pick up the #/about part and show the correct page.", "Downsides: 'ugly' URLs Server-side rendering is not possible with this approach.", "As far as Search Engine Optimization (SEO) is concerned, your website consists of a single page with hardly any content on it.", ".", "Catch-all With this approach you do use Browser History, but just set up a catch-all on the server that sends /* to index.html, effectively giving you much the same situation as with Hash History.", "You do have clean URLs however and you could improve upon this scheme later without having to invalidate all your user's favorites.", "Downsides: More complex to set up Still no good SEO .", "Hybrid In the hybrid approach you expand upon the catch-all scenario by adding specific scripts for specific routes.", "You could make some simple PHP scripts to return the most important pages of your site with content included, so Googlebot can at least see what's on your page.", "Downsides: Even more complex to set up Only good SEO for those routes you give the special treatment Duplicating code for rendering content on server and client .", "Isomorphic What if we use Node JS as our server so we can run the same JS code on both ends?", "Now, we have all our routes defined in a single react-router config and we don't need to duplicate our rendering code.", "This is 'the holy grail' so to speak.", "The server sends the exact same markup as we would end up with if the page transition had happened on the client.", "This solution is optimal in terms of SEO.", "Downsides: Server must (be able to) run JS.", "I've experimented with Java i.c.w.", "Nashorn but it's not working for me.", "In practice it mostly means you must use a Node JS based server.", "Many tricky environmental issues (using window on server-side etc) Steep learning curve .", "Which should I use?", "Choose the one that you can get away with.", "Personally I think the catch-all is simple enough to set up, so that would be my minimum.", "This setup allows you to improve on things over time.", "If you are already using Node JS as your server platform, I'd definitely investigate doing an isomorphic app.", "Yes it's tough at first, but once you get the hang of it it's actually a very elegant solution to the problem.", "So basically, for me, that would be the deciding factor.", "If my server runs on Node JS, I'd go isomorphic; otherwise I would go for the Catch-all solution and just expand on it (Hybrid solution) as time progresses and SEO requirements demand it.", "If you'd like to learn more on isomorphic (also called 'universal') rendering with React, there are some good tutorials on the subject: React to the future with isomorphic apps The Pain and the Joy of creating isomorphic apps in ReactJS How to Implement Node + React Isomorphic JavaScript & Why it Matters Also, to get you started, I recommend looking at some starter kits.", "Pick one that matches your choices for the technology stack (remember, React is just the V in MVC, you need more stuff to build a full app).", "Start with looking at the one published by Facebook itself: Create React App Or pick one of the many by the community.", "There is a nice site now that tries to index all of them: Pick your perfect React starter project I started with these: React Isomorphic Starterkit React Redux Universal Hot Example Currently I am using a home-brew version of universal rendering that was inspired by the two starter kits above, but they are out of date now.", "Good luck with your quest!", "The answers here are all extremely helpful, what worked for me was configuring my Webpack server to expect the routes.", "devServer: { historyApiFallback: true, contentBase: './', hot: true }, The historyApiFallback is what fixed this issue for me.", "Now routing works correctly and I can refresh the page or type in the URL directly.", "No need to worry about work arounds on your node server.", "This answer obviously only works if you're using webpack.", "EDIT: see my answer here for a more detailed reason why this is necessary: https://stackoverflow.com/a/37622953/5217568 You can change your .htaccess file and insert this: <IfModule mod_rewrite.c> RewriteEngine On RewriteBase / RewriteRule ^index\\.html$ - [L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-l RewriteRule .", "/index.html [L] </IfModule> I am using react: \"^16.12.0\" and react-router: \"^5.1.2\" This method is the Catch-all and is probably the easiest way to get you started.", "For React Router V4 Users: If you try to solve this problem by Hash History technique mentioned in other answers, note that <Router history={hashHistory} > does not work in V4, please use HashRouter instead: import { HashRouter } from 'react-router-dom' <HashRouter> <App/> </HashRouter> Reference: HashRouter I used create-react-app to make a website just now and had the same issue presented here.", "I use BrowserRouting from the react-router-dom package.", "I am running on a Nginx server and what solved it for me was adding the following to /etc/nginx/yourconfig.conf location / { if (!-e $request_filename){ rewrite ^(.", "*)$ /index.html break; } } Which corresponds to adding the following to the .htaccess in case you are running Appache Options -MultiViews RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.html [QSA,L] This also seems to be the solution suggested by Facebook themselves and can be found here In your index.html head, add the following: <base href=\"/\"> <!-- This must come before the css and javascripts --> Then when running with webpack dev server use this command.", "webpack-dev-server --mode development --hot --inline --content-base=dist --history-api-fallback --history-api-fallback is the important part The router can be called in two different ways, depending on whether the navigation occurs on the client or on the server.", "You have it configured for client-side operation.", "The key parameter is the second one to the run method, the location.", "When you use the React Router Link component, it blocks browser navigation and calls transitionTo to do a client-side navigation.", "You are using HistoryLocation, so it uses the HTML5 history API to complete the illusion of navigation by simulating the new URL in the address bar.", "If you're using older browsers, this won't work.", "You would need to use the HashLocation component.", "When you hit refresh, you bypass all of the React and React Router code.", "The server gets the request for /joblist and it must return something.", "On the server you need to pass the path that was requested to the run method in order for it to render the correct view.", "You can use the same route map, but you'll probably need a different call to Router.run.", "As Charles points out, you can use URL rewriting to handle this.", "Another option is to use a node.js server to handle all requests and pass the path value as the location argument.", "In express, for example, it might look like this: var app = express(); app.get('*', function (req, res) { // This wildcard method handles all requests Router.run(routes, req.path, function (Handler, state) { var element = React.createElement(Handler); var html = React.renderToString(element); res.render('main', { content: html }); }); }); Note that the request path is being passed to run.", "To do this, you'll need to have a server-side view engine that you can pass the rendered HTML to.", "There are a number of other considerations using renderToString and in running React on the server.", "Once the page is rendered on the server, when your app loads in the client, it will render again, updating the server-side rendered HTML as needed.", "If you're hosting a react app via AWS Static S3 Hosting & CloudFront This problem presented itself by CloudFront responding with a 403 Access Denied message because it expected /some/other/path to exist in my S3 folder, but that path only exists internally in React's routing with react-router.", "The solution was to set up a distribution Error Pages rule.", "Go to the CloudFront settings and choose your distribution.", "Next go to the \"Error Pages\" tab.", "Click \"Create Custom Error Response\" and add an entry for 403 since that's the error status code we get.", "Set the Response Page Path to /index.html and the status code to 200.", "The end result astonishes me with its simplicity.", "The index page is served, but the URL is preserved in the browser, so once the react app loads, it detects the URL path and navigates to the desired route.", "Error Pages 403 Rule This can solve your problem I also faced the same problem in the ReactJS application in Production mode.", "Here is the 2 solution to the problem.", "1.Change the routing history to \"hashHistory\" instead of browserHistory in the place of <Router history={hashHistory} > <Route path=\"/home\" component={Home} /> <Route path=\"/aboutus\" component={AboutUs} /> </Router> Now build the app using the command sudo npm run build Then place the build folder in your var/www/ folder, Now the application is working fine with the addition of # tag in each and every URL.", "like localhost/#/home localhost/#/aboutus Solution 2: Without # tag using browserHistory, Set your history = {browserHistory} in your Router, Now build it using sudo npm run build.", "You need to create the \"conf\" file to solve the 404 not found page, the conf file should be like this.", "open your terminal type the below commands cd /etc/apache2/sites-available ls nano sample.conf Add the below content in it.", "<VirtualHost *:80> ServerAdmin admin@0.0.0.0 ServerName 0.0.0.0 ServerAlias 0.0.0.0 DocumentRoot /var/www/html/ ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined <Directory \"/var/www/html/\"> Options Indexes FollowSymLinks AllowOverride all Require all granted </Directory> </VirtualHost> Now you need to enable the sample.conf file by using the following command cd /etc/apache2/sites-available sudo a2ensite sample.conf then it will ask you to reload the apache server, using sudo service apache2 reload or restart then open your localhost/build folder and add the .htaccess file with the content of below.", "RewriteEngine On RewriteBase / RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-l RewriteRule ^.", "*$ / [L,QSA] Now the app is working normally.", "Note: change 0.0.0.0 IP to your local IP address.", "If any doubts regarding this feel free to raise a comment.", "I hope it is helpful to others.", "If you are hosting your react app on IIS, just add a web.config file containing : <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <system.webServer> <httpErrors errorMode=\"Custom\" existingResponse=\"Replace\"> <remove statusCode=\"404\" subStatusCode=\"-1\" /> <error statusCode=\"404\" path=\"/\" responseMode=\"ExecuteURL\" /> </httpErrors> </system.webServer> </configuration> This will tell IIS server to return the main page to the client instead of 404 error and no need to use hash history.", "The Webpack Dev Server has an option to enable this.", "Open up package.json and add --history-api-fallback.", "This solutions worked for me.", "react-router-tutorial If you are using Create React App: There's a great walk though of this issue with solutions for many major hosting platforms that you can find HERE on the Create React App page.", "For example, I use React Router v4 and Netlify for my frontend code.", "All it took was adding 1 file to my public folder (\"_redirects\") and one line of code in that file: /* /index.html 200 Now my website properly renders paths like mysite.com/pricing when entered into the browser or when someone hits refresh.", "Add this to webpack.config.js: devServer: { historyApiFallback: true } Production stack: React, React Router v4, BrowswerRouter, Express, Nginx 1) User BrowserRouter for pretty urls // app.js import { BrowserRouter as Router } from 'react-router-dom' const App = () { render() { return ( <Router> // your routes here </Router> ) } } 2) Add index.html to all unknown requests by using /* // server.js app.get('/*', function(req, res) { res.sendFile(path.join(__dirname, 'path/to/your/index.html'), function(err) { if (err) { res.status(500).send(err) } }) }) 3) bundle webpack with webpack -p 4) run nodemon server.js or node server.js EDIT: You may want to let nginx handle this in the server block and disregard step 2: location / { try_files $uri /index.html; } Try adding \".htaccess\" file inside the public folder with the below code.", "RewriteEngine On RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -f [OR] RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -d RewriteRule ^ - [L] RewriteRule ^ /index.html [L] If you do have a fallback to your index.html, make sure that in your index.html file you have this: <script> System.config({ baseURL: '/' }); </script> This may differ from project to project.", "If you're using firebase all you have to do is make sure you've got a rewrites property in your firebase.json file in the root of your app (in the hosting section).", "For example: { \"hosting\": { \"rewrites\": [{ \"source\":\"**\", \"destination\": \"/index.html\" }] } } Hope this saves somebody else a hoard of frustration and wasted time.", "Happy coding... Further reading on the subject: https://firebase.google.com/docs/hosting/full-config#rewrites Firebase CLI: \"Configure as a single-page app (rewrite all urls to /index.html)\" I found the solution for my SPA with react router (Apache).", "Just add in .htaccess <IfModule mod_rewrite.c> RewriteEngine On RewriteBase / RewriteRule ^index\\.html$ - [L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-l RewriteRule .", "/index.html [L] </IfModule> source: https://gist.github.com/alexsasharegan/173878f9d67055bfef63449fa7136042 I'm not using server side rendering yet but I hit the same problem as the OP where Link seemed to work fine most of the time but failed when I had a parameter.", "I'll document my solution here to see if it helps anyone.", "My main jsx contains this: <Route onEnter={requireLogin} path=\"detail/:id\" component={ModelDetail} /> This works fine for the first matching link but when the :id changes in <Link> expressions nested on that model's detail page, the url changes in the browser bar but the content of the page did not initially change to reflect the linked model.", "The trouble was that I had used the props.params.id to set the model in componentDidMount.", "The component is just mounted once so this means that the first model is the one that sticks on the page and the subsequent Links change the props but leave the page looking unchanged.", "Setting the model in the component state in both componentDidMount and in componentWillReceiveProps (where it is based on the next props) solves the problem and the page content changes to reflect the desired model.", "This topic is a little bit old and solved but I would like to suggest you a simply, clear and better solution.", "It works if you use web server.", "Each web server has an ability to redirect the user to an error page in case of http 404.", "To solve this issue you need to redirect user to the index page.", "If you use Java base server (tomcat or any java application server) the solution could be the following: web.xml: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"> <!-- WELCOME FILE LIST --> <welcome-file-list> <welcome-file>index.jsp</welcome-file> </welcome-file-list> <!-- ERROR PAGES DEFINITION --> <error-page> <error-code>404</error-code> <location>/index.jsp</location> </error-page> </web-app> Example: GET http://example.com/about Web server throws http 404 because this page does not exist on the server side the error page configuration tells to the server that send the index.jsp page back to the user then JS will do the rest of the job on the clien side because the url on the client side is still http://example.com/about.", "That is it, no more magic needs:) For those who are using IIS 10, this is what you should do to make this right.", "Be sure that you are using browserHistory with this.", "As for reference I will give the code for the routing, but this is not what matters, what matters is the next step after the component code below: class App extends Component { render() { return ( <Router history={browserHistory}> <div> <Root> <Switch> <Route exact path={\"/\"} component={Home} /> <Route path={\"/home\"} component={Home} /> <Route path={\"/createnewproject\"} component={CreateNewProject} /> <Route path={\"/projects\"} component={Projects} /> <Route path=\"*\" component={NotFoundRoute} /> </Switch> </Root> </div> </Router> ) } } render (<App />, window.document.getElementById(\"app\")); Since the problem is IIS receives request from client browsers, it will interpret the URL as if it is asking for a page, then returns a 404 page since there is no available page.", "Do the following: Open IIS Expand Server then open the Sites Folder Click the website/application Go to the Error Pages Open the 404 error status item in the list Instead of the option \"Insert content from static file into the error response\", change it to \"Execute a URL on this site\" and add \"/\" slash value to the URL.", "And it will now work fine.", "I hope it helps.", ":-) If you are using Express or some other framework in the backend , you can add the similar configuration as below and check out the Webpack public path in the configuration, it should work fine even on reload if you are using BrowserRouter expressApp.get('/*', (request, response) => { response.sendFile(path.join(__dirname, '../public/index.html')); }); Fixing the \"cannot GET /URL\" error on refresh or on calling the URL directly.", "Configure your webpack.config.js to expect the given link the routes like this.", "module.exports = { entry: './app/index.js', output: { path: path.join(__dirname, '/bundle'), filename: 'index_bundle.js', publicPath: '/' }, As I am using .Net Core MVC something like this helped me: public class HomeController : Controller { public IActionResult Index() { var url = Request.Path + Request.QueryString; return App(url); } [Route(\"App\")] public IActionResult App(string url) { return View(\"/wwwroot/app/build/index.html\"); } } Basically in MVC side, all the routes not matching will fall into to Home/Index as it specified in startup.cs.", "Inside Index it is possible to get the original request url and pass it wherever needed.", "startup.cs app.UseMvc(routes => { routes.MapRoute( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?", "}\"); routes.MapSpaFallbackRoute( name: \"spa-fallback\", defaults: new { controller = \"Home\", action = \"Index\" }); }); If you are hosting in IIS ; Adding this to my webconfig solved my problem <httpErrors errorMode=\"Custom\" defaultResponseMode=\"ExecuteURL\"> <remove statusCode=\"500\" subStatusCode=\"100\" /> <remove statusCode=\"500\" subStatusCode=\"-1\" /> <remove statusCode=\"404\" subStatusCode=\"-1\" /> <error statusCode=\"404\" path=\"/\" responseMode=\"ExecuteURL\" /> <error statusCode=\"500\" prefixLanguageFilePath=\"\" path=\"/error_500.asp\" responseMode=\"ExecuteURL\" /> <error statusCode=\"500\" subStatusCode=\"100\" path=\"/error_500.asp\" responseMode=\"ExecuteURL\" /> </httpErrors> You can make similar configuration for any other server Using HashRouter worked for me with Redux also, just simply replace: import { Router //replace Router } from \"react-router-dom\"; ReactDOM.render( <LocaleProvider locale={enUS}> <Provider store={Store}> <Router history={history}> //replace here saying Router <Layout/> </Router> </Provider> </LocaleProvider>, document.getElementById(\"app\")); registerServiceWorker(); to: import { HashRouter //replaced with HashRouter } from \"react-router-dom\"; ReactDOM.render( <LocaleProvider locale={enUS}> <Provider store={Store}> <HashRouter history={history}> //replaced with HashRouter <Layout/> </HashRouter> </Provider> </LocaleProvider>, document.getElementById(\"app\")); registerServiceWorker(); In case, anyone is here looking for solution on React JS SPA with Laravel.", "The accepted answer is the best explanation of why such problems happen.", "As already explained you have to configure both client side and server side.", "In your blade template, include the js bundled file, make sure to use URL facade like this <script src=\"{{ URL::to('js/user/spa.js') }}\"></script> In your routes, make sure add this to the main endpoint where the blade template is.", "For example, Route::get('/setting-alerts', function () { return view('user.set-alerts'); }); The above is the main endpoint for the blade template.", "Now add an optional route too, Route::get('/setting-alerts/{spa?", "}', function () { return view('user.set-alerts'); }); The problem that happens is that first the blade template is loaded, then the react router.", "So, when you're loading '/setting-alerts', it loads the html and the js.", "But when you load '/setting-alerts/about', it first loads on the server side.", "Since on the server side, there is nothing on this location, it returns not found.", "When you have that optional router, it loads that same page and react router is also loaded, then react loader decides which component to show.", "Hope this helps.", "I am using WebPack, I had same problem Solution=> In your server.js file const express = require('express'); const app = express(); app.use(express.static(path.resolve(__dirname, '../dist'))); app.get('*', function (req, res) { res.sendFile(path.resolve(__dirname, '../dist/index.html')); // res.end(); }); Why doesn't my application render after refreshing?", "you can try reading this all though it's not mine: https://www.andreasreiterer.at/fix-browserrouter-on-apache/ Fixing the app\u2019s routing Now here\u2019s how to finally fix the routing.", "To tell Apache to redirect requests to index.html where our app lives, we have to modify the .htaccess file.", "If there is no such file in your app\u2019s folder yet, just create it.", "Then be sure that you put in those 4 lines that will magically make your routing work.", "Options -MultiViews RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.html [QSA,L] After we put that .htaccess file into the same directory as the index.html, Apache will redirect each new request directly to your app.", "Bonus: Deploying the React app to a sub directory If you\u2019re deploying your app into a sub directory, so it\u2019s accessible e.g.", "via https://myapp.com/the-app, you\u2019ll soon notice that there is another issue.", "Each click to a new route will transform the URL to something like https://myapp.com/route-abc \u2013 which will break again after a reload.", "But there is a simple fix for that: BrowserRouter has a prop called basename where you can specify your sub-directory path: From now on, each Route like /contacts will result in an URL like http://myapp.com/the-app/contacts.", "I had this same problem and this solution worked for us.. Background: We are hosting multiple apps on the same server.", "When we would refresh the server would not understand where to look for our index in the dist folder for that particular app.", "The above link will take you to what worked for us... Hope this helps, as we have spent quite a hours on figuring out a solution for our needs.", "We are using: package.json \"dependencies\": { \"babel-polyfill\": \"^6.23.0\", \"ejs\": \"^2.5.6\", \"express\": \"^4.15.2\", \"prop-types\": \"^15.5.6\", \"react\": \"^15.5.4\", \"react-dom\": \"^15.5.4\", \"react-redux\": \"^5.0.4\", \"react-router\": \"^3.0.2\", \"react-router-redux\": \"^4.0.8\", \"redux\": \"^3.6.0\", \"redux-persist\": \"^4.6.0\", \"redux-thunk\": \"^2.2.0\", \"webpack\": \"^2.4.1\" } my webpack.config.js webpack.config.js /* eslint-disable */ const path = require('path'); const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const babelPolyfill = require('babel-polyfill'); const HTMLWebpackPluginConfig = new HtmlWebpackPlugin({ template: __dirname + '/app/views/index.html', filename: 'index.html', inject: 'body' }); module.exports = { entry: [ 'babel-polyfill', './app/index.js' ], output: { path: __dirname + '/dist/your_app_name_here', filename: 'index_bundle.js' }, module: { rules: [{ test: /\\.js$/, loader: 'babel-loader', query : { presets : [\"env\", \"react\", \"stage-1\"] }, exclude: /node_modules/ }] }, plugins: [HTMLWebpackPluginConfig] } my index.js index.js import React from 'react' import ReactDOM from 'react-dom' import Routes from './Routes' import { Provider } from 'react-redux' import { createHistory } from 'history' import { useRouterHistory } from 'react-router' import configureStore from './store/configureStore' import { syncHistoryWithStore } from 'react-router-redux' import { persistStore } from 'redux-persist' const store = configureStore(); const browserHistory = useRouterHistory(createHistory) ({ basename: '/your_app_name_here' }) const history = syncHistoryWithStore(browserHistory, store) persistStore(store, {blacklist: ['routing']}, () => { console.log('rehydration complete') }) // persistStore(store).purge() ReactDOM.render( <Provider store={store}> <div> <Routes history={history} /> </div> </Provider>, document.getElementById('mount') ) my app.js var express = require('express'); var app = express(); app.use(express.static(__dirname + '/dist')); // app.use(express.static(__dirname + '/app/assets')); app.set('views', __dirname + '/dist/your_app_name_here'); app.engine('html', require('ejs').renderFile); app.set('view engine', 'html'); app.get('/*', function (req, res) { res.render('index'); }); app.listen(8081, function () { console.log('MD listening on port 8081!", "'); });", "I would like to ask why my state is not changing when I do an onclick event.", "I've search a while ago that I need to bind the onclick function in constructor but still the state is not updating.", "Here's my code: import React from 'react'; import Grid from 'react-bootstrap/lib/Grid'; import Row from 'react-bootstrap/lib/Row'; import Col from 'react-bootstrap/lib/Col'; import BoardAddModal from 'components/board/BoardAddModal.jsx'; import style from 'styles/boarditem.css'; class BoardAdd extends React.Component { constructor(props){ super(props); this.state = { boardAddModalShow: false } this.openAddBoardModal = this.openAddBoardModal.bind(this); } openAddBoardModal(){ this.setState({ boardAddModalShow: true }); // After setting a new state it still return a false value console.log(this.state.boardAddModalShow); } render() { return ( <Col lg={3}> <a href=\"javascript:;\" className={style.boardItemAdd} onClick={this.openAddBoardModal}> <div className={[style.boardItemContainer,style.boardItemGray].join(' ')}> Create New Board </div> </a> </Col> ) } } export default BoardAdd This callback is really messy.", "Just use async await instead: async openAddBoardModal(){ await this.setState({ boardAddModalShow: true }); console.log(this.state.boardAddModalShow); } Your state needs some time to mutate, and since console.log(this.state.boardAddModalShow) executes before the state mutates, you get the previous value as output.", "So you need to write the console in the callback to the setState function openAddBoardModal() { this.setState({ boardAddModalShow: true }, function () { console.log(this.state.boardAddModalShow); }); } setState is asynchronous.", "It means you can\u2019t call it on one line and assume the state has changed on the next.", "According to React docs setState() does not immediately mutate this.state but creates a pending state transition.", "Accessing this.state after calling this method can potentially return the existing value.", "There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.", "Why would they make setState async This is because setState alters the state and causes rerendering.", "This can be an expensive operation and making it synchronous might leave the browser unresponsive.", "Thus the setState calls are asynchronous as well as batched for better UI experience and performance.", "Fortunately setState() takes a callback.", "And this is where we get updated state.", "Consider this example.", "this.setState({ name: \"myname\" }, () => { //callback console.log(this.state.name) // myname }); So When callback fires, this.state is the updated state.", "You can get mutated/updated data in callback.", "Since setSatate is a asynchronous function so you need to console the state as a callback like this.", "openAddBoardModal(){ this.setState({ boardAddModalShow: true }, () => { console.log(this.state.boardAddModalShow) }); } setState() does not always immediately update the component.", "It may batch or defer the update until later.", "This makes reading this.state right after calling setState() a potential pitfall.", "Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied.", "If you need to set the state based on the previous state, read about the updater argument below.", "setState() will always lead to a re-render unless shouldComponentUpdate() returns false.", "If mutable objects are being used and conditional rendering logic cannot be implemented in shouldComponentUpdate(), calling setState() only when the new state differs from the previous state will avoid unnecessary re-renders.", "The first argument is an updater function with the signature: (state, props) => stateChange state is a reference to the component state at the time the change is being applied.", "It should not be directly mutated.", "Instead, changes should be represented by building a new object based on the input from state and props.", "For instance, suppose we wanted to increment a value in state by props.step: this.setState((state, props) => { return {counter: state.counter + props.step}; }); If you want to track the state is updating or not then the another way of doing the same thing is _stateUpdated(){ console.log(this.state.", "boardAddModalShow); } openAddBoardModal(){ this.setState( {boardAddModalShow: true}, this._stateUpdated.bind(this) ); } This way you can call the method \"_stateUpdated\" every time you try to update the state for debugging.", "setState() is asynchronous.", "The best way to verify if the state is updating would be in the componentDidUpdate() and not to put a console.log(this.state.boardAddModalShow) after this.setState({ boardAddModalShow: true }) .", "according to React Docs Think of setState() as a request rather than an immediate command to update the component.", "For better perceived performance, React may delay it, and then update several components in a single pass.", "React does not guarantee that the state changes are applied immediately According to React Docs React does not guarantee that the state changes are applied immediately.", "This makes reading this.state right after calling setState() a potential pitfall and can potentially return the existing value due to async nature .", "Instead, use componentDidUpdate or a setState callback that is executed right after setState operation is successful.Generally we recommend using componentDidUpdate() for such logic instead.", "Example: import React from \"react\"; import ReactDOM from \"react-dom\"; import \"./styles.css\"; class App extends React.Component { constructor() { super(); this.state = { counter: 1 }; } componentDidUpdate() { console.log(\"componentDidUpdate fired\"); console.log(\"STATE\", this.state); } updateState = () => { this.setState( (state, props) => { return { counter: state.counter + 1 }; }); }; render() { return ( <div className=\"App\"> <h1>Hello CodeSandbox</h1> <h2>Start editing to see some magic happen!</h2> <button onClick={this.updateState}>Update State</button> </div> ); } } const rootElement = document.getElementById(\"root\"); ReactDOM.render(<App />, rootElement); For anyone trying to do this with hooks, you need useEffect.", "function App() { const [x, setX] = useState(5) const [y, setY] = useState(15) console.log(\"Element is rendered:\", x, y) // setting y does not trigger the effect // the second argument is an array of dependencies useEffect(() => console.log(\"re-render because x changed:\", x), [x]) function handleXClick() { console.log(\"x before setting:\", x) setX(10) console.log(\"x in *line* after setting:\", x) } return <> <div> x is {x}.", "</div> <button onClick={handleXClick}> set x to 10</button> <div> y is {y}.", "</div> <button onClick={() => setY(20)}> set y to 20</button> </> } Output: Element is rendered: 5 15 re-render because x changed: 5 (press x button) x before setting: 5 x in *line* after setting: 5 Element is rendered: 10 15 re-render because x changed: 10 (press y button) Element is rendered: 10 20 when i was running the code and checking my output at console it showing the that it is undefined.", "After i search around and find something that worked for me.", "componentDidUpdate(){} I added this method in my code after constructor().", "check out the life cycle of react native workflow.", "https://images.app.goo.gl/BVRAi4ea2P4LchqJ8 this.setState({ isMonthFee: !this.state.isMonthFee, }, () => { console.log(this.state.isMonthFee); }) Yes because setState is an asynchronous function.", "The best way to set state right after you write set state is by using Object.assign like this: For eg you want to set a property isValid to true, do it like this Object.assign(this.state, { isValid: true }) You can access updated state just after writing this line.", "This question already has answers here: How to access the correct `this` inside a callback?", "(12 answers) Closed 6 months ago.", "I am writing a simple component in ES6 (with BabelJS), and functions this.setState is not working.", "Typical errors include something like Cannot read property 'setState' of undefined or this.setState is not a function Do you know why?", "Here is the code: import React from 'react' class SomeClass extends React.Component { constructor(props) { super(props) this.state = {inputContent: 'startValue'} } sendContent(e) { console.log('sending input content '+React.findDOMNode(React.refs.someref).value) } changeContent(e) { this.setState({inputContent: e.target.value}) } render() { return ( <div> <h4>The input form is here:</h4> Title: <input type=\"text\" ref=\"someref\" value={this.inputContent} onChange={this.changeContent} /> <button onClick={this.sendContent}>Submit</button> </div> ) } } export default SomeClass this.changeContent needs to be bound to the component instance via this.changeContent.bind(this) before being passed as the onChange prop, otherwise the this variable in the body of the function will not refer to the component instance but to window.", "See Function::bind.", "When using React.createClass instead of ES6 classes, every non-lifecycle method defined on a component is automatically bound to the component instance.", "See Autobinding.", "Be aware that binding a function creates a new function.", "You can either bind it directly in render, which means a new function will be created every time the component renders, or bind it in your constructor, which will only fire once.", "constructor() { this.changeContent = this.changeContent.bind(this); } vs render() { return <input onChange={this.changeContent.bind(this)} />; } Refs are set on the component instance and not on React.refs: you need to change React.refs.someref to this.refs.someref.", "You'll also need to bind the sendContent method to the component instance so that this refers to it.", "Morhaus is correct, but this can be solved without bind.", "You can use an arrow function together with the class properties proposal: class SomeClass extends React.Component { changeContent = (e) => { this.setState({inputContent: e.target.value}) } render() { return <input type=\"text\" onChange={this.changeContent} />; } } Because the arrow function is declared in the scope of the constructor, and because arrow functions maintain this from their declaring scope, it all works.", "The downside here is that these wont be functions on the prototype, they will all be recreated with each component.", "However, this isn't much of a downside since bind results in the same thing.", "This issue is one of the first things most of us experience, when transitioning from the React.createClass() component definition syntax to the ES6 class way of extending React.Component.", "It is caused by the this context differences in React.createClass() vs extends React.Component.", "Using React.createClass() will automatically bind this context (values) correctly, but that is not the case when using ES6 classes.", "When doing it the ES6 way (by extending React.Component) the this context is null by default.", "Properties of the class do not automatically bind to the React class (component) instance.", "Approaches to Solve this Issue I know a total of 4 general approaches.", "Bind your functions in the class constructor.", "Considered by many as a best-practice approach that avoids touching JSX at all and doesn't create a new function on each component re-render.", "class SomeClass extends React.Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(this); // the React Component instance } render() { return ( <button onClick={this.handleClick}></button> ); } } Bind your functions inline.", "You can still find this approach used here and there in some tutorials / articles / etc, so it's important you're aware of it.", "It it the same concept like #1, but be aware that binding a function creates a new function per each re-render.", "class SomeClass extends React.Component { handleClick() { console.log(this); // the React Component instance } render() { return ( <button onClick={this.handleClick.bind(this)}></button> ); } } Use a fat arrow function.", "Until arrow functions, every new function defined its own this value.", "However, the arrow function does not create its own this context, so this has the original meaning from the React component instance.", "Therefore, we can: class SomeClass extends React.Component { handleClick() { console.log(this); // the React Component instance } render() { return ( <button onClick={ () => this.handleClick() }></button> ); } } or class SomeClass extends React.Component { handleClick = () => { console.log(this); // the React Component instance } render() { return ( <button onClick={this.handleClick}></button> ); } } Use utility function library to automatically bind your functions.", "There are a few utility libraries out there, that automatically does the job for you.", "Here are some of the popular, just to mention a few: Autobind Decorator is an NPM package which binds methods of a class to the correct instance of this, even when the methods are detached.", "The package uses @autobind before methods to bind this to the correct reference to the component's context.", "import autobind from 'autobind-decorator'; class SomeClass extends React.Component { @autobind handleClick() { console.log(this); // the React Component instance } render() { return ( <button onClick={this.handleClick}></button> ); } } Autobind Decorator is smart enough to let us bind all methods inside a component class at once, just like approach #1.", "Class Autobind is another NPM package that is widely used to solve this binding issue.", "Unlike Autobind Decorator, it does not use of the decorator pattern, but really just uses a function inside your constructor that automatically binds the Component's methods to the correct reference of this.", "import autobind from 'class-autobind'; class SomeClass extends React.Component { constructor() { autobind(this); // or if you want to bind only only select functions: // autobind(this, 'handleClick'); } handleClick() { console.log(this); // the React Component instance } render() { return ( <button onClick={this.handleClick}></button> ); } } PS: Other very similar library is React Autobind.", "Recommendation If I were you, I would stick with approach #1.", "However, as soon as you get a ton of binds in your class constructor, I would recommend you to explore one of the helper libraries mentioned in approach #4.", "Other It's not related to the issue you have, but you shouldn't overuse refs.", "Your first inclination may be to use refs to \"make things happen\" in your app.", "If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy.", "For similar purposes, just like the one you need, using a controlled component is the preferred way.", "I suggest you to consider using your Component state.", "So, you can simply access the value like this: this.state.inputContent.", "Although the previous answers have provided the basic overview of solutions (i.e.", "binding, arrow functions, decorators that do this for you), I've yet to come across an answer which actually explains why this is necessary\u2014which in my opinion is the root of confusion, and leads to unnecessary steps such as needless rebinding and blindly following what others do.", "this is dynamic To understand this specific situation, a brief introduction to how this works.", "The key thing here is that this is a runtime binding and depends on the current execution context.", "Hence why it's commonly referred to as \"context\"\u2014giving information on the current execution context, and why you need to bind is because you loose \"context\".", "But let me illustrate the issue with a snippet: const foobar = { bar: function () { return this.foo; }, foo: 3, }; console.log(foobar.bar()); // 3, all is good!", "In this example, we get 3, as expected.", "But take this example: const barFunc = foobar.bar; console.log(barFunc()); // Uh oh, undefined!", "It may be unexpected to find that it logs undefined\u2014where did the 3 go?", "The answer lies in \"context\", or how you execute a function.", "Compare how we call the functions: // Example 1 foobar.bar(); // Example 2 const barFunc = foobar.bar; barFunc(); Notice the difference.", "In the first example, we are specifying exactly where the bar method1 is located\u2014on the foobar object: foobar.bar(); ^^^^^^ But in the second, we store the method into a new variable, and use that variable to call the method, without explicitly stating where the method actually exists, thus losing context: barFunc(); // Which object is this function coming from?", "And therein lies the problem, when you store a method in a variable, the original information about where that method is located (the context in which the method is being executed), is lost.", "Without this information, at runtime, there is no way for the JavaScript interpreter to bind the correct this\u2014without specific context, this does not work as expected2.", "Relating to React Here's an example of a React component (shortened for brevity) suffering from the this problem: handleClick() { this.setState(({ clicks }) => ({ // setState is async, use callback to access previous state clicks: clicks + 1, // increase by 1 })); } render() { return ( <button onClick={this.handleClick}>{this.state.clicks}</button> ); } But why, and how does the previous section relate to this?", "This is because they suffer from an abstraction of the same problem.", "If you take a look how React handles event handlers: // Edited to fit answer, React performs other checks internally // props is the current React component's props, registrationName is the name of the event handle prop, i.e \"onClick\" let listener = props[registrationName]; // Later, listener is called So, when you do onClick={this.handleClick}, the method this.handleClick is eventually assigned to the variable listener3.", "But now you see the problem arise\u2014since we've assigned this.handleClick to listener, we no longer specify exactly where handleClick is coming from!", "From React's point of view, listener is just some function, not attached to any object (or in this case, React component instance).", "We have lost context and thus the interpreter cannot infer a this value to use inside handleClick.", "Why binding works You might be wondering, if the interpreter decides the this value at runtime, why can I bind the handler so that it does work?", "This is because you can use Function#bind to guarantee the this value at runtime.", "This is done by setting an internal this binding property on a function, allowing it to not infer this: this.handleClick = this.handleClick.bind(this); When this line is executed, presumably in the constructor, the current this is captured (the React component instance) and set as an internal this binding of a entirely new function, returned from Function#bind.", "This makes sure that when this is being calculated at runtime, the interpreter will not try to infer anything, but use the provided this value you given it.", "Why arrow function properties work Arrow function class properties currently work through Babel based on the transpilation: handleClick = () => { /* Can use this just fine here */ } Becomes: constructor() { super(); this.handleClick = () => {} } And this works due to the fact arrow functions do not bind their own this, but take the this of their enclosing scope.", "In this case, the constructor's this, which points to the React component instance\u2014thus giving you the correct this.4 1 I use \"method\" to refer to a function that is supposed to be bound to an object, and \"function\" for those not.", "2 In the second snippet, undefined is logged instead of 3 because this defaults to the global execution context (window when not in strict mode, or else undefined) when it cannot be determined via specific context.", "And in the example window.foo does not exist thus yielding undefined.", "3 If you go down the rabbit hole of how events in the event queue are executed, invokeGuardedCallback is called on the listener.", "4 It's actually a lot more complicated.", "React internally tries to use Function#apply on listeners for its own use, but this does not work arrow functions as they simply do not bind this.", "That means, when this inside the arrow function is actually evaluated, the this is resolved up each lexical environment of each execution context of the current code of the module.", "The execution context which finally resolves to have a this binding is the constructor, which has a this pointing to the current React component instance, allowing it to work.", "You can tackle this by three ways 1.Bind the event function in the constructor itself as follows import React from 'react' class SomeClass extends React.Component { constructor(props) { super(props) this.state = {inputContent: 'startValue'} this.changeContent = this.changeContent.bind(this); } sendContent(e) { console.log('sending input content '+React.findDOMNode(React.refs.someref).value) } changeContent(e) { this.setState({inputContent: e.target.value}) } render() { return ( <div> <h4>The input form is here:</h4> Title: <input type=\"text\" ref=\"someref\" value={this.inputContent} onChange={this.changeContent} /> <button onClick={this.sendContent}>Submit</button> </div> ) } } export default SomeClass 2.Bind when it is called import React from 'react' class SomeClass extends React.Component { constructor(props) { super(props) this.state = {inputContent: 'startValue'} } sendContent(e) { console.log('sending input content '+React.findDOMNode(React.refs.someref).value) } changeContent(e) { this.setState({inputContent: e.target.value}) } render() { return ( <div> <h4>The input form is here:</h4> Title: <input type=\"text\" ref=\"someref\" value={this.inputContent} onChange={this.changeContent} /> <button onClick={this.sendContent.bind(this)}>Submit</button> </div> ) } } export default SomeClass 3.By using Arrow functions import React from 'react' class SomeClass extends React.Component { constructor(props) { super(props) this.state = {inputContent: 'startValue'} } sendContent(e) { console.log('sending input content '+React.findDOMNode(React.refs.someref).value) } changeContent(e) { this.setState({inputContent: e.target.value}) } render() { return ( <div> <h4>The input form is here:</h4> Title: <input type=\"text\" ref=\"someref\" value={this.inputContent} onChange={this.changeContent} /> <button onClick={()=>this.sendContent()}>Submit</button> </div> ) } } export default SomeClass We need to bind the event function with the component in constructor as follows, import React from 'react' class SomeClass extends React.Component { constructor(props) { super(props) this.state = {inputContent: 'startValue'} this.changeContent = this.changeContent.bind(this); } sendContent(e) { console.log('sending input content '+React.findDOMNode(React.refs.someref).value) } changeContent(e) { this.setState({inputContent: e.target.value}) } render() { return ( <div> <h4>The input form is here:</h4> Title: <input type=\"text\" ref=\"someref\" value={this.inputContent} onChange={this.changeContent} /> <button onClick={this.sendContent}>Submit</button> </div> ) } } export default SomeClass Thanks My recommendation is use arrow functions as a properties class SomeClass extends React.Component { handleClick = () => { console.log(this); // the React Component instance } render() { return ( <button onClick={this.handleClick}></button> ); } } and do not use arrow functions as class SomeClass extends React.Component { handleClick(){ console.log(this); // the React Component instance } render() { return ( <button onClick={()=>{this.handleClick}}></button> ); } } because second approach will generate new function every render call in fact this means new pointer new version of props, than if you will later care about performance you are able use React.PureComponent or in React.Component you can override shouldComponentUpdate(nextProps, nextState) and shallow check when props arrived You can solve this following these steps Change sendContent function with sendContent(e) { console.log('sending input content '+this.refs.someref.value) } Change render function with <input type=\"text\" ref=\"someref\" value={this.state.inputContent} onChange={(event)=>this.changeContent(event)} /> <button onClick={(event)=>this.sendContent(event)}>Submit</button> We have to bind our function with this to get instance of the function in class.", "Like so in example <button onClick={this.sendContent.bind(this)}>Submit</button> This way this.state will be valid object.", "if anyone will ever reach this answer, here is a way to bind all of the functions without needing to bind them manually in the constructor(): for (let member of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) { this[member] = this[member].bind(this) } or create this function in a global.jsx file export function bindAllFunctions({ bindTo: dis }) { for (let member of Object.getOwnPropertyNames(Object.getPrototypeOf(dis))) { dis[member] = dis[member].bind(dis) } } and in your constructor() call it like: bindAllFunctions({ bindTo: this }) This issue is happening because this.changeContent and onClick={this.sendContent} are not bound to this of the instance of the component .", "There is another solution (In addition to use bind() in the constructor() ) to use the arrow functions of ES6 which share the same lexical scope of the surrounding code and maintain this , so you can change your code in render() to be : render() { return ( <input type=\"text\" onChange={ () => this.changeContent() } /> <button onClick={ () => this.sendContent() }>Submit</button> ) } Hello if you want to dont care about binding yourself your function call.", "You can use 'class-autobind' and import it like that import autobind from 'class-autobind'; class test extends Component { constructor(props){ super(props); autobind(this); } Dont write autobind before the super call because it will not work In case you want to keep the bind in constructor syntax, you can use the proposal-bind-operator and transform your code like follow : constructor() { this.changeContent = ::this.changeContent; } Instead of : constructor() { this.changeContent = this.changeContent.bind(this); } much simpler, no need of bind(this) or fatArrow.", "this problem happen after react15.0 ,which event handler didn't auto bind to the component.", "so you must bind this to component manually whenever the event handler will be called.", "there are several methods to solve the problem.", "but you need to know which method is best and why?", "In general, we recommend that binding your functions in the class constructor or use a arrow function.", "// method 1\uff1a use a arrow function class ComponentA extends React.Component { eventHandler = () => { console.log(this) } render() { return ( <ChildComponent onClick={this.eventHandler} /> ); } // method 2: Bind your functions in the class constructor.", "class ComponentA extends React.Component { constructor(props) { super(props); this.eventHandler = this.eventHandler.bind(this); } render() { return ( <ChildComponent onClick={this.eventHandler} /> ); } these two methods will not creates a new function when the component render everytime.", "so our ChildComponent will not reRender becaue of the new function props change, or may produce the performance problem.", "You are using ES6 so functions will not bind to \"this\" context automatically.", "You have to manually bind the function to the context.", "constructor(props) { super(props); this.changeContent = this.changeContent.bind(this); } Your functions needs binding in order to play with state or props in event handlers In ES5, bind your event handler functions only in constructor but don't bind directly in render.", "If you do binding directly in render then it creates a new function every time your component renders and re-renders.", "So you should always bind it in constructor this.sendContent = this.sendContent.bind(this) In ES6, use arrow functions When you use arrow functions then you no need to do binding and you can also stay away from scope related issues sendContent = (event) => { } Alexandre Kirszenberg is correct, But another important thing to pay attention to , is where you put your binding.", "I have been stuck with a situation for days(probably because I'm a beginner), but unlike others, I knew about bind(Which I had applied already) so I just couldn't get my head around why I was still having those errors.", "It turns out that I had the bind in wrong order.", "Another is also perhaps the fact that I was calling the function within \"this.state\", which was not aware of the bind because it happened to be above the bind line, Below is what I had(By the way this is my first ever posting, But I thought it was very important, as I couldn't find solution any where else): constructor(props){ super(props); productArray=//some array this.state={ // Create an Array which will hold components to be displayed proListing:productArray.map(product=>{return(<ProRow dele={this.this.popRow()} prodName={product.name} prodPrice={product.price}/>)}) } this.popRow=this.popRow.bind(this);//This was the Issue, This line //should be kept above \"this.state\" Solution: Without explicitly binding, bind with the method name you can use fat arrow functions syntax ()=>{} that maintains the context of this.", "import React from 'react' class SomeClass extends React.Component { constructor(props) { super(props) this.state = { inputContent: 'startValue' } } sendContent = (e) => { console.log('sending input content ',this.state.inputContent); } changeContent = (e) => { this.setState({inputContent: e.target.value},()=>{ console.log('STATE:',this.state); }) } render() { return ( <div> <h4>The input form is here:</h4> Title: <input type=\"text\" value={this.state.inputContent} onChange={this.changeContent} /> <button onClick={this.sendContent}>Submit</button> </div> ) } } export default SomeClass Other Solutions: Bind your functions in the class constructor.", "Bind your functions in the JSX Template escaping braces {} {this.methodName.bind(this)} bind(this) can fix this issue, and nowadays we can use another 2 ways to achieve this if you don't like using bind .", "1) As the traditional way, we can use bind(this) in the constructor, so that when we use the function as JSX callback, the context of this is the class itself.", "class App1 extends React.Component { constructor(props) { super(props); // If we comment out the following line, // we will get run time error said `this` is undefined.", "this.changeColor = this.changeColor.bind(this); } changeColor(e) { e.currentTarget.style.backgroundColor = \"#00FF00\"; console.log(this.props); } render() { return ( <div> <button onClick={this.changeColor}> button</button> </div> ); } } 2) If we define the function as an attribute/field of the class with arrow function, we don't need to use bind(this) any more.", "class App2 extends React.Component { changeColor = e => { e.currentTarget.style.backgroundColor = \"#00FF00\"; console.log(this.props); }; render() { return ( <div> <button onClick={this.changeColor}> button 1</button> </div> ); } } 3) If we use arrow function as JSX callback, we don't need to use bind(this) either.", "And further more, we can pass in the parameters.", "Looks good, isn't it?", "but its drawback is the performance concern, for details please refer ReactJS doco.", "class App3 extends React.Component { changeColor(e, colorHex) { e.currentTarget.style.backgroundColor = colorHex; console.log(this.props); } render() { return ( <div> <button onClick={e => this.changeColor(e, \"#ff0000\")}> button 1</button> </div> ); } } And I have created a Codepen to demo these code snippets, hope it helps.", "I'm building a React component that accepts a JSON data source and creates a sortable table.", "Each of the dynamic data rows has a unique key assigned to it but I'm still getting an error of: Each child in an array should have a unique \"key\" prop.", "Check the render method of TableComponent.", "My TableComponent render method returns: <table> <thead key=\"thead\"> <TableHeader columns={columnNames}/> </thead> <tbody key=\"tbody\"> { rows } </tbody> </table> The TableHeader component is a single row and also has a unique key assigned to it.", "Each row in rows is built from a component with a unique key: <TableRowItem key={item.id} data={item} columns={columnNames}/> And the TableRowItem looks like this: var TableRowItem = React.createClass({ render: function() { var td = function() { return this.props.columns.map(function(c) { return <td key={this.props.data[c]}>{this.props.data[c]}</td>; }, this); }.bind(this); return ( <tr>{ td(this.props.item) }</tr> ) } }); What is causing the unique key prop error?", "You should add a key to each child as well as each element inside children.", "This way React can handle the minimal DOM change.", "In your code, each <TableRowItem key={item.id} data={item} columns={columnNames}/> is trying to render some children inside them without a key.", "Check this example.", "Try removing the key={i} from the <b></b> element inside the div's (and check the console).", "In the sample, if we don't give a key to the <b> element and we want to update only the object.city, React needs to re-render the whole row vs just the element.", "Here is the code: var data = [{name:'Jhon', age:28, city:'HO'}, {name:'Onhj', age:82, city:'HN'}, {name:'Nohj', age:41, city:'IT'} ]; var Hello = React.createClass({ render: function() { var _data = this.props.info; console.log(_data); return( <div> {_data.map(function(object, i){ return <div className={\"row\"} key={i}> {[ object.name , // remove the key <b className=\"fosfo\" key={i}> {object.city} </b> , object.age ]} </div>; })} </div> ); } }); React.render(<Hello info={data} />, document.body); The answer posted by @Chris at the bottom goes into much more detail than this answer.", "Please take a look at https://stackoverflow.com/a/43892905/2325522 React documentation on the importance of keys in reconciliation: Keys Be careful when iterating over arrays!!", "It is a common misconception that using the index of the element in the array is an acceptable way of suppressing the error you are probably familiar with: Each child in an array should have a unique \"key\" prop.", "However, in many cases it is not!", "This is anti-pattern that can in some situations lead to unwanted behavior.", "Understanding the key prop React uses the key prop to understand the component-to-DOM Element relation, which is then used for the reconciliation process.", "It is therefore very important that the key always remains unique, otherwise there is a good chance React will mix up the elements and mutate the incorrect one.", "It is also important that these keys remain static throughout all re-renders in order to maintain best performance.", "That being said, one does not always need to apply the above, provided it is known that the array is completely static.", "However, applying best practices is encouraged whenever possible.", "A React developer said in this GitHub issue: key is not really about performance, it's more about identity (which in turn leads to better performance).", "randomly assigned and changing values are not identity We can't realistically provide keys [automatically] without knowing how your data is modeled.", "I would suggest maybe using some sort of hashing function if you don't have ids We already have internal keys when we use arrays, but they are the index in the array.", "When you insert a new element, those keys are wrong.", "In short, a key should be: Unique - A key cannot be identical to that of a sibling component.", "Static - A key should not ever change between renders.", "Using the key prop As per the explanation above, carefully study the following samples and try to implement, when possible, the recommended approach.", "Bad (Potentially) <tbody> {rows.map((row, i) => { return <ObjectRow key={i} />; })} </tbody> This is arguably the most common mistake seen when iterating over an array in React.", "This approach isn't technically \"wrong\", it's just... \"dangerous\" if you don't know what you are doing.", "If you are iterating through a static array then this is a perfectly valid approach (e.g.", "an array of links in your navigation menu).", "However, if you are adding, removing, reordering or filtering items, then you need to be careful.", "Take a look at this detailed explanation in the official documentation.", "class MyApp extends React.Component { constructor() { super(); this.state = { arr: [\"Item 1\"] } } click = () => { this.setState({ arr: ['Item ' + (this.state.arr.length+1)].concat(this.state.arr), }); } render() { return( <div> <button onClick={this.click}>Add</button> <ul> {this.state.arr.map( (item, i) => <Item key={i} text={\"Item \" + i}>{item + \" \"}</Item> )} </ul> </div> ); } } const Item = (props) => { return ( <li> <label>{props.children}</label> <input value={props.text} /> </li> ); } ReactDOM.render(<MyApp />, document.getElementById(\"app\")); <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js\"></script> <div id=\"app\"></div> In this snippet we are using a non-static array and we are not restricting ourselves to using it as a stack.", "This is an unsafe approach (you'll see why).", "Note how as we add items to the beginning of the array (basically unshift), the value for each <input> remains in place.", "Why?", "Because the key doesn't uniquely identify each item.", "In other words, at first Item 1 has key={0}.", "When we add the second item, the top item becomes Item 2, followed by Item 1 as the second item.", "However, now Item 1 has key={1} and not key={0} anymore.", "Instead, Item 2 now has key={0}!!", "As such, React thinks the <input> elements have not changed, because the Item with key 0 is always at the top!", "So why is this approach only sometimes bad?", "This approach is only risky if the array is somehow filtered, rearranged, or items are added/removed.", "If it is always static, then it's perfectly safe to use.", "For example, a navigation menu like [\"Home\", \"Products\", \"Contact us\"] can safely be iterated through with this method because you'll probably never add new links or rearrange them.", "In short, here's when you can safely use the index as key: The array is static and will never change.", "The array is never filtered (display a subset of the array).", "The array is never reordered.", "The array is used as a stack or LIFO (last in, first out).", "In other words, adding can only be done at the end of the array (i.e push), and only the last item can ever be removed (i.e pop).", "Had we instead, in the snippet above, pushed the added item to the end of the array, the order for each existing item would always be correct.", "Very bad <tbody> {rows.map((row) => { return <ObjectRow key={Math.random()} />; })} </tbody> While this approach will probably guarantee uniqueness of the keys, it will always force react to re-render each item in the list, even when this is not required.", "This a very bad solution as it greatly impacts performance.", "Not to mention that one cannot exclude the possibility of a key collision in the event that Math.random() produces the same number twice.", "Unstable keys (like those produced by Math.random()) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.", "Very good <tbody> {rows.map((row) => { return <ObjectRow key={row.uniqueId} />; })} </tbody> This is arguably the best approach because it uses a property that is unique for each item in the dataset.", "For example, if rows contains data fetched from a database, one could use the table's Primary Key (which typically is an auto-incrementing number).", "The best way to pick a key is to use a string that uniquely identifies a list item among its siblings.", "Most often you would use IDs from your data as keys Good componentWillMount() { let rows = this.props.rows.map(item => { return {uid: SomeLibrary.generateUniqueID(), value: item}; }); } ... <tbody> {rows.map((row) => { return <ObjectRow key={row.uid} />; })} </tbody> This is also a good approach.", "If your dataset does not contain any data that guarantees uniqueness (e.g.", "an array of arbitrary numbers), there is a chance of a key collision.", "In such cases, it is best to manually generate a unique identifier for each item in the dataset before iterating over it.", "Preferably when mounting the component or when the dataset is received (e.g.", "from props or from an async API call), in order to do this only once, and not each time the component re-renders.", "There are already a handful of libraries out there that can provide you such keys.", "Here is one example: react-key-index.", "This may or not help someone, but it might be a quick reference.", "This is also similar to all the answers presented above.", "I have a lot of locations that generate list using the structure below: return ( {myList.map(item => ( <> <div class=\"some class\"> {item.someProperty} .... </div> </> )} ) After a little trial and error (and some frustrations), adding a key property to the outermost block resolved it.", "Also, note that the <> tag is now replaced with the <div> tag now.", "return ( {myList.map((item, index) => ( <div key={index}> <div class=\"some class\"> {item.someProperty} .... </div> </div> )} ) Of course, I've been naively using the iterating index (index) to populate the key value in the above example.", "Ideally, you'd use something which is unique to the list item.", "Just add the unique key to the your Components data.map((marker)=>{ return( <YourComponents key={data.id} // <----- unique key /> ); }) Check: key = undef !!!", "You got also the warn message: Each child in a list should have a unique \"key\" prop.", "if your code is complete right, but if on <ObjectRow key={someValue} /> someValue is undefined!!!", "Please check this first.", "You can save hours.", "Warning: Each child in an array or iterator should have a unique \"key\" prop.", "This is a warning as for array items which we are going to iterate over will need a unique resemblance.", "React handles iterating component rendering as arrays.", "Better way to resolve this is provide index on the array items you are going to iterate over.for example: class UsersState extends Component { state = { users: [ {name:\"shashank\", age:20}, {name:\"vardan\", age:30}, {name:\"somya\", age:40} ] } render() { return( <div> { this.state.users.map((user, index)=>{ return <UserState key={index} age={user.age}>{user.name}</UserState> }) } </div> ) } index is React built-in props.", "Best solution of define unique key in react: inside the map you initialized the name post then key define by key={post.id} or in my code you see i define the name item then i define key by key={item.id}: <div className=\"container\"> {posts.map(item =>( <div className=\"card border-primary mb-3\" key={item.id}> <div className=\"card-header\">{item.name}</div> <div className=\"card-body\" > <h4 className=\"card-title\">{item.username}</h4> <p className=\"card-text\">{item.email}</p> </div> </div> ))} </div> I was running into this error message because of <></> being returned for some items in the array when instead null needs to be returned.", "This is a warning, But addressing this will make Reacts rendering much FASTER, This is because React needs to uniquely identify each items in the list.", "Lets say if the state of an element of that list changes in Reacts Virtual DOM then React needs to figure out which element got changed and where in the DOM it needs to change so that browser DOM will be in sync with the Reacts Virtual DOM.", "As a solution just introduce a key attribute to each li tag.", "This key should be a unique value to each element.", "var TableRowItem = React.createClass({ render: function() { var td = function() { return this.props.columns.map(function(c, i) { return <td key={i}>{this.props.data[c]}</td>; }, this); }.bind(this); return ( <tr>{ td(this.props.item) }</tr> ) } }); This will sove the problem.", "In ReactJS if you are rendering an array of elements you should have a unique key for each those elements.", "Normally those kinda situations are creating a list.", "Example: function List() { const numbers = [0,1,2,3]; return ( <ul>{numbers.map((n) => <li> {n} </li>)}</ul> ); } ReactDOM.render( <List />, document.getElementById('root') ); In the above example, it creates a dynamic list using li tag, so since li tag does not have a unique key it shows an error.", "After fixed: function List() { const numbers = [0,1,2,3]; return ( <ul>{numbers.map((n) => <li key={n}> {n} </li>)}</ul> ); } ReactDOM.render( <List />, document.getElementById('root') ); Alternative solution when use map when you don't have a unique key (this is not recommended by react eslint ): function List() { const numbers = [0,1,2,3,4,4]; return ( <ul>{numbers.map((n,i) => <li key={i}> {n} </li>)}</ul> ); } ReactDOM.render( <List />, document.getElementById('root') ); Live example: https://codepen.io/spmsupun/pen/wvWdGwG I fixed this using Guid for each key like this: Generating Guid: guid() { return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + this.s4() + this.s4(); } s4() { return Math.floor((1 + Math.random()) * 0x10000) .toString(16) .substring(1); } And then assigning this value to markers: {this.state.markers.map(marker => ( <MapView.Marker key={this.guid()} coordinate={marker.coordinates} title={marker.title} /> ))}", "I'm trying to organize my state by using nested property like this: this.state = { someProperty: { flag:true } } But updating state like this, this.setState({ someProperty.flag: false }); doesn't work.", "How can this be done correctly?", "In order to setState for a nested object you can follow the below approach as I think setState doesn't handle nested updates.", "var someProperty = {...this.state.someProperty} someProperty.flag = true; this.setState({someProperty}) The idea is to create a dummy object perform operations on it and then replace the component's state with the updated object Now, the spread operator creates only one level nested copy of the object.", "If your state is highly nested like: this.state = { someProperty: { someOtherProperty: { anotherProperty: { flag: true } .. } ... } ... } You could setState using spread operator at each level like this.setState(prevState => ({ ...prevState, someProperty: { ...prevState.someProperty, someOtherProperty: { ...prevState.someProperty.someOtherProperty, anotherProperty: { ...prevState.someProperty.someOtherProperty.anotherProperty, flag: false } } } })) However the above syntax get every ugly as the state becomes more and more nested and hence I recommend you to use immutability-helper package to update the state.", "See this answer on how to update state with immutability helper.", "To write it in one line this.setState({ someProperty: { ...this.state.someProperty, flag: false} }); Sometimes direct answers are not the best ones :) Short version: this code this.state = { someProperty: { flag: true } } should be simplified as something like this.state = { somePropertyFlag: true } Long version: Currently you shouldn't want to work with nested state in React.", "Because React is not oriented to work with nested states and all solutions proposed here look as hacks.", "They don't use the framework but fight with it.", "They suggest to write not so clear code for doubtful purpose of grouping some properties.", "So they are very interesting as an answer to the challenge but practically useless.", "Lets imagine the following state: { parent: { child1: 'value 1', child2: 'value 2', ... child100: 'value 100' } } What will happen if you change just a value of child1?", "React will not re-render the view because it uses shallow comparison and it will find that parent property didn't change.", "BTW mutating the state object directly is considered to be a bad practice in general.", "So you need to re-create the whole parent object.", "But in this case we will meet another problem.", "React will think that all children have changed their values and will re-render all of them.", "Of course it is not good for performance.", "It is still possible to solve that problem by writing some complicated logic in shouldComponentUpdate() but I would prefer to stop here and use simple solution from the short version.", "Disclaimer Nested State in React is wrong design Read this excellent answer.", "Reasoning behind this answer: React's setState is just a built-in convenience, but you soon realise that it has its limits.", "Using custom properties and intelligent use of forceUpdate gives you much more.", "eg: class MyClass extends React.Component { myState = someObject inputValue = 42 ... MobX, for example, ditches state completely and uses custom observable properties.", "Use Observables instead of state in React components.", "the answer to your misery - see example here There is another shorter way to update whatever nested property.", "this.setState(state => { state.nested.flag = false state.another.deep.prop = true return state }) On one line this.setState(state => (state.nested.flag = false, state)) note: This here is Comma operator ~MDN, see it in action here (Sandbox).", "It is similar to (though this doesn't change state reference) this.state.nested.flag = false this.forceUpdate() For the subtle difference in this context between forceUpdate and setState see the linked example.", "Of course this is abusing some core principles, as the state should be read-only, but since you are immediately discarding the old state and replacing it with new state, it is completely ok.", "Warning Even though the component containing the state will update and rerender properly (except this gotcha), the props will fail to propagate to children (see Spymaster's comment below).", "Only use this technique if you know what you are doing.", "For example, you may pass a changed flat prop that is updated and passed easily.", "render( //some complex render with your nested state <ChildComponent complexNestedProp={this.state.nested} pleaseRerender={Math.random()}/> ) Now even though reference for complexNestedProp did not change (shouldComponentUpdate) this.props.complexNestedProp === nextProps.complexNestedProp the component will rerender whenever parent component updates, which is the case after calling this.setState or this.forceUpdate in the parent.", "Effects of mutating the state Using nested state and mutating the state directly is dangerous because different objects might hold (intentionally or not) different (older) references to the state and might not necessarily know when to update (for example when using PureComponent or if shouldComponentUpdate is implemented to return false) OR are intended to display old data like in the example below.", "Imagine a timeline that is supposed to render historic data, mutating the data under the hand will result in unexpected behaviour as it will also change previous items.", "Anyway here you can see that Nested PureChildClass it not rerendered due to props failing to propagate.", "If you are using ES2015 you have access to the Object.assign.", "You can use it as follows to update a nested object.", "this.setState({ someProperty: Object.assign({}, this.state.someProperty, {flag: false}) }); You merge the updated properties with the existing and use the returned object to update the state.", "Edit: Added an empty object as target to the assign function to make sure the state isn't mutated directly as carkod pointed out.", "const newState = Object.assign({}, this.state); newState.property.nestedProperty = \"new value\"; this.setState(newState); There are many libraries to help with this.", "For example, using immutability-helper: import update from 'immutability-helper'; const newState = update(this.state, { someProperty: {flag: {$set: false}}, }; this.setState(newState); Using lodash/fp set: import {set} from 'lodash/fp'; const newState = set([\"someProperty\", \"flag\"], false, this.state); Using lodash/fp merge: import {merge} from 'lodash/fp'; const newState = merge(this.state, { someProperty: {flag: false}, }); We use Immer https://github.com/mweststrate/immer to handle these kinds of issues.", "Just replaced this code in one of our components this.setState(prevState => ({ ...prevState, preferences: { ...prevState.preferences, [key]: newValue } })); With this import produce from 'immer'; this.setState(produce(draft => { draft.preferences[key] = newValue; })); With immer you handle your state as a \"normal object\".", "The magic happens behind the scene with proxy objects.", "Here's a variation on the first answer given in this thread which doesn't require any extra packages, libraries or special functions.", "state = { someProperty: { flag: 'string' } } handleChange = (value) => { const newState = {...this.state.someProperty, flag: value} this.setState({ someProperty: newState }) } In order to set the state of a specific nested field, you have set the whole object.", "I did this by creating a variable, newState and spreading the contents of the current state into it first using the ES2015 spread operator.", "Then, I replaced the value of this.state.flag with the new value (since I set flag: value after I spread the current state into the object, the flag field in the current state is overridden).", "Then, I simply set the state of someProperty to my newState object.", "Although nesting isn't really how you should treat a component state, sometimes for something easy for single tier nesting.", "For a state like this state = { contact: { phone: '888-888-8888', email: 'test@test.com' } address: { street:'' }, occupation: { } } A re-useable method ive used would look like this.", "handleChange = (obj) => e => { let x = this.state[obj]; x[e.target.name] = e.target.value; this.setState({ [obj]: x }); }; then just passing in the obj name for each nesting you want to address... <TextField name=\"street\" onChange={handleChange('address')} /> I used this solution.", "If you have a nested state like this: this.state = { formInputs:{ friendName:{ value:'', isValid:false, errorMsg:'' }, friendEmail:{ value:'', isValid:false, errorMsg:'' } } you can declare the handleChange function that copy current status and re-assigns it with changed values handleChange(el) { let inputName = el.target.name; let inputValue = el.target.value; let statusCopy = Object.assign({}, this.state); statusCopy.formInputs[inputName].value = inputValue; this.setState(statusCopy); } here the html with the event listener <input type=\"text\" onChange={this.handleChange} \" name=\"friendName\" /> Create a copy of the state: let someProperty = JSON.parse(JSON.stringify(this.state.someProperty)) make changes in this object: someProperty.flag = \"false\" now update the state this.setState({someProperty}) Although you asked about a state of class-based React component, the same problem exists with useState hook.", "Even worse: useState hook does not accept partial updates.", "So this question became very relevant when useState hook was introduced.", "I have decided to post the following answer to make sure the question covers more modern scenarios where the useState hook is used: If you have got: const [state, setState] = useState({ someProperty: { flag: true, otherNestedProp: 1 }, otherProp: 2 }) you can set the nested property by cloning the current and patching the required segments of the data, for example: setState(current => { ...current, someProperty: { ...current.someProperty, flag: false } }); Or you can use Immer library to simplify the cloning and patching of the object.", "Or you can use Hookstate library (disclaimer: I am an author) to simply the management of complex (local and global) state data entirely and improve the performance (read: not to worry about rendering optimization): import { useStateLink } from '@hookstate/core' const state = useStateLink({ someProperty: { flag: true, otherNestedProp: 1 }, otherProp: 2 }) get the field to render: state.nested.someProperty.nested.flag.get() // or state.get().someProperty.flag set the nested field: state.nested.someProperty.nested.flag.set(false) Here is the Hookstate example, where the state is deeply / recursively nested in tree-like data structure.", "Two other options not mentioned yet: If you have deeply nested state, consider if you can restructure the child objects to sit at the root.", "This makes the data easier to update.", "There are many handy libraries available for handling immutable state listed in the Redux docs.", "I recommend Immer since it allows you to write code in a mutative manner but handles the necessary cloning behind the scenes.", "It also freezes the resulting object so you can't accidentally mutate it later.", "To make things generic, I worked on @ShubhamKhatri's and @Qwerty's answers.", "state object this.state = { name: '', grandParent: { parent1: { child: '' }, parent2: { child: '' } } }; input controls <input value={this.state.name} onChange={this.updateState} type=\"text\" name=\"name\" /> <input value={this.state.grandParent.parent1.child} onChange={this.updateState} type=\"text\" name=\"grandParent.parent1.child\" /> <input value={this.state.grandParent.parent2.child} onChange={this.updateState} type=\"text\" name=\"grandParent.parent2.child\" /> updateState method setState as @ShubhamKhatri's answer updateState(event) { const path = event.target.name.split('.", "'); const depth = path.length; const oldstate = this.state; const newstate = { ...oldstate }; let newStateLevel = newstate; let oldStateLevel = oldstate; for (let i = 0; i < depth; i += 1) { if (i === depth - 1) { newStateLevel[path[i]] = event.target.value; } else { newStateLevel[path[i]] = { ...oldStateLevel[path[i]] }; oldStateLevel = oldStateLevel[path[i]]; newStateLevel = newStateLevel[path[i]]; } } this.setState(newstate); } setState as @Qwerty's answer updateState(event) { const path = event.target.name.split('.", "'); const depth = path.length; const state = { ...this.state }; let ref = state; for (let i = 0; i < depth; i += 1) { if (i === depth - 1) { ref[path[i]] = event.target.value; } else { ref = ref[path[i]]; } } this.setState(state); } Note: These above methods won't work for arrays I take very seriously the concerns already voiced around creating a complete copy of your component state.", "With that said, I would strongly suggest Immer.", "import produce from 'immer'; <Input value={this.state.form.username} onChange={e => produce(this.state, s => { s.form.username = e.target.value }) } /> This should work for React.PureComponent (i.e.", "shallow state comparisons by React) as Immer cleverly uses a proxy object to efficiently copy an arbitrarily deep state tree.", "Immer is also more typesafe compared to libraries like Immutability Helper, and is ideal for Javascript and Typescript users alike.", "Typescript utility function function setStateDeep<S>(comp: React.Component<any, S, any>, fn: (s: Draft<Readonly<S>>) => any) { comp.setState(produce(comp.state, s => { fn(s); })) } onChange={e => setStateDeep(this, s => s.form.username = e.target.value)} stateUpdate = () => { let obj = this.state; if(this.props.v12_data.values.email) { obj.obj_v12.Customer.EmailAddress = this.props.v12_data.values.email } this.setState(obj) } I found this to work for me, having a project form in my case where for example you have an id, and a name and I'd rather maintain state for a nested project.", "return ( <div> <h2>Project Details</h2> <form> <Input label=\"ID\" group type=\"number\" value={this.state.project.id} onChange={(event) => this.setState({ project: {...this.state.project, id: event.target.value}})} /> <Input label=\"Name\" group type=\"text\" value={this.state.project.name} onChange={(event) => this.setState({ project: {...this.state.project, name: event.target.value}})} /> </form> </div> ) Let me know!", "Something like this might suffice, const isObject = (thing) => { if(thing && typeof thing === 'object' && typeof thing !== null && !", "(Array.isArray(thing)) ){ return true; } return false; } /* Call with an array containing the path to the property you want to access And the current component/redux state.", "For example if we want to update `hello` within the following obj const obj = { somePrimitive:false, someNestedObj:{ hello:1 } } we would do : //clone the object const cloned = clone(['someNestedObj','hello'],obj) //Set the new value cloned.someNestedObj.hello = 5; */ const clone = (arr, state) => { let clonedObj = {...state} const originalObj = clonedObj; arr.forEach(property => { if(!", "(property in clonedObj)){ throw new Error('State missing property') } if(isObject(clonedObj[property])){ clonedObj[property] = {...originalObj[property]}; clonedObj = clonedObj[property]; } }) return originalObj; } const nestedObj = { someProperty:true, someNestedObj:{ someOtherProperty:true } } const clonedObj = clone(['someProperty'], nestedObj); console.log(clonedObj === nestedObj) //returns false console.log(clonedObj.someProperty === nestedObj.someProperty) //returns true console.log(clonedObj.someNestedObj === nestedObj.someNestedObj) //returns true console.log() const clonedObj2 = clone(['someProperty','someNestedObj','someOtherProperty'], nestedObj); console.log(clonedObj2 === nestedObj) // returns false console.log(clonedObj2.someNestedObj === nestedObj.someNestedObj) //returns false //returns true (doesn't attempt to clone because its primitive type) console.log(clonedObj2.someNestedObj.someOtherProperty === nestedObj.someNestedObj.someOtherProperty) I know it is an old question but still wanted to share how i achieved this.", "Assuming state in constructor looks like this: constructor(props) { super(props); this.state = { loading: false, user: { email: \"\" }, organization: { name: \"\" } }; this.handleChange = this.handleChange.bind(this); } My handleChange function is like this: handleChange(e) { const names = e.target.name.split(\".", "\"); const value = e.target.type === \"checkbox\" ?", "e.target.checked : e.target.value; this.setState((state) => { state[names[0]][names[1]] = value; return {[names[0]]: state[names[0]]}; }); } And make sure you name inputs accordingly: <input type=\"text\" name=\"user.email\" onChange={this.handleChange} value={this.state.user.firstName} placeholder=\"Email Address\" /> <input type=\"text\" name=\"organization.name\" onChange={this.handleChange} value={this.state.organization.name} placeholder=\"Organization Name\" /> I do nested updates with a reduce search: Example: The nested variables in state: state = { coords: { x: 0, y: 0, z: 0 } } The function: handleChange = nestedAttr => event => { const { target: { value } } = event; const attrs = nestedAttr.split('.", "'); let stateVar = this.state[attrs[0]]; if(attrs.length>1) attrs.reduce((a,b,index,arr)=>{ if(index==arr.length-1) a[b] = value; else if(a[b]!=null) return a[b] else return a; },stateVar); else stateVar = value; this.setState({[attrs[0]]: stateVar}) } Use: <input value={this.state.coords.x} onChange={this.handleTextChange('coords.x')} /> This is my initialState const initialStateInput = { cabeceraFamilia: { familia: '', direccion: '', telefonos: '', email: '' }, motivoConsulta: '', fechaHora: '', corresponsables: [], } The hook or you can replace it with the state (class component) const [infoAgendamiento, setInfoAgendamiento] = useState(initialStateInput); The method for handleChange const actualizarState = e => { const nameObjects = e.target.name.split('.", "'); const newState = setStateNested(infoAgendamiento, nameObjects, e.target.value); setInfoAgendamiento({...newState}); }; Method for set state with nested states const setStateNested = (state, nameObjects, value) => { let i = 0; let operativeState = state; if(nameObjects.length > 1){ for (i = 0; i < nameObjects.length - 1; i++) { operativeState = operativeState[nameObjects[i]]; } } operativeState[nameObjects[i]] = value; return state; } Finally this is the input that I use <input type=\"text\" className=\"form-control\" name=\"cabeceraFamilia.direccion\" placeholder=\"Direcci\u00f3n\" defaultValue={infoAgendamiento.cabeceraFamilia.direccion} onChange={actualizarState} /> If you are using formik in your project it has some easy way to handle this stuff.", "Here is the most easiest way to do with formik.", "First set your initial values inside the formik initivalues attribute or in the react.", "state Here, the initial values is define in react state state = { data: { fy: { active: \"N\" } } } define above initialValues for formik field inside formik initiValues attribute <Formik initialValues={this.state.data} onSubmit={(values, actions)=> {...your actions goes here}} > {({ isSubmitting }) => ( <Form> <Field type=\"checkbox\" name=\"fy.active\" onChange={(e) => { const value = e.target.checked; if(value) setFieldValue('fy.active', 'Y') else setFieldValue('fy.active', 'N') }}/> </Form> )} </Formik> Make a console to the check the state updated into string instead of booleanthe formik setFieldValue function to set the state or go with react debugger tool to see the changes iniside formik state values.", "try this code: this.setState({ someProperty: {flag: false} }); This is clearly not the right or best way to do, however it is cleaner to my view: this.state.hugeNestedObject = hugeNestedObject; this.state.anotherHugeNestedObject = anotherHugeNestedObject; this.setState({}) However, React itself should iterate thought nested objects and update state and DOM accordingly which is not there yet.", "i saw following in a book: this.setState(state => state.someProperty.falg = false); but i'm not sure if it's right..", "I want to add an element to the end of a state array, is this the correct way to do it?", "this.state.arrayvar.push(newelement); this.setState({arrayvar:this.state.arrayvar}); I am concerned that modifying the array in-place with push might cause trouble - is it safe?", "The alternative of making a copy of the array, and setStateing that seems wasteful.", "The React docs says: Treat this.state as if it were immutable.", "Your push will mutate the state directly and that could potentially lead to error prone code, even if you are \"resetting\" the state again afterwards.", "F.ex, it could lead to that some lifecycle methods like componentDidUpdate won\u2019t trigger.", "The recommended approach in later React versions is to use an updater function when modifying states to prevent race conditions: this.setState(prevState => ({ arrayvar: [...prevState.arrayvar, newelement] })) The memory \"waste\" is not an issue compared to the errors you might face using non-standard state modifications.", "Alternative syntax for earlier React versions You can use concat to get a clean syntax since it returns a new array: this.setState({ arrayvar: this.state.arrayvar.concat([newelement]) }) In ES6 you can use the Spread Operator: this.setState({ arrayvar: [...this.state.arrayvar, newelement] }) Easiest, if you are using ES6.", "initialArray = [1, 2, 3]; newArray = [ ...initialArray, 4 ]; // --> [1,2,3,4] New array will be [1,2,3,4] to update your state in React this.setState({ arrayvar:[...this.state.arrayvar, newelement] }); Learn more about array destructuring The simplest way with ES6: this.setState(prevState => ({ array: [...prevState.array, newElement] })) React may batch updates, and therefore the correct approach is to provide setState with a function that performs the update.", "For the React update addon, the following will reliably work: this.setState( state => update(state, {array: {$push: [4]}}) ); or for concat(): this.setState( state => ({ array: state.array.concat([4]) })); The following shows what https://jsbin.com/mofekakuqi/7/edit?js,output as an example of what happens if you get it wrong.", "The setTimeout() invocation correctly adds three items because React will not batch updates within a setTimeout callback (see https://groups.google.com/d/msg/reactjs/G6pljvpTGX0/0ihYw2zK9dEJ).", "The buggy onClick will only add \"Third\", but the fixed one, will add F, S and T as expected.", "class List extends React.Component { constructor(props) { super(props); this.state = { array: [] } setTimeout(this.addSome, 500); } addSome = () => { this.setState( update(this.state, {array: {$push: [\"First\"]}})); this.setState( update(this.state, {array: {$push: [\"Second\"]}})); this.setState( update(this.state, {array: {$push: [\"Third\"]}})); }; addSomeFixed = () => { this.setState( state => update(state, {array: {$push: [\"F\"]}})); this.setState( state => update(state, {array: {$push: [\"S\"]}})); this.setState( state => update(state, {array: {$push: [\"T\"]}})); }; render() { const list = this.state.array.map((item, i) => { return <li key={i}>{item}</li> }); console.log(this.state); return ( <div className='list'> <button onClick={this.addSome}>add three</button> <button onClick={this.addSomeFixed}>add three (fixed)</button> <ul> {list} </ul> </div> ); } }; ReactDOM.render(<List />, document.getElementById('app')); As @nilgun mentioned in the comment, you can use the react immutability helpers.", "I've found this to be super useful.", "From the docs: Simple push var initialArray = [1, 2, 3]; var newArray = update(initialArray, {$push: [4]}); // => [1, 2, 3, 4] initialArray is still [1, 2, 3].", "If you are using functional component please use this as below.", "const [chatHistory, setChatHistory] = useState([]); // define the state const chatHistoryList = [...chatHistory, {'from':'me', 'message':e.target.value}]; // new array need to update setChatHistory(chatHistoryList); // update the state For added new element into the array, push() should be the answer.", "For remove element and update state of array, below code works for me.", "splice(index, 1) can not work.", "const [arrayState, setArrayState] = React.useState<any[]>([]); ... // index is the index for the element you want to remove const newArrayState = arrayState.filter((value, theIndex) => {return index !== theIndex}); setArrayState(newArrayState); This worked for me to add an array within an array this.setState(prevState => ({ component: prevState.component.concat(new Array(['new', 'new'])) })); Here's a 2020, Reactjs Hook example that I thought could help others.", "I am using it to add new rows to a Reactjs table.", "Let me know if I could improve on something.", "Adding a new element to a functional state component: Define the state data: const [data, setData] = useState([ { id: 1, name: 'John', age: 16 }, { id: 2, name: 'Jane', age: 22 }, { id: 3, name: 'Josh', age: 21 } ]); Have a button trigger a function to add a new element <Button // pass the current state data to the handleAdd function so we can append to it.", "onClick={() => handleAdd(data)}> Add a row </Button> function handleAdd(currentData) { // return last data array element let lastDataObject = currentTableData[currentTableData.length - 1] // assign last elements ID to a variable.", "let lastID = Object.values(lastDataObject)[0] // build a new element with a new ID based off the last element in the array let newDataElement = { id: lastID + 1, name: 'Jill', age: 55, } // build a new state object const newStateData = [...currentData, newDataElement ] // update the state setData(newStateData); // print newly updated state for (const element of newStateData) { console.log('New Data: ' + Object.values(element).join(', ')) } } Option one is using this.setState(prevState => ({ arrayvar: [...prevState.arrayvar, newelement] })) Option 2: this.setState({ arrayvar: this.state.arrayvar.concat([newelement]) }) Option 3: function abc() { const data = this.state.myarray; data.push({a:1,b:2}) this.setState({myarray:data}) } this.setState({ arrayvar: [...this.state.arrayvar, ...newelement] }) I am trying to push value in an array state and set value like this and define state array and push value by map function.", "this.state = { createJob: [], totalAmount:Number=0 } your_API_JSON_Array.map((_) => { this.setState({totalAmount:this.state.totalAmount += _.your_API_JSON.price}) this.state.createJob.push({ id: _._id, price: _.your_API_JSON.price }) return this.setState({createJob: this.state.createJob}) }) //------------------code is return in typescript const updateMyData1 = (rowIndex:any, columnId:any, value:any) => { setItems(old => old.map((row, index) => { if (index === rowIndex) { return Object.assign(Object.assign({}, old[rowIndex]), { [columnId]: value }); } return row; })); This code work for me: fetch('http://localhost:8080') .then(response => response.json()) .then(json => { this.setState({mystate: this.state.mystate.push.apply(this.state.mystate, json)}) })", "I'm trying to send data from a child component to it's parent as follow: const ParentComponent = React.createClass({ getInitialState() { return { language: '', }; }, handleLanguageCode: function(langValue) { this.setState({language: langValue}); }, render() { return ( <div className=\"col-sm-9\" > <SelectLanguage onSelectLanguage={this.handleLanguage}/> </div> ); }); and here is the child component: export const SelectLanguage = React.createClass({ getInitialState: function(){ return{ selectedCode: '', selectedLanguage: '', }; }, handleLangChange: function (e) { var lang = this.state.selectedLanguage; var code = this.state.selectedCode; this.props.onSelectLanguage({selectedLanguage: lang}); this.props.onSelectLanguage({selectedCode: code}); }, render() { var json = require(\"json!../languages.json\"); var jsonArray = json.languages; return ( <div > <DropdownList ref='dropdown' data={jsonArray} value={this.state.selectedLanguage} caseSensitive={false} minLength={3} filter='contains' onChange={this.handleLangChange} /> </div> ); } }); What I need is to get the selected value by user in the parent component.", "I'm getting this error: Uncaught TypeError: this.props.onSelectLanguage is not a function Can anyone help me to find the problem?", "P.S.", "The child component is creating a dropdown from a json file, and I need the dropdown list to show both elements of the json array next to each other(like: \"aaa,english\" as the first choice!)", "{ \"languages\":[ [ \"aaa\", \"english\" ], [ \"aab\", \"swedish\" ], } This should work.", "While sending the prop back you are sending that as an object rather send that as a value or alternatively use it as an object in the parent component.", "Secondly you need to format your json object to contain name value pairs and use valueField and textField attribute of DropdownList Short Answer Parent: <div className=\"col-sm-9\"> <SelectLanguage onSelectLanguage={this.handleLanguage} /> </div> Child: handleLangChange = () => { var lang = this.dropdown.value; this.props.onSelectLanguage(lang); } Detailed: EDIT: Considering React.createClass is deprecated from v16.0 onwards, It is better to go ahead and create a React Component by extending React.Component.", "Passing data from child to parent component with this syntax will look like Parent class ParentComponent extends React.Component { state = { language: '' } handleLanguage = (langValue) => { this.setState({language: langValue}); } render() { return ( <div className=\"col-sm-9\"> <SelectLanguage onSelectLanguage={this.handleLanguage} /> </div> ) } } Child var json = require(\"json!../languages.json\"); var jsonArray = json.languages; export class SelectLanguage extends React.Component { state = { selectedCode: '', selectedLanguage: jsonArray[0], } handleLangChange = () => { var lang = this.dropdown.value; this.props.onSelectLanguage(lang); } render() { return ( <div> <DropdownList ref={(ref) => this.dropdown = ref} data={jsonArray} valueField='lang' textField='lang' caseSensitive={false} minLength={3} filter='contains' onChange={this.handleLangChange} /> </div> ); } } Using createClass syntax which the OP used in his answer Parent const ParentComponent = React.createClass({ getInitialState() { return { language: '', }; }, handleLanguage: function(langValue) { this.setState({language: langValue}); }, render() { return ( <div className=\"col-sm-9\"> <SelectLanguage onSelectLanguage={this.handleLanguage} /> </div> ); }); Child var json = require(\"json!../languages.json\"); var jsonArray = json.languages; export const SelectLanguage = React.createClass({ getInitialState: function() { return { selectedCode: '', selectedLanguage: jsonArray[0], }; }, handleLangChange: function () { var lang = this.refs.dropdown.value; this.props.onSelectLanguage(lang); }, render() { return ( <div> <DropdownList ref='dropdown' data={jsonArray} valueField='lang' textField='lang' caseSensitive={false} minLength={3} filter='contains' onChange={this.handleLangChange} /> </div> ); } }); JSON: { \"languages\":[ { \"code\": \"aaa\", \"lang\": \"english\" }, { \"code\": \"aab\", \"lang\": \"Swedish\" }, ] } To pass data from child component to parent component In Parent Component: getData(val){ // do not forget to bind getData in constructor console.log(val); } render(){ return(<Child sendData={this.getData}/>); } In Child Component: demoMethod(){ this.props.sendData(value); } Considering React Function Components and using Hooks are getting more popular these days , I will give a simple example of how to Passing data from child to parent component in Parent Function Component we will have : import React, { useState, useEffect } from \"react\"; then const [childData, setChildData] = useState(\"\"); and passing setChildData (which do a job similar to this.setState in Class Components) to Child return( <ChildComponent passChildData={setChildData} /> ) in Child Component first we get the receiving props function ChildComponent(props){ return (...) } then you can pass data anyhow like using a handler function const functionHandler = (data) => { props.passChildData(data); } I found the approach how to get data from child component in parents when i need it.", "Parent: class ParentComponent extends Component{ onSubmit(data) { let mapPoint = this.getMapPoint(); } render(){ return ( <form onSubmit={this.onSubmit.bind(this)}> <ChildComponent getCurrentPoint={getMapPoint => {this.getMapPoint = getMapPoint}} /> <input type=\"submit\" value=\"Submit\" /> </form> ) } } Child: class ChildComponent extends Component{ constructor(props){ super(props); if (props.getCurrentPoint){ props.getCurrentPoint(this.getMapPoint.bind(this)); } } getMapPoint(){ return this.Point; } } This example showing how to pass function from child component to parent and use this function to get data from child.", "from child component to parent component as below parent component class Parent extends React.Component { state = { message: \"parent message\" } callbackFunction = (childData) => { this.setState({message: childData}) }, render() { return ( <div> <Child parentCallback = {this.callbackFunction}/> <p> {this.state.message} </p> </div> ); } } child component class Child extends React.Component{ sendBackData = () => { this.props.parentCallback(\"child message\"); }, render() { <button onClick={sendBackData}>click me to send back</button> } }; I hope this work in React v16.8+ function component, you can use useState() to create a function state that lets you update the parent state, then pass it on to child as a props attribute, then inside the child component you can trigger the parent state function, the following is a working snippet: const { useState , useEffect } = React; function Timer({ setParentCounter }) { const [counter, setCounter] = React.useState(0); useEffect(() => { let countersystem; countersystem = setTimeout(() => setCounter(counter + 1), 1000); return () => { clearTimeout(countersystem); }; }, [counter]); return ( <div className=\"App\"> <button onClick={() => { setParentCounter(counter); }} > Set parent counter value </button> <hr /> <div>Child Counter: {counter}</div> </div> ); } function App() { const [parentCounter, setParentCounter] = useState(0); return ( <div className=\"App\"> Parent Counter: {parentCounter} <hr /> <Timer setParentCounter={setParentCounter} /> </div> ); } ReactDOM.render(<App />, document.getElementById('react-root')); <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.8.4/umd/react.production.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.4/umd/react-dom.production.min.js\"></script> <div id=\"react-root\"></div> React.createClass method has been deprecated in the new version of React, you can do it very simply in the following way make one functional component and another class component to maintain state: Parent: const ParentComp = () => { getLanguage = (language) => { console.log('Language in Parent Component: ', language); } <ChildComp onGetLanguage={getLanguage} }; Child: class ChildComp extends React.Component { state = { selectedLanguage: '' } handleLangChange = e => { const language = e.target.value; thi.setState({ selectedLanguage = language; }); this.props.onGetLanguage({language}); } render() { const json = require(\"json!../languages.json\"); const jsonArray = json.languages; const selectedLanguage = this.state; return ( <div > <DropdownList ref='dropdown' data={jsonArray} value={tselectedLanguage} caseSensitive={false} minLength={3} filter='contains' onChange={this.handleLangChange} /> </div> ); } }; You can even avoid the function at the parent updating the state directly In Parent Component: render(){ return(<Child sendData={ v => this.setState({item: v}) } />); } In the Child Component: demoMethod(){ this.props.sendData(value); } The idea is to send a callback to the child which will be called to give the data back A complete and minimal example using functions: App will create a Child which will compute a random number and send it back directly to the parent, which will console.log the result const Child = ({ handleRandom }) => { handleRandom(Math.random()) return <span>child</span> } const App = () => <Child handleRandom={(num) => console.log(num)}/> Pass data from child to parent Component using Callback You need to pass from parent to child callback function, and then call it in the child.", "Parent Component:-TimeModal handleTimeValue = (timeValue) => { this.setState({pouringDiff: timeValue}); } <TimeSelection prePourPreHours={prePourPreHours} setPourTime={this.setPourTime} isPrePour={isPrePour} isResident={isResident} isMilitaryFormatTime={isMilitaryFormatTime} communityDateTime={moment(communityDT).format(\"MM/DD/YYYY hh:mm A\")} onSelectPouringTimeDiff={this.handleTimeValue} /> Note:- onSelectPouringTimeDiff={this.handleTimeValue} In the Child Component call props when required componentDidMount():void{ // Todo use this as per your scenrio this.props.onSelectPouringTimeDiff(pouringDiff); }", "Ok, i'll try and make this quick because it SHOULD be an easy fix...", "I've read a bunch of similar questions, and the answer seems to be quite obvious.", "Nothing I would ever have to look up in the first place!", "But...", "I am having an error that I cannot fathom how to fix or why its happening.", "As follows: class NightlifeTypes extends Component { constructor(props) { super(props); this.state = { barClubLounge: false, seeTheTown: true, eventsEntertainment: true, familyFriendlyOnly: false } this.handleOnChange = this.handleOnChange.bind(this); } handleOnChange = (event) => { if(event.target.className == \"barClubLounge\") { this.setState({barClubLounge: event.target.checked}); console.log(event.target.checked) console.log(this.state.barClubLounge) } } render() { return ( <input className=\"barClubLounge\" type='checkbox' onChange={this.handleOnChange} checked={this.state.barClubLounge}/> ) } More code surrounds this but this is where my problem lies.", "Should work, right?", "I've also tried this: handleOnChange = (event) => { if(event.target.className == \"barClubLounge\") { this.setState({barClubLounge: !this.state.barClubLounge}); console.log(event.target.checked) console.log(this.state.barClubLounge) } So I have those two console.log()'s, both should be the same.", "I'm literally setting the state to be the same as the event.target.checked in the line above it!", "But it always returns the opposite of what it should.", "Same goes for when I use !this.state.barClubLounge; If it starts false, on my first click it remains false, even though whether the checkbox is checked or not is based off of the state!!", "It's a crazy paradox and I have no idea whats going on, please help!", "Reason is setState is asynchronous, you can't expect the updated state value just after the setState, if you want to check the value use a callback method.", "Pass a method as callback that will be get executed after the setState complete its task.", "Why setState is asynchronous ?", "This is because setState alters the state and causes re rendering.", "This can be an expensive operation and making it synchronous might leave the browser unresponsive.", "Thus the setState calls are asynchronous as well as batched for better UI experience and performance.", "From Doc: setState() does not immediately mutate this.state but creates a pending state transition.", "Accessing this.state after calling this method can potentially return the existing value.", "There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.", "Using callback method with setState: To check the updated state value just after the setState, use a callback method like this: setState({ key: value }, () => { console.log('updated state value', this.state.key) }) Check this: class NightlifeTypes extends React.Component { constructor(props) { super(props); this.state = { barClubLounge: false, seeTheTown: true, eventsEntertainment: true, familyFriendlyOnly: false } } handleOnChange = (event) => { // Arrow function binds `this` let value = event.target.checked; if(event.target.className == \"barClubLounge\") { this.setState({ barClubLounge: value}, () => { //here console.log(value); console.log(this.state.barClubLounge); //both will print same value }); } } render() { return ( <input className=\"barClubLounge\" type='checkbox' onChange={this.handleOnChange} checked={this.state.barClubLounge}/> ) } } ReactDOM.render(<NightlifeTypes/>, document.getElementById('app')) <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js\"></script> <div id='app'/> Since setState is a async function.", "That means after calling setState state variable does not immediately change.", "So if you want to perform other actions immediately after changing the state you should use callback method of setstate inside your setState update function.", "handleOnChange = (event) => { let inputState = event.target.checked; if(event.target.className == \"barClubLounge\") { this.setState({ barClubLounge: inputState}, () => { //here console.log(this.state.barClubLounge); //here you can call other functions which use this state variable // }); } } This is by-design due to performance considerations.", "setState in React is a function guaranteed to re-render Component, which is a costly CPU process.", "As such, its designers wanted to optimize by gathering multiple rendering actions into one, hence setState is asynchronous.", "I have two components.", "Parent component Child component I was trying to call child's method from Parent, I tried this way but couldn't get a result class Parent extends Component { render() { return ( <Child> <button onClick={Child.getAlert()}>Click</button> </Child> ); } } class Child extends Component { getAlert() { alert('clicked'); } render() { return ( <h1 ref=\"hello\">Hello</h1> ); } } Is there a way to call child's method from the parent ?", "Note: Child and Parent components are in two different files First off, let me express that this is generally not the way to go about things in React land.", "Usually what you want to do is pass down functionality to children in props, and pass up notifications from children in events (or better yet: dispatch).", "But if you must expose an imperative method on a child component, you can use refs.", "Remember this is an escape hatch and usually indicates a better design is available.", "Previously, refs were only supported for Class-based components.", "With the advent of React Hooks, that's no longer the case Using Hooks and Function Components (>= react@16.8) const { forwardRef, useRef, useImperativeHandle } = React; // We need to wrap component in `forwardRef` in order to gain // access to the ref object that is assigned using the `ref` prop.", "// This ref is passed as the second parameter to the function component.", "const Child = forwardRef((props, ref) => { // The component instance will be extended // with whatever you return from the callback passed // as the second argument useImperativeHandle(ref, () => ({ getAlert() { alert(\"getAlert from Child\"); } })); return <h1>Hi</h1>; }); const Parent = () => { // In order to gain access to the child component instance, // you need to assign it to a `ref`, so we call `useRef()` to get one const childRef = useRef(); return ( <div> <Child ref={childRef} /> <button onClick={() => childRef.current.getAlert()}>Click</button> </div> ); }; ReactDOM.render( <Parent />, document.getElementById('root') ); <script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script> <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script> <div id=\"root\"></div> Documentation for useImperativeHandle() is here: useImperativeHandle customizes the instance value that is exposed to parent components when using ref.", "Using Class Components (>= react@16.4) const { Component } = React; class Parent extends Component { constructor(props) { super(props); this.child = React.createRef(); } onClick = () => { this.child.current.getAlert(); }; render() { return ( <div> <Child ref={this.child} /> <button onClick={this.onClick}>Click</button> </div> ); } } class Child extends Component { getAlert() { alert('getAlert from Child'); } render() { return <h1>Hello</h1>; } } ReactDOM.render(<Parent />, document.getElementById('root')); <script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script> <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script> <div id=\"root\"></div> Legacy API (<= react@16.3) For historical purposes, here's the callback-based style you'd use with React versions before 16.3: const { Component } = React; const { render } = ReactDOM; class Parent extends Component { render() { return ( <div> <Child ref={instance => { this.child = instance; }} /> <button onClick={() => { this.child.getAlert(); }}>Click</button> </div> ); } } class Child extends Component { getAlert() { alert('clicked'); } render() { return ( <h1>Hello</h1> ); } } render( <Parent />, document.getElementById('app') ); <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js\"></script> <div id=\"app\"></div> You can use another pattern here: class Parent extends Component { render() { return ( <div> <Child setClick={click => this.clickChild = click}/> <button onClick={() => this.clickChild()}>Click</button> </div> ); } } class Child extends Component { constructor(props) { super(props); this.getAlert = this.getAlert.bind(this); } componentDidMount() { this.props.setClick(this.getAlert); } getAlert() { alert('clicked'); } render() { return ( <h1 ref=\"hello\">Hello</h1> ); } } What it does is to set the parent's clickChild method when child is mounted.", "In this way when you click the button in parent it will call clickChild which calls child's getAlert.", "This also works if your child is wrapped with connect() so you don't need the getWrappedInstance() hack.", "Note you can't use onClick={this.clickChild} in parent because when parent is rendered child is not mounted so this.clickChild is not assigned yet.", "Using onClick={() => this.clickChild()} is fine because when you click the button this.clickChild should already be assigned.", "Alternative method with useEffect: Parent: const [refresh, doRefresh] = useState(0); <Button onClick={() => doRefresh(prev => prev + 1)} /> <Children refresh={refresh} /> Children: useEffect(() => { performRefresh(); //children function of interest }, [props.refresh]); https://facebook.github.io/react/tips/expose-component-functions.html for more answers ref here Call methods on React children components By looking into the refs of the \"reason\" component, you're breaking encapsulation and making it impossible to refactor that component without carefully examining all the places it's used.", "Because of this, we strongly recommend treating refs as private to a component, much like state.", "In general, data should be passed down the tree via props.", "There are a few exceptions to this (such as calling .focus() or triggering a one-time animation that doesn't really \"change\" the state) but any time you're exposing a method called \"set\", props are usually a better choice.", "Try to make it so that the inner input component worries about its size and appearance so that none of its ancestors do.", "We can use refs in another way as- We are going to create a Parent element, it will render a <Child/> component.", "As you can see, the component that will be rendered, you need to add the ref attribute and provide a name for it.", "Then, the triggerChildAlert function, located in the parent class will access the refs property of the this context (when the triggerChildAlert function is triggered will access the child reference and it will has all the functions of the child element).", "class Parent extends React.Component { triggerChildAlert(){ this.refs.child.callChildMethod(); // to get child parent returned value- // this.value = this.refs.child.callChildMethod(); // alert('Returned value- '+this.value); } render() { return ( <div> {/* Note that you need to give a value to the ref parameter, in this case child*/} <Child ref=\"child\" /> <button onClick={this.triggerChildAlert}>Click</button> </div> ); } } Now, the child component, as theoretically designed previously, will look like: class Child extends React.Component { callChildMethod() { alert('Hello World'); // to return some value // return this.state.someValue; } render() { return ( <h1>Hello</h1> ); } } Here is the source code- Hope will help you !", "If you are doing this simply because you want the Child to provide a re-usable trait to its parents, then you might consider doing that using render-props instead.", "That technique actually turns the structure upside down.", "The Child now wraps the parent, so I have renamed it to AlertTrait below.", "I kept the name Parent for continuity, although it is not really a parent now.", "// Use it like this: <AlertTrait renderComponent={Parent}/> class AlertTrait extends Component { // You will need to bind this function, if it uses 'this' doAlert() { alert('clicked'); } render() { return this.props.renderComponent({ doAlert: this.doAlert }); } } class Parent extends Component { render() { return ( <button onClick={this.props.doAlert}>Click</button> ); } } In this case, the AlertTrait provides one or more traits which it passes down as props to whatever component it was given in its renderComponent prop.", "The Parent receives doAlert as a prop, and can call it when needed.", "(For clarity, I called the prop renderComponent in the above example.", "But in the React docs linked above, they just call it render.)", "The Trait component can render stuff surrounding the Parent, in its render function, but it does not render anything inside the parent.", "Actually it could render things inside the Parent, if it passed another prop (e.g.", "renderChild) to the parent, which the parent could then use during its render method.", "This is somewhat different from what the OP asked for, but some people might end up here (like we did) because they wanted to create a reusable trait, and thought that a child component was a good way to do that.", "I wasn't satisfied with any of the solutions presented here.", "There is actually a very simple solution that can be done using pure Javascript without relying upon some React functionality other than the basic props object - and it gives you the benefit of communicating in either direction (parent -> child, child -> parent).", "You need to pass an object from the parent component to the child component.", "This object is what I refer to as a \"bi-directional reference\" or biRef for short.", "Basically, the object contains a reference to methods in the parent that the parent wants to expose.", "And the child component attaches methods to the object that the parent can call.", "Something like this: // Parent component.", "function MyParentComponent(props) { function someParentFunction() { // The child component can call this function. }", "function onButtonClick() { // Call the function inside the child component.", "biRef.someChildFunction(); } // Add all the functions here that the child can call.", "var biRef = { someParentFunction: someParentFunction } return <div> <MyChildComponent biRef={biRef} /> <Button onClick={onButtonClick} /> </div>; } // Child component function MyChildComponent(props) { function someChildFunction() { // The parent component can call this function. }", "function onButtonClick() { // Call the parent function.", "props.biRef.someParentFunction(); } // Add all the child functions to props.biRef that you want the parent // to be able to call.", "props.biRef.someChildFunction = someChildFunction; return <div> <Button onClick={onButtonClick} /> </div>; } The other advantage to this solution is that you can add a lot more functions in the parent and child while passing them from the parent to the child using only a single property.", "An improvement over the code above is to not add the parent and child functions directly to the biRef object but rather to sub members.", "Parent functions should be added to a member called \"parent\" while the child functions should be added to a member called \"child\".", "// Parent component.", "function MyParentComponent(props) { function someParentFunction() { // The child component can call this function. }", "function onButtonClick() { // Call the function inside the child component.", "biRef.child.someChildFunction(); } // Add all the functions here that the child can call.", "var biRef = { parent: { someParentFunction: someParentFunction } } return <div> <MyChildComponent biRef={biRef} /> <Button onClick={onButtonClick} /> </div>; } // Child component function MyChildComponent(props) { function someChildFunction() { // The parent component can call this function. }", "function onButtonClick() { // Call the parent function.", "props.biRef.parent.someParentFunction(); } // Add all the child functions to props.biRef that you want the parent // to be able to call.", "props.biRef { child: { someChildFunction: someChildFunction } } return <div> <Button onClick={onButtonClick} /> </div>; } By placing parent and child functions into separate members of the biRef object, you 'll have a clean separation between the two and easily see which ones belong to parent or child.", "It also helps to prevent a child component from accidentally overwriting a parent function if the same function appears in both.", "One last thing is that if you note, the parent component creates the biRef object with var whereas the child component accesses it through the props object.", "It might be tempting to not define the biRef object in the parent and access it from its parent through its own props parameter (which might be the case in a hierarchy of UI elements).", "This is risky because the child may think a function it is calling on the parent belongs to the parent when it might actually belong to a grandparent.", "There's nothing wrong with this as long as you are aware of it.", "Unless you have a reason for supporting some hierarchy beyond a parent/child relationship, it's best to create the biRef in your parent component.", "I hope I'm not repeating anything from above but what about passing a callback prop that sets the function in the parent?", "This works and is pretty easy.", "(Added code is between the ////'s) class Parent extends Component { ///// getAlert = () => {} // initial value for getAlert setGetAlertMethod = (newMethod) => { this.getAlert = newMethod; } ///// render() { return ( <Child setGetAlertMethod={this.setGetAlertMethod}> <button onClick={this.getAlert}>Click</button> </Child> ); } } class Child extends Component { ///// componentDidMount() { this.props.setGetAlertMethod(this.getAlert); } ///// getAlert() => { alert('clicked'); } render() { return ( <h1 ref=\"hello\">Hello</h1> ); } } You can achieve this easily in this way Steps- Create a boolean variable in the state in the parent class.", "Update this when you want to call a function.", "Create a prop variable and assign the boolean variable.", "From the child component access that variable using props and execute the method you want by having an if condition.", "class Child extends Component { Method=()=>{ --Your method body-- } render() { return ( //check whether the variable has been updated or not if(this.props.updateMethod){ this.Method(); } ) } } class Parent extends Component { constructor(){ this.state={ callMethod:false } } render() { return ( //update state according to your requirement this.setState({ callMethod:true }} <Child updateMethod={this.state.callMethod}></Child> ); } } I'm using useEffect hook to overcome the headache of doing all this so now I pass a variable down to child like this: <ParentComponent> <ChildComponent arbitrary={value} /> </ParentComponent> useEffect(() => callTheFunctionToBeCalled(value) , [value]); Here my demo: https://stackblitz.com/edit/react-dgz1ee?file=styles.css I am using useEffect to call the children component's methods.", "I have tried with Proxy and Setter_Getter but sor far useEffect seems to be the more convenient way to call a child method from parent.", "To use Proxy and Setter_Getter it seems there is some subtlety to overcome first, because the element firstly rendered is an objectLike's element through the ref.current return => <div/>'s specificity.", "Concerning useEffect, you can also leverage on this approach to set the parent's state depending on what you want to do with the children.", "In the demo's link I have provided, you will find my full ReactJS' code with my draftwork inside's so you can appreciate the workflow of my solution.", "Here I am providing you my ReactJS' snippet with the relevant code only.", ": import React, { Component, createRef, forwardRef, useState, useEffect } from \"react\"; {...} // Child component // I am defining here a forwardRef's element to get the Child's methods from the parent // through the ref's element.", "let Child = forwardRef((props, ref) => { // I am fetching the parent's method here // that allows me to connect the parent and the child's components let { validateChildren } = props; // I am initializing the state of the children // good if we can even leverage on the functional children's state let initialState = { one: \"hello world\", two: () => { console.log(\"I am accessing child method from parent :].", "\"); return \"child method achieve\"; } }; // useState initialization const [componentState, setComponentState] = useState(initialState); // useEffect will allow me to communicate with the parent // through a lifecycle data flow useEffect(() => { ref.current = { componentState }; validateChildren(ref.current.componentState.two); }); {...} }); {...} // Parent component class App extends Component { // initialize the ref inside the constructor element constructor(props) { super(props); this.childRef = createRef(); } // I am implementing a parent's method // in child useEffect's method validateChildren = childrenMethod => { // access children method from parent childrenMethod(); // or signaling children is ready console.log(\"children active\"); }; {...} render(){ return ( { // I am referencing the children // also I am implementing the parent logic connector's function // in the child, here => this.validateChildren's function } <Child ref={this.childRef} validateChildren={this.validateChildren} /> </div> ) } We're happy with a custom hook we call useCounterKey.", "It just sets up a counterKey, or a key that counts up from zero.", "The function it returns resets the key (i.e.", "increment).", "(I believe this is the most idiomatic way in React to reset a component - just bump the key.)", "However this hook also works in any situation where you want to send a one-time message to the client to do something.", "E.g.", "we use it to focus a control in the child on a certain parent event - it just autofocuses anytime the key is updated.", "(If more props are needed they could be set prior to resetting the key so they're available when the event happens.)", "This method has a bit of a learning curve b/c it's not as straightforward as a typical event handler, but it seems the most idiomatic way to handle this in React that we've found (since keys already function this way).", "Def open to feedback on this method but it is working well!", "// Main helper hook: export function useCounterKey() { const [key, setKey] = useState(0); return [key, () => setKey(prev => prev + 1)] as const; } Sample usages: // Sample 1 - normal React, just reset a control by changing Key on demand function Sample1() { const [inputLineCounterKey, resetInputLine] = useCounterKey(); return <> <InputLine key={inputLineCounterKey} /> <button onClick={() => resetInputLine()} /> <>; } // Second sample - anytime the counterKey is incremented, child calls focus() on the input function Sample2() { const [amountFocusCounterKey, focusAmountInput] = useCounterKey(); // ... call focusAmountInput in some hook or event handler as needed return <WorkoutAmountInput focusCounterKey={amountFocusCounterKey} /> } function WorkoutAmountInput(props) { useEffect(() => { if (counterKey > 0) { // Don't focus initially focusAmount(); } }, [counterKey]); // ... } (Credit to Kent Dodds for the counterKey concept.)", "You can make Inheritance Inversion (look it up here: https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e).", "That way you have access to instance of the component that you would be wrapping (thus you'll be able to access it's functions) I think that the most basic way to call methods is by setting a request on the child component.", "Then as soon as the child handles the request, it calls a callback method to reset the request.", "The reset mechanism is necessary to be able to send the same request multiple times after each other.", "In parent component In the render method of the parent: const { request } = this.state; return (<Child request={request} onRequestHandled={()->resetRequest()}/>); The parent needs 2 methods, to communicate with its child in 2 directions.", "sendRequest() { const request = { param: \"value\" }; this.setState({ request }); } resetRequest() { const request = null; this.setState({ request }); } In child component The child updates its internal state, copying the request from the props.", "constructor(props) { super(props); const { request } = props; this.state = { request }; } static getDerivedStateFromProps(props, state) { const { request } = props; if (request !== state.request ) return { request }; return null; } Then finally it handles the request, and sends the reset to the parent: componentDidMount() { const { request } = this.state; // todo handle request.", "const { onRequestHandled } = this.props; if (onRequestHandled != null) onRequestHandled(); } Another way of triggering a child function from parent is to make use of the componentDidUpdate function in child Component.", "I pass a prop triggerChildFunc from Parent to Child, which initially is null.", "The value changes to a function when the button is clicked and Child notice that change in componentDidUpdate and calls its own internal function.", "Since prop triggerChildFunc changes to a function, we also get a callback to the Parent.", "If Parent don't need to know when the function is called the value triggerChildFunc could for example change from null to true instead.", "const { Component } = React; const { render } = ReactDOM; class Parent extends Component { state = { triggerFunc: null } render() { return ( <div> <Child triggerChildFunc={this.state.triggerFunc} /> <button onClick={() => { this.setState({ triggerFunc: () => alert('Callback in parent')}) }}>Click </button> </div> ); } } class Child extends Component { componentDidUpdate(prevProps) { if (this.props.triggerChildFunc !== prevProps.triggerChildFunc) { this.onParentTrigger(); } } onParentTrigger() { alert('parent triggered me'); // Let's call the passed variable from parent if it's a function if (this.props.triggerChildFunc && {}.toString.call(this.props.triggerChildFunc) === '[object Function]') { this.props.triggerChildFunc(); } } render() { return ( <h1>Hello</h1> ); } } render( <Parent />, document.getElementById('app') ); <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.6.3/umd/react.production.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.6.3/umd/react-dom.production.min.js\"></script> <div id='app'></div> CodePen: https://codepen.io/calsal/pen/NWPxbJv?editors=1010 Here's a bug?", "to look out for: I concur with rossipedia's solution using forwardRef, useRef, useImperativeHandle There's some misinformation online that says refs can only be created from React Class components, but you can indeed use Function Components if you use the aforementioned hooks above.", "A note, the hooks only worked for me after I changed the file to not use withRouter() when exporting the component.", "I.e.", "a change from export default withRouter(TableConfig); to instead be export default TableConfig; In hindsight the withRouter() is not needed for such a component anyway, but usually it doesn't hurt anything having it in.", "My use case is that I created a component to create a Table to handle the viewing and editing of config values, and I wanted to be able to tell this Child component to reset it's state values whenever the Parent form's Reset button was hit.", "UseRef() wouldn't properly get the ref or ref.current (kept on getting null) until I removed withRouter() from the file containing my child component TableConfig", "I understand that React tutorials and documentation warn in no uncertain terms that state should not be directly mutated and that everything should go through setState.", "I would like to understand why, exactly, I can't just directly change state and then (in the same function) call this.setState({}) just to trigger the render.", "E.g.", ": The below code seems to work just fine: const React = require('react'); const App = React.createClass({ getInitialState: function() { return { some: { rather: { deeply: { embedded: { stuff: 1 }}}}}; }, updateCounter: function () { this.state.some.rather.deeply.embedded.stuff++; this.setState({}); // just to trigger the render ... }, render: function() { return ( <div> Counter value: {this.state.some.rather.deeply.embedded.stuff} <br></br> <button onClick={this.updateCounter}>inc</button> </div> ); } }); export default App; I am all for following conventions but I would like to enhance my further understanding of how ReactJS actually works and what can go wrong or is it sub-optimal with the above code.", "The notes under the this.setState documentation basically identify two gotchas: That if you mutate state directly and then subsequently call this.setState this may replace (overwrite?)", "the mutation you made.", "I don't see how this can happen in the above code.", "That setState may mutate this.state effectively in an asynchronous / deferred way and so when accessing this.state right after calling this.setState you are not guaranteed to access the final mutated state.", "I get that, by this is not an issue if this.setState is the last call of the update function.", "The React docs for setState have this to say: NEVER mutate this.state directly, as calling setState() afterwards may replace the mutation you made.", "Treat this.state as if it were immutable.", "setState() does not immediately mutate this.state but creates a pending state transition.", "Accessing this.state after calling this method can potentially return the existing value.", "There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.", "setState() will always trigger a re-render unless conditional rendering logic is implemented in shouldComponentUpdate().", "If mutable objects are being used and the logic cannot be implemented in shouldComponentUpdate(), calling setState() only when the new state differs from the previous state will avoid unnecessary re-renders.", "Basically, if you modify this.state directly, you create a situation where those modifications might get overwritten.", "Related to your extended questions 1) and 2), setState() is not immediate.", "It queues a state transition based on what it thinks is going on which may not include the direct changes to this.state.", "Since it's queued rather than applied immediately, it's entirely possible that something is modified in between such that your direct changes get overwritten.", "If nothing else, you might be better off just considering that not directly modifying this.state can be seen as good practice.", "You may know personally that your code interacts with React in such a way that these over-writes or other issues can't happen but you're creating a situation where other developers or future updates can suddenly find themselves with weird or subtle issues.", "This answer is to provide enough information to not change/mutate the state directly in React.", "React follows Unidirectional Data Flow.", "Meaning, the data flow inside react should and will be expected to be in a circular path.", "React's Data flow without flux To make React work like this, developers made the React similar to functional programming.", "The thumb rule of functional programming is immutability.", "Let me explain it loud and clear.", "How does the unidirectional flow works?", "states are a data store which contains the data of a component.", "The view of a component renders based on the state.", "When the view needs to change something on the screen, that value should be supplied from the store.", "To make this happen, React provides setState() function which takes in an object of new states and does an compare and merge(similar to object.assign()) over the previous state and adds the new state to the state data store.", "Whenever the data in the state store changes, react will trigger an re-render with the new state which the view consumes and shows it on the screen.", "This cycle will continue throughout the component's lifetime.", "If you see the above steps, it clearly shows a lot of things are happening behind when you change the state.", "So, when you mutate the state directly and call setState() with an empty object.", "The previous state will be polluted with your mutation.", "Due to which, the shallow compare and merge of two states will be disturbed or won't happen, because you'll have only one state now.", "This will disrupt all the React's Lifecycle Methods.", "As a result, your app will behave abnormal or even crash.", "Most of the times, it won't affect your app because all the apps which we use for testing this are pretty small.", "And another downside of mutation of Objects and Arrays in JavaScript is, when you assign an object or an array, you're just making a reference of that object or that array.", "When you mutate them, all the reference to that object or that array will be affected.", "React handles this in a intelligent way in the background and simply give us an API to make it work.", "Most common errors done when handling states in React //original state this.state = { a: [1,2,3,4,5] } //changing the state in react //need to add '6' in the array //bad approach const b = this.state.a.push(6) this.setState({ a: b }) In the above example, this.state.a.push(6) will mutate the state directly.", "Assigning it to another variable and calling setState is same as what's shown below.", "As we mutated the state anyway, there's no point assigning it to another variable and calling setState with that variable.", "//same as this.state.a.push(6) this.setState({}) Most of the people does this.", "This is so wrong.", "This breaks the beauty of React and it'll make you a bad programmer.", "So, What's the best way to handle states in React?", "Let me explain.", "When you need to change 'something' in the existing state, first get a copy of that 'something' from the current state.", "//original state this.state = { a: [1,2,3,4,5] } //changing the state in react //need to add '6' in the array //create a copy of this.state.a //you can use ES6's destructuring or loadash's _.clone() const currentStateCopy = [...this.state.a] Now, mutating currentStateCopy won't mutate the original state.", "Do operations over currentStateCopy and set it as the new state using setState().", "currentStateCopy.push(6) this.state({ a: currentStateCopy }) This is beautify, right?", "By doing this, all the references of this.state.a won't get affected until we use setState.", "This gives you control over your code and this'll help you write elegant test and make you confident about the performance of the code in production.", "To answer your question, Why can't I directly modify a component's state?", "Yes, you can.", "But, you need to face the following consequences.", "When you scale, you'll be writing unmanageable code.", "You'll lose control of state across components.", "Instead of using React, you'll be writing custom codes over React.", "Immutability is not necessary thing because JavaScript is single threaded.", "But, It's a good to follow practice which will help you in the long run.", "PS.", "I've written about 10000 lines of mutable React JS code.", "If it breaks now, I don't know where to look into because all the values are mutated somewhere.", "When I realized this, I started writing immutable code.", "Trust me!", "That's the best thing you can do it to a product or an app.", "Hope this helps!", "the simplest answer to \" Why can't I directly modify a component's state: is all about Updating phase.", "when we update the state of a component all it's children are going to be rendered as well.", "or our entire component tree rendered.", "but when i say our entire component tree is rendered that doesn\u2019t mean that the entire DOM is updated.", "when a component is rendered we basically get a react element, so that is updating our virtual dom.", "React will then look at the virtual DOM, it also has a copy of the old virtual DOM, that is why we shouldn\u2019t update the state directly, so we can have two different object references in memory, we have the old virtual DOM as well as the new virtual DOM.", "then react will figure out what is changed and based on that it will update the real DOM accordingly .", "hope it helps.", "To avoid every time to create a copy of this.state.element you can use update with $set or $push or many others from immutability-helper e.g.", ": import update from 'immutability-helper'; const newData = update(myData, { x: {y: {z: {$set: 7}}}, a: {b: {$push: [9]}} }); setState trigger re rendering of the components.when we want to update state again and again we must need to setState otherwise it doesn't work correctly.", "My current understanding is based on this and this answer: IF you don't use shouldComponentUpdate or any other lifecycle methods (like componentWillReceiveProps, componentWillUpdate, and componentDidUpdate) where you compare the old and new props/state THEN its fine to mutate state and then call setState(), otherwise it is not fine.", "I am developing an application in which I check if the user is not loggedIn.", "I have to display the login form, else dispatch an action that would change the route and load other component.", "Here is my code: render() { if (isLoggedIn) { // dispatch an action to change the route } // return login component <Login /> } How can I achieve this as I cannot change states inside the render function.", "Considering you are using react-router v4 Use your component with withRouter and use history.push from props to change the route.", "You need to make use of withRouter only when your component is not receiving the Router props, this may happen in cases when your component is a nested child of a component rendered by the Router and you haven't passed the Router props to it or when the component is not linked to the Router at all and is rendered as a separate component from the Routes.", "import {withRouter} from 'react-router'; class App extends React.Component { ... componenDidMount() { // get isLoggedIn from localStorage or API call if (isLoggedIn) { // dispatch an action to change the route this.props.history.push('/home'); } } render() { // return login component return <Login /> } } export default withRouter(App); Important Note If you are using withRouter to prevent updates from being blocked by shouldComponentUpdate, it is important that withRouter wraps the component that implements shouldComponentUpdate.", "For example, when using Redux: // This gets around shouldComponentUpdate withRouter(connect(...)(MyComponent)) // This does not connect(...)(withRouter(MyComponent)) or you could use Redirect import {withRouter} from 'react-router'; class App extends React.Component { ... render() { if(isLoggedIn) { return <Redirect to=\"/home\"/> } // return login component return <Login /> } } With react-router v2 or react-router v3, you can make use of context to dynamically change the route like class App extends React.Component { ... render() { if (isLoggedIn) { // dispatch an action to change the route this.context.router.push('/home'); } // return login component return <Login /> } } App.contextTypes = { router: React.PropTypes.object.isRequired } export default App; or use import { browserHistory } from 'react-router'; browserHistory.push('/some/path'); In react-router version 4: import React from 'react' import { BrowserRouter as Router, Route, Redirect} from 'react-router-dom' const Example = () => ( if (isLoggedIn) { <OtherComponent /> } else { <Router> <Redirect push to=\"/login\" /> <Route path=\"/login\" component={Login}/> </Router> } ) const Login = () => ( <h1>Form Components</h1> ... ) export default Example; Another alternative is to handle this using Thunk-style asynchronous actions (which are safe/allowed to have side-effects).", "If you use Thunk, you can inject the same history object into both your <Router> component and Thunk actions using thunk.withExtraArgument, like this: import React from 'react' import { BrowserRouter as Router, Route, Redirect} from 'react-router-dom' import { createBrowserHistory } from \"history\" import { applyMiddleware, createStore } from \"redux\" import thunk from \"redux-thunk\" const history = createBrowserHistory() const middlewares = applyMiddleware(thunk.withExtraArgument({history})) const store = createStore(appReducer, middlewares) render( <Provider store={store} <Router history={history}> <Route path=\"*\" component={CatchAll} /> </Router </Provider>, appDiv) Then in your action-creators, you will have a history instance that is safe to use with ReactRouter, so you can just trigger a regular Redux event if you're not logged in: // meanwhile... in action-creators.js export const notLoggedIn = () => { return (dispatch, getState, {history}) => { history.push(`/login`) } } Another advantage of this is that the url is easier to handle, now, so we can put redirect info on the query string, etc.", "You can try still doing this check in your Render methods, but if it causes problems, you might consider doing it in componentDidMount, or elsewhere in the lifecycle (although also I understand the desire to stick with Stateless Functional Compeonents!)", "You can still use Redux and mapDispatchToProps to inject the action creator into your comptonent, so your component is still only loosely connected to Redux.", "Those who are facing issues in implementing this on react-router v4.", "Here is a working solution for navigating through the react app programmatically.", "history.js import createHistory from 'history/createBrowserHistory' export default createHistory() App.js OR Route.jsx.", "Pass history as a prop to your Router.", "import { Router, Route } from 'react-router-dom' import history from './history' ... <Router history={history}> <Route path=\"/test\" component={Test}/> </Router> You can use push() to navigate.", "import history from './history' ... render() { if (isLoggedIn) { history.push('/test') // this should change the url and re-render Test component } // return login component <Login /> } All thanks to this comment: https://github.com/ReactTraining/react-router/issues/3498#issuecomment-301057248 This is my handle loggedIn.", "react-router v4 PrivateRoute is allow enter path if user is loggedIn and save the token to localStorge function PrivateRoute({ component: Component, ...rest }) { return ( <Route {...rest} render={props => (localStorage.token) ?", "<Component {...props} /> : ( <Redirect to={{ pathname: '/signin', state: { from: props.location }, }} /> ) } /> ); } Define all paths in your app in here export default ( <main> <Switch> <Route exact path=\"/signin\" component={SignIn} /> <Route exact path=\"/signup\" component={SignUp} /> <PrivateRoute path=\"/\" component={Home} /> </Switch> </main> ); render(){ return ( <div> { this.props.redirect ?", "<Redirect to=\"/\" /> :'' } <div> add here component codes </div> </div> ); } I would suggest you to use connected-react-router https://github.com/supasate/connected-react-router which helps to perform navigation even from reducers/actions if you want.", "it is well documented and easy to configure I was able to use history within stateless functional component, using withRouter following way (needed to ignore typescript warning): import { withRouter } from 'react-router-dom'; ... type Props = { myProp: boolean }; // @ts-ignore export const MyComponent: FC<Props> = withRouter(({ myProp, history }) => { ... })", "I have just found that in react this.setState() function in any component is asynchronous or is called after the completion of the function that it was called in.", "Now I searched and found this blog (setState() State Mutation Operation May Be Synchronous In ReactJS) Here he found that setState is async(called when stack is empty) or sync(called as soon as called) depending on how the change of state was triggered.", "Now these two things are hard to digest In the blog the setState function is called inside a function updateState, but what triggered the updateState function is not something that a called function would know about.", "Why would they make setState async as JS is single threaded language and this setState is not a WebAPI or server call so has to be done on JS's thread only.", "Are they doing this so that Re-Rendering does not stop all the event listeners and stuff, or there is some other design issue.", "You can call a function after the state value has updated: this.setState({foo: 'bar'}, () => { // Do something here.", "}); Also, if you have lots of states to update at once, group them all within the same setState: Instead of: this.setState({foo: \"one\"}, () => { this.setState({bar: \"two\"}); }); Just do this: this.setState({ foo: \"one\", bar: \"two\" }); 1) setState actions are asynchronous and are batched for performance gains.", "This is explained in the documentation of setState.", "setState() does not immediately mutate this.state but creates a pending state transition.", "Accessing this.state after calling this method can potentially return the existing value.", "There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.", "2) Why would they make setState async as JS is a single threaded language and this setState is not a WebAPI or server call?", "This is because setState alters the state and causes rerendering.", "This can be an expensive operation and making it synchronous might leave the browser unresponsive.", "Thus the setState calls are asynchronous as well as batched for better UI experience and performance.", "I know this question is old, but it has been causing a lot of confusion for many reactjs users for a long time, including me.", "Recently Dan Abramov (from the react team) just wrote up a great explanation as to why the nature of setState is async: https://github.com/facebook/react/issues/11527#issuecomment-360199710 setState is meant to be asynchronous, and there are a few really good reasons for that in the linked explanation by Dan Abramov.", "This doesn't mean it will always be asynchronous - it mainly means that you just can't depend on it being synchronous.", "ReactJS takes into consideration many variables in the scenario that you're changing the state in, to decide when the state should actually be updated and your component rerendered.", "A simple example to demonstrate this, is that if you call setState as a reaction to a user action, then the state will probably be updated immediately (although, again, you can't count on it), so the user won't feel any delay, but if you call setState in reaction to an ajax call response or some other event that isn't triggered by the user, then the state might be updated with a slight delay, since the user won't really feel this delay, and it will improve performance by waiting to batch multiple state updates together and rerender the DOM fewer times.", "Good article here https://github.com/vasanthk/react-bits/blob/master/patterns/27.passing-function-to-setState.md // assuming this.state.count === 0 this.setState({count: this.state.count + 1}); this.setState({count: this.state.count + 1}); this.setState({count: this.state.count + 1}); // this.state.count === 1, not 3 Solution this.setState((prevState, props) => ({ count: prevState.count + props.increment })); or pass callback this.setState ({.....},callback) https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82 https://medium.freecodecamp.org/functional-setstate-is-the-future-of-react-374f30401b6b You can use the following wrap to make sync call this.setState((state =>{ return{ something } }) Imagine incrementing a counter in some component: class SomeComponent extends Component{ state = { updatedByDiv: '', updatedByBtn: '', counter: 0 } divCountHandler = () => { this.setState({ updatedByDiv: 'Div', counter: this.state.counter + 1 }); console.log('divCountHandler executed'); } btnCountHandler = () => { this.setState({ updatedByBtn: 'Button', counter: this.state.counter + 1 }); console.log('btnCountHandler executed'); } ... ... render(){ return ( ... // a parent div <div onClick={this.divCountHandler}> // a child button <button onClick={this.btnCountHandler}>Increment Count</button> </div> ... ) } } There is a count handler attached to both the parent and the child components.", "This is done purposely so we can execute the setState() twice within the same click event bubbling context, but from within 2 different handlers.", "As we would imagine, a single click event on the button would now trigger both these handlers since the event bubbles from target to the outermost container during the bubbling phase.", "Therefore the btnCountHandler() executes first, expected to increment the count to 1 and then the divCountHandler() executes, expected to increment the count to 2.", "However the count only increments to 1 as you can inspect in React Developer tools.", "This proves that react queues all the setState calls comes back to this queue after executing the last method in the context(the divCountHandler in this case) merges all the object mutations happening within multiple setState calls in the same context(all method calls within a single event phase is same context for e.g.)", "into one single object mutation syntax (merging makes sense because this is why we can update the state properties independently in setState() in the first place) and passes it into one single setState() to prevent re-rendering due to multiple setState() calls (this is a very primitive description of batching).", "Resultant code run by react: this.setState({ updatedByDiv: 'Div', updatedByBtn: 'Button', counter: this.state.counter + 1 }) To stop this behaviour, instead of passing objects as arguments to the setState method, callbacks are passed.", "divCountHandler = () => { this.setState((prevState, props) => { return { updatedByDiv: 'Div', counter: prevState.counter + 1 }; }); console.log('divCountHandler executed'); } btnCountHandler = () => { this.setState((prevState, props) => { return { updatedByBtn: 'Button', counter: prevState.counter + 1 }; }); console.log('btnCountHandler executed'); } After the last method finishes execution and when react returns to process the setState queue, it simply calls the callback for each setState queued, passing in the previous component state.", "This way react ensures that the last callback in the queue gets to update the state that all of its previous counterparts have laid hands on.", "Yes, setState() is asynchronous.", "From the link: https://reactjs.org/docs/react-component.html#setstate React does not guarantee that the state changes are applied immediately.", "setState() does not always immediately update the component.", "Think of setState() as a request rather than an immediate command to update the component.", "Because they think From the link: https://github.com/facebook/react/issues/11527#issuecomment-360199710 ... we agree that setState() re-rendering synchronously would be inefficient in many cases Asynchronous setState() makes life very difficult for those getting started and even experienced unfortunately: - unexpected rendering issues: delayed rendering or no rendering (based on program logic) - passing parameters is a big deal among other issues.", "Below example helped: // call doMyTask1 - here we set state // then after state is updated... // call to doMyTask2 to proceed further in program constructor(props) { // .. // This binding is necessary to make `this` work in the callback this.doMyTask1 = this.doMyTask1.bind(this); this.doMyTask2 = this.doMyTask2.bind(this); } function doMyTask1(myparam1) { // .. this.setState( { mystate1: 'myvalue1', mystate2: 'myvalue2' // ... }, () => { this.doMyTask2(myparam1); } ); } function doMyTask2(myparam2) { // .. } Hope that helps.", "I'm new to using ES6 classes with React, previously I've been binding my methods to the current object (show in first example), but does ES6 allow me to permanently bind a class function to a class instance with arrows?", "(Useful when passing as a callback function.)", "I get errors when I try to use them as you can with CoffeeScript: class SomeClass extends React.Component { // Instead of this constructor(){ this.handleInputChange = this.handleInputChange.bind(this) } // Can I somehow do this?", "Am i just getting the syntax wrong?", "handleInputChange (val) => { console.log('selectionMade: ', val); } So that if I were to pass SomeClass.handleInputChange to, for instance setTimeout, it would be scoped to the class instance, and not the window object.", "Your syntax is slightly off, just missing an equals sign after the property name.", "class SomeClass extends React.Component { handleInputChange = (val) => { console.log('selectionMade: ', val); } } This is an experimental feature.", "You will need to enable experimental features in Babel to get this to compile.", "Here is a demo with experimental enabled.", "To use experimental features in babel you can install the relevant plugin from here.", "For this specific feature, you need the transform-class-properties plugin: { \"plugins\": [ \"transform-class-properties\" ] } You can read more about the proposal for Class Fields and Static Properties here No, if you want to create bound, instance-specific methods you will have to do that in the constructor.", "However, you can use arrow functions for that, instead of using .bind on a prototype method: class SomeClass extends React.Component { constructor() { super(); this.handleInputChange = (val) => { console.log('selectionMade: ', val, this); }; \u2026 } } There is an proposal which might allow you to omit the constructor() and directly put the assignment in the class scope with the same functionality, but I wouldn't recommend to use that as it's highly experimental.", "Alternatively, you can always use .bind, which allows you to declare the method on the prototype and then bind it to the instance in the constructor.", "This approach has greater flexibility as it allows modifying the method from the outside of your class.", "class SomeClass extends React.Component { constructor() { super(); this.handleInputChange = this.handleInputChange.bind(this); \u2026 } handleInputChange(val) { console.log('selectionMade: ', val, this); } } I know this question has been sufficiently answered, but I just have a small contribution to make (for those who don't want to use the experimental feature).", "Because of the problem of having to bind multiple function binds in the constructor and making it look messy, I came up with a utility method that once bound and called in the constructor, does all the necessary method bindings for you automatically.", "Assume I have this class with the constructor: //src/components/PetEditor.jsx import React from 'react'; class PetEditor extends React.Component { constructor(props){ super(props); this.state = props.currentPet || {tags:[], photoUrls: []}; this.tagInput = null; this.htmlNode = null; this.removeTag = this.removeTag.bind(this); this.handleChange = this.handleChange.bind(this); this.modifyState = this.modifyState.bind(this); this.handleKeyUp = this.handleKeyUp.bind(this); this.addTag = this.addTag.bind(this); this.removeTag = this.removeTag.bind(this); this.savePet = this.savePet.bind(this); this.addPhotoInput = this.addPhotoInput.bind(this); this.handleSelect = this.handleSelect.bind(this); } // ... actual method declarations omitted } It looks messy, doesn't it?", "Now I created this utility method //src/utils/index.js /** * NB: to use this method, you need to bind it to the object instance calling it */ export function bindMethodsToSelf(objClass, otherMethodsToIgnore=[]){ const self = this; Object.getOwnPropertyNames(objClass.prototype) .forEach(method => { //skip constructor, render and any overrides of lifecycle methods if(method.startsWith('component') || method==='constructor' || method==='render') return; //any other methods you don't want bound to self if(otherMethodsToIgnore.indexOf(method)>-1) return; //bind all other methods to class instance self[method] = self[method].bind(self); }); } All I now need to do is import that utility, and add a call to my constructor, and I don't need to bind each new method in the constructor anymore.", "New constructor now looks clean, like this: //src/components/PetEditor.jsx import React from 'react'; import { bindMethodsToSelf } from '../utils'; class PetEditor extends React.Component { constructor(props){ super(props); this.state = props.currentPet || {tags:[], photoUrls: []}; this.tagInput = null; this.htmlNode = null; bindMethodsToSelf.bind(this)(PetEditor); } // ... } You are using arrow function and also binding it in constructor.", "So you no need to do binding when you use arrow functions class SomeClass extends React.Component { handleInputChange = (val) => { console.log('selectionMade: ', val); } } OR you need to bind a function only in constructor when you use normal function like below class SomeClass extends React.Component { constructor(props){ super(props); this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(val){ console.log('selectionMade: ', val); } } Also binding a function directly in render is not recommended.", "It should always be in constructor", "I'm trying to do something like the following in React JSX (where ObjectRow is a separate component): <tbody> for (var i=0; i < numrows; i++) { <ObjectRow/> } </tbody> I realize and understand why this isn't valid JSX, since JSX maps to function calls.", "However, coming from template land and being new to JSX, I am unsure how I would achieve the above (adding a component multiple times).", "Think of it like you're just calling JavaScript functions.", "You can't use a for loop where the arguments to a function call would go: return tbody( for (var i = 0; i < numrows; i++) { ObjectRow() } ) See how the function tbody is being passed a for loop as an argument \u2013 leading to a syntax error.", "But you can make an array, and then pass that in as an argument: var rows = []; for (var i = 0; i < numrows; i++) { rows.push(ObjectRow()); } return tbody(rows); You can basically use the same structure when working with JSX: var rows = []; for (var i = 0; i < numrows; i++) { // note: we are adding a key prop here to allow react to uniquely identify each // element in this array.", "see: https://reactjs.org/docs/lists-and-keys.html rows.push(<ObjectRow key={i} />); } return <tbody>{rows}</tbody>; Incidentally, my JavaScript example is almost exactly what that example of JSX transforms into.", "Play around with Babel REPL to get a feel for how JSX works.", "Not sure if this will work for your situation, but often map is a good answer.", "If this was your code with the for loop: <tbody> for (var i=0; i < objects.length; i++) { <ObjectRow obj={objects[i]} key={i}> } </tbody> You could write it like this with map: <tbody> {objects.map(function(object, i){ return <ObjectRow obj={object} key={i} />; })} </tbody> ES6 syntax: <tbody> {objects.map((object, i) => <ObjectRow obj={object} key={i} />)} </tbody> If you don't already have an array to map() like @FakeRainBrigand's answer, and want to inline this so the source layout corresponds to the output closer than @SophieAlpert's answer: With ES2015 (ES6) syntax (spread and arrow functions) http://plnkr.co/edit/mfqFWODVy8dKQQOkIEGV?p=preview <tbody> {[...Array(10)].map((x, i) => <ObjectRow key={i} /> )} </tbody> Re: transpiling with Babel, its caveats page says that Array.from is required for spread, but at present (v5.8.23) that does not seem to be the case when spreading an actual Array.", "I have a documentation issue open to clarify that.", "But use at your own risk or polyfill.", "Vanilla ES5 Array.apply <tbody> {Array.apply(0, Array(10)).map(function (x, i) { return <ObjectRow key={i} />; })} </tbody> Inline IIFE http://plnkr.co/edit/4kQjdTzd4w69g8Suu2hT?p=preview <tbody> {(function (rows, i, len) { while (++i <= len) { rows.push(<ObjectRow key={i} />) } return rows; })([], 0, 10)} </tbody> Combination of techniques from other answers Keep the source layout corresponding to the output, but make the inlined part more compact: render: function () { var rows = [], i = 0, len = 10; while (++i <= len) rows.push(i); return ( <tbody> {rows.map(function (i) { return <ObjectRow key={i} index={i} />; })} </tbody> ); } With ES2015 syntax & Array methods With Array.prototype.fill you could do this as an alternative to using spread as illustrated above: <tbody> {Array(10).fill(1).map((el, i) => <ObjectRow key={i} /> )} </tbody> (I think you could actually omit any argument to fill(), but I'm not 100% on that.)", "Thanks to @FakeRainBrigand for correcting my mistake in an earlier version of the fill() solution (see revisions).", "key In all cases the key attr alleviates a warning with the development build, but isn't accessible in the child.", "You can pass an extra attr if you want the index available in the child.", "See Lists and Keys for discussion.", "Simply using map Array method with ES6 syntax: <tbody> {items.map(item => <ObjectRow key={item.id} name={item.name} />)} </tbody> Don't forget the key property.", "Using Array map function is a very common way to loop through an Array of elements and create components according to them in React, this is a great way to do a loop which is a pretty efficient and tidy way to do your loops in JSX, It's not the only way to do it, but the preferred way.", "Also, don't forget having a unique Key for each iteration as required.", "Map function creates a unique index from 0 but it's not recommended using the produced index but if your value is unique or if there is a unique key, you can use them: <tbody> {numrows.map(x=> <ObjectRow key={x.id} />)} </tbody> Also, few lines from MDN if you not familiar with map function on Array: map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results.", "callback is invoked only for indexes of the array which have assigned values, including undefined.", "It is not called for missing elements of the array (that is, indexes that have never been set, which have been deleted or which have never been assigned a value).", "callback is invoked with three arguments: the value of the element, the index of the element, and the Array object being traversed.", "If a thisArg parameter is provided to the map, it will be used as callback's this value.", "Otherwise, the value undefined will be used as its this value.", "This value ultimately observable by the callback is determined according to the usual rules for determining the this seen by a function.", "map does not mutate the array on which it is called (although callback, if invoked, may do so).", "If you're already using lodash, the _.times function is handy.", "import React, { Component } from \"react\"; import Select from \"./Select\"; import _ from \"lodash\"; export default class App extends Component { render() { return ( <div className=\"container\"> <ol> {_.times(3, (i) => ( <li key={i}> <Select onSelect={this.onSelect}> <option value=\"1\">bacon</option> <option value=\"2\">cheez</option> </Select> </li> ))} </ol> </div> ); } } You can also extract outside the return block: render: function() { var rows = []; for (var i = 0; i < numrows; i++) { rows.push(<ObjectRow key={i}/>); } return (<tbody>{rows}</tbody>); } I know this is an old thread, but you might want to checkout React Templates, which does let you use jsx-style templates in react, with a few directives (such as rt-repeat).", "Your example, if you used react-templates, would be: <tbody> <ObjectRow rt-repeat=\"obj in objects\"/> </tbody> There are multiple ways to go about doing this.", "JSX eventually gets compiled to JavaScript, so as long as you're writing valid JavaScript, you'll be good.", "My answer aims to consolidate all the wonderful ways already presented here: If you do not have an array of object, simply the number of rows: within the return block, creating an Array and using Array.prototype.map: render() { return ( <tbody> {Array(numrows).fill(null).map((value, index) => ( <ObjectRow key={index}> ))} </tbody> ); } outside the return block, simply use a normal JavaScript for-loop: render() { let rows = []; for (let i = 0; i < numrows; i++) { rows.push(<ObjectRow key={i}/>); } return ( <tbody>{rows}</tbody> ); } immediately invoked function expression: render() { return ( <tbody> {() => { let rows = []; for (let i = 0; i < numrows; i++) { rows.push(<ObjectRow key={i}/>); } return rows; }} </tbody> ); } If you have an array of objects within the return block, .map() each object to a <ObjectRow> component: render() { return ( <tbody> {objectRows.map((row, index) => ( <ObjectRow key={index} data={row} /> ))} </tbody> ); } outside the return block, simply use a normal JavaScript for-loop: render() { let rows = []; for (let i = 0; i < objectRows.length; i++) { rows.push(<ObjectRow key={i} data={objectRows[i]} />); } return ( <tbody>{rows}</tbody> ); } immediately invoked function expression: render() { return ( <tbody> {(() => { const rows = []; for (let i = 0; i < objectRows.length; i++) { rows.push(<ObjectRow key={i} data={objectRows[i]} />); } return rows; })()} </tbody> ); } if numrows is a array, and it's very simple.", "<tbody> {numrows.map(item => <ObjectRow />)} </tbody> Array data type in React is very better, array can back new array, and support filter, reduce etc.", "There are several answers pointing to using the map statement.", "Here is a complete example using an iterator within the FeatureList component to list Feature components based on a JSON data structure called features.", "const FeatureList = ({ features, onClickFeature, onClickLikes }) => ( <div className=\"feature-list\"> {features.map(feature => <Feature key={feature.id} {...feature} onClickFeature={() => onClickFeature(feature.id)} onClickLikes={() => onClickLikes(feature.id)} /> )} </div> ); You can view the complete FeatureList code on GitHub.", "The features fixture is listed here.", "To loop for a number of times and return, you can achieve it with the help of from and map: <tbody> { Array.from(Array(i)).map(() => <ObjectRow />) } </tbody> where i = number of times If you want to assign unique key IDs into the rendered components, you can use React.Children.toArray as proposed in the React documentation React.Children.toArray Returns the children opaque data structure as a flat array with keys assigned to each child.", "Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice this.props.children before passing it down.", "Note: React.Children.toArray() changes keys to preserve the semantics of nested arrays when flattening lists of children.", "That is, toArray prefixes each key in the returned array so that each element\u2019s key is scoped to the input array containing it.", "<tbody> { React.Children.toArray( Array.from(Array(i)).map(() => <ObjectRow />) ) } </tbody> let us say we have an array of items in your state: [{name: \"item1\", id: 1}, {name: \"item2\", id: 2}, {name: \"item3\", id: 3}] <tbody> {this.state.items.map((item) => { <ObjectRow key={item.id} name={item.name} /> })} </tbody> If you opt to convert this inside return( ) of render method, easiest option would be using map( ) method.", "Map your array into JSX syntax using map() function, as shown below (ES6 syntax is used).", "Inside parent component: <tbody> { objectArray.map(object => <ObjectRow key={object.id} object={object.value}>) } </tbody> Please note the key attribute added to your child component.", "If you didn't provide a key attribute, you can see the following warning on your console.", "Warning: Each child in an array or iterator should have a unique \"key\" prop.", "Note: One common mistake people do is using index as key when iterating, using index of the element as a key is an anti-pattern and you can read more about it here.", "In short, if it's NOT a static list never use index as key.", "Now at the ObjectRow component, you can access the object from its properties.", "Inside ObjectRow component const { object } = this.props or const object = this.props.object This should fetch you the object you passed from parent component to the variable object in ObjectRow component.", "Now you can spit out the values in that object according to your purpose.", "References : map() method in Javascript ECMA Script 6 or ES6 An ES2015 / Babel possibility is using a generator function to create an array of JSX: function* jsxLoop(times, callback) { for(var i = 0; i < times; ++i) yield callback(i); } ... <tbody> {[...jsxLoop(numrows, i => <ObjectRow key={i}/> )]} </tbody> ...Or you can also prepare an array of objects and map it to a function to have the desired output.", "I prefer this, because it helps me to maintain the good practice of coding with no logic inside the return of render.", "render() { const mapItem = []; for(let i =0;i<item.length;i++) mapItem.push(i); const singleItem => (item, index) { // item the single item in the array // the index of the item in the array // can implement any logic here return ( <ObjectRow/> ) } return( <tbody>{mapItem.map(singleItem)}</tbody> ) } Simply use .map() to loop through your collection and return <ObjectRow> items with props from each iteration.", "Assuming objects is an array somewhere... <tbody> { objects.map((obj, index) => <ObjectRow obj={ obj } key={ index }/> ) } </tbody> ES2015 Array.from with the map function + key If you have nothing to .map() you can use Array.from() with the map function to repeat elements: <tbody> {Array.from({ length: 5 }, (value, key) => <ObjectRow key={key} />)} </tbody> I use this: gridItems = this.state.applications.map(app => <ApplicationItem key={app.Id} app={app } /> ); PS: never forget the key or you will have a lot of warnings!", "I tend to favor an approach where programming logic happens outside the return value of render.", "This helps keep what is actually rendered easy to grok.", "So I'd probably do something like: import _ from 'lodash'; ... const TableBody = ({ objects }) => { const objectRows = objects.map(obj => <ObjectRow object={obj} />); return <tbody>{objectRows}</tbody>; } Admittedly this is such a small amount of code that inlining it might work fine.", "you can of course solve with a .map as suggested by the other answer.", "If you already use babel, you could think about using jsx-control-statements They require a little of setting, but I think it's worth in terms of readability (especially for non-react developer).", "If you use a linter, there's also eslint-plugin-jsx-control-statements Your JSX code will compile into pure JavaScript code, any tags will be replaced by ReactElement objects.", "In JavaScript, you cannot call a function multiple times to collect their returned variables.", "It is illegal, the only way is to use an array to store the function returned variables.", "Or you can use Array.prototype.map which is available since JavaScript ES5 to handle this situation.", "Maybe we can write other compiler to recreate a new JSX syntax to implement a repeat function just like Angular's ng-repeat.", "This can be done in multple ways.", "As suggested above, before return store all elements in the array Loop inside return Method 1 let container =[]; let arr = [1,2,3] //can be anything array, object arr.forEach((val,index)=>{ container.push(<div key={index}> val </div>) /** * 1.", "All loop generated elements require a key * 2. only one parent element can be placed in Array * e.g.", "container.push(<div key={index}> val </div> <div> this will throw error </div> ) **/ }); return ( <div> <div>any things goes here</div> <div>{container}</div> </div> ) Method 2 return( <div> <div>any things goes here</div> <div> {(()=>{ let container =[]; let arr = [1,2,3] //can be anything array, object arr.forEach((val,index)=>{ container.push(<div key={index}> val </div>) }); return container; })()} </div> </div> ) Here's a simple solution to it.", "var Object_rows = []; for (var i = 0; i < numrows; i++) { Object_rows.push(<ObjectRow />); } <tbody>{Object_rows}</tbody>; No mapping and complex code required.", "You just need to push the rows to the array and return the values to render it.", "Since you are writing Javascript syntax inside JSX code, you need to wrap your Javascript in curly braces.", "row = () => { var rows = []; for (let i = 0; i<numrows; i++) { rows.push(<ObjectRow/>); } return rows; } <tbody> {this.row()} </tbody> You can also use a self-invoking function: return <tbody> {(() => { let row = [] for (var i = 0; i < numrows; i++) { row.push(<ObjectRow key={i} />) } return row })()} </tbody> Here is a sample from React doc:JavaScript Expressions as Children function Item(props) { return <li>{props.message}</li>; } function TodoList() { const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( <ul> {todos.map((message) => <Item key={message} message={message} />)} </ul> ); } as your case, I suggest writing like this: function render() { return ( <tbody> {numrows.map((roe, index) => <ObjectRow key={index} />)} </tbody> ); } Please notice the Key is very important, because React use Key to differ data in array.", "I use it like <tbody> { numrows ?", "( numrows.map(obj => { return <ObjectRow /> }) ) : null } </tbody> You can do something like: let foo = [1,undefined,3] { foo.map(e => !", "!e ?", "<Object /> : null )} Great question.", "What I do when I want to add a certain number of components is use a helper function.", "Define a function that returns JSX: const myExample = () => { let myArray = [] for(let i = 0; i<5;i++) { myArray.push(<MyComponent/>) } return myArray } //... in JSX <tbody> {myExample()} </tbody>", "When a react component state changes, the render method is called.", "Hence for any state change, an action can be performed in the render methods body.", "Is there a particular use case for the setState callback then?", "Yes there is, since setState works in an asynchronous way.", "That means after calling setState the this.state variable is not immediately changed.", "so if you want to perform an action immediately after setting state on a state variable and then return a result, a callback will be useful Consider the example below .... changeTitle: function changeTitle (event) { this.setState({ title: event.target.value }); this.validateTitle(); }, validateTitle: function validateTitle () { if (this.state.title.length === 0) { this.setState({ titleError: \"Title can't be blank\" }); } }, ....", "The above code may not work as expected since the title variable may not have mutated before validation is performed on it.", "Now you may wonder that we can perform the validation in the render() function itself but it would be better and a cleaner way if we can handle this in the changeTitle function itself since that would make your code more organised and understandable In this case callback is useful .... changeTitle: function changeTitle (event) { this.setState({ title: event.target.value }, function() { this.validateTitle(); }); }, validateTitle: function validateTitle () { if (this.state.title.length === 0) { this.setState({ titleError: \"Title can't be blank\" }); } }, .... Another example will be when you want to dispatch and action when the state changed.", "you will want to do it in a callback and not the render() as it will be called everytime rerendering occurs and hence many such scenarios are possible where you will need callback.", "Another case is a API Call A case may arise when you need to make an API call based on a particular state change, if you do that in the render method, it will be called on every render onState change or because some Prop passed down to the Child Component changed.", "In this case you would want to use a setState callback to pass the updated state value to the API call .... changeTitle: function (event) { this.setState({ title: event.target.value }, () => this.APICallFunction()); }, APICallFunction: function () { // Call API with the updated value } .... this.setState({ name:'value' },() => { console.log(this.state.name); }); The 1. usecase which comes into my mind, is an api call, which should't go into the render, because it will run for each state change.", "And the API call should be only performed on special state change, and not on every render.", "changeSearchParams = (params) => { this.setState({ params }, this.performSearch) } performSearch = () => { API.search(this.state.params, (result) => { this.setState({ result }) }); } Hence for any state change, an action can be performed in the render methods body.", "Very bad practice, because the render-method should be pure, it means no actions, state changes, api calls, should be performed, just composite your view and return it.", "Actions should be performed on some events only.", "Render is not an event, but componentDidMount for example.", "Consider setState call this.setState({ counter: this.state.counter + 1 }) IDEA setState may be called in async function So you cannot rely on this.", "If the above call was made inside a async function this will refer to state of component at that point of time but we expected this to refer to property inside state at time setState calling or beginning of async task.", "And as task was async call thus that property may have changed in time being.", "Thus it is unreliable to use this keyword to refer to some property of state thus we use callback function whose arguments are previousState and props which means when async task was done and it was time to update state using setState call prevState will refer to state now when setState has not started yet.", "Ensuring reliability that nextState would not be corrupted.", "Wrong Code: would lead to corruption of data this.setState( {counter:this.state.counter+1} ); Correct Code with setState having call back function: this.setState( (prevState,props)=>{ return {counter:prevState.counter+1}; } ); Thus whenever we need to update our current state to next state based on value possed by property just now and all this is happening in async fashion it is good idea to use setState as callback function.", "I have tried to explain it in codepen here CODE PEN", "What does the ... do in this React (using JSX) code and what is it called?", "<Modal {...this.props} title='Modal heading' animation={false}> That's property spread notation.", "It was added in ES2018 (spread for arrays/iterables was earlier, ES2015), but it's been supported in React projects for a long time via transpilation (as \"JSX spread attributes\" even though you could do it elsewhere, too, not just attributes).", "{...this.props} spreads out the \"own\" enumerable properties in props as discrete properties on the Modal element you're creating.", "For instance, if this.props contained a: 1 and b: 2, then <Modal {...this.props} title='Modal heading' animation={false}> would be the same as <Modal a={this.props.a} b={this.props.b} title='Modal heading' animation={false}> But it's dynamic, so whatever \"own\" properties are in props are included.", "Since children is an \"own\" property in props, spread will include it.", "So if the component where this appears had child elements, they'll be passed on to Modal.", "Putting child elements between the opening tag and closing tags is just syntactic sugar \u2014 the good kind \u2014 for putting a children property in the opening tag.", "Example: class Example extends React.Component { render() { const { className, children } = this.props; return ( <div className={className}> {children} </div> ); } } ReactDOM.render( [ <Example className=\"first\"> <span>Child in first</span> </Example>, <Example className=\"second\" children={<span>Child in second</span>} /> ], document.getElementById(\"root\") ); .first { color: green; } .second { color: blue; } <div id=\"root\"></div> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.6.3/umd/react.production.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.6.3/umd/react-dom.production.min.js\"></script> Spread notation is handy not only for that use case, but for creating a new object with most (or all) of the properties of an existing object \u2014 which comes up a lot when you're updating state, since you can't modify state directly: this.setState(prevState => { return {foo: {...prevState.foo, a: \"updated\"}}; }); That replaces this.state.foo with a new object with all the same properties as foo except the a property, which becomes \"updated\": const obj = { foo: { a: 1, b: 2, c: 3 } }; console.log(\"original\", obj.foo); // Creates a NEW object and assigns it to `obj.foo` obj.foo = {...obj.foo, a: \"updated\"}; console.log(\"updated\", obj.foo); .as-console-wrapper { max-height: 100% !important; } As you know ... are called Spread Attributes which the name represents it allows an expression to be expanded.", "var parts = ['two', 'three']; var numbers = ['one', ...parts, 'four', 'five']; // [\"one\", \"two\", \"three\", \"four\", \"five\"] And in this case(I'm gonna simplify it).", "//just assume we have an object like this: var person= { name: 'Alex', age: 35 } This: <Modal {...person} title='Modal heading' animation={false} /> is equal to <Modal name={person.name} age={person.age} title='Modal heading' animation={false} /> So in short, it's a neat short-cut, we can say.", "The three dots represent the Spread Operator in ES6.", "It allows us to do quite a few things in Javascript: Concatenate arrays var shooterGames = ['Call of Duty', 'Far Cry', 'Resident Evil']; var racingGames = ['Need For Speed', 'Gran Turismo', 'Burnout']; var games = [...shooterGames, ...racingGames]; console.log(games) // ['Call of Duty', 'Far Cry', 'Resident Evil', 'Need For Speed', 'Gran Turismo', 'Burnout'] Destructuring an array var shooterGames = ['Call of Duty', 'Far Cry', 'Resident Evil']; var [first, ...remaining] = shooterGames; console.log(first); //Call of Duty console.log(remaining); //['Far Cry', 'Resident Evil'] Combining two objects var myCrush = { firstname: 'Selena', middlename: 'Marie' }; var lastname = 'my last name'; var myWife = { ...myCrush, lastname } console.log(myWife); // {firstname: 'Selena', // middlename: 'Marie', // lastname: 'my last name'} There's another use for the three dots which is known as Rest Parameters and it makes it possible to take all of the arguments to a function in as one array.", "Function arguments as array function fun1(...params) { } The three dots in JavaScript are spread / rest operator.", "Spread operator The spread syntax allows an expression to be expanded in places where multiple arguments are expected.", "myFunction(...iterableObj); [...iterableObj, 4, 5, 6] [...Array(10)] Rest parameters The rest parameter syntax is used for functions with variable number of arguments.", "function(a, b, ...theArgs) { // ... } The spread / rest operator for arrays was introduced in ES6.", "There's a State 2 proposal for object spread / rest properties.", "TypeScript also supports the spread syntax and can transpile that into older versions of ECMAScript with minor issues.", "This is a feature of ES6, which is used in React as well.", "Look at the below example: function Sum(x,y,z) { return x + y + z; } console.log(Sum(1,2,3)); //6 This way is fine if we have a maximum of 3 parameters.", "But, what if we need to add for example 110 parameters.", "Should we define them all and add them one by one?", "Of course there is an easier way to do, which is called SPREAD.", "Instead of passing all those parameters you write : function (...numbers){} We have no idea how many parameters we have, but we know there are heaps of those.", "Based on ES6, we can rewrite the above function as below and use the spread and mapping between them to make it as easy as a piece of cake: let Sum = (...numbers) => { return numbers.reduce((prev, current) => prev + current ); } console.log(Sum(1, 2, 3, 4, 5, 6, 7, 8, 9));//45 It's just defining props in a different way in JSX for you!", "It's using ... array and object operator in ES6 (object one not fully supported yet), so basically if you already define your props, you can pass it to your element this way.", "So in your case, the code should be something like this: function yourA() { const props = {name='Alireza', age='35'}; <Modal {...props} title='Modal heading' animation={false} /> } so the props you defined, now separated and can be reused if necessary.", "It's equal to: function yourA() { <Modal name='Alireza' age='35' title='Modal heading' animation={false} /> } These are the quotes from React team about spread operator in JSX: JSX Spread Attributes If you know all the properties that you want to place on a component ahead of time, it is easy to use JSX: var component = <Component foo={x} bar={y} />; Mutating Props is Bad If you don't know which properties you want to set, you might be tempted to add them onto the object later: var component = <Component />; component.props.foo = x; // bad component.props.bar = y; // also bad This is an anti-pattern because it means that we can't help you check the right propTypes until way later.", "This means that your propTypes errors end up with a cryptic stack trace.", "The props should be considered immutable.", "Mutating the props object somewhere else could cause unexpected consequences so ideally it would be a frozen object at this point.", "Spread Attributes Now you can use a new feature of JSX called spread attributes: var props = {}; props.foo = x; props.bar = y; var component = <Component {...props} />; The properties of the object that you pass in are copied onto the component's props.", "You can use this multiple times or combine it with other attributes.", "The specification order is important.", "Later attributes override previous ones.", "var props = { foo: 'default' }; var component = <Component {...props} foo={'override'} />; console.log(component.props.foo); // 'override' What's with the weird ... notation?", "The ... operator (or spread operator) is already supported for arrays in ES6.", "There is also an ECMAScript proposal for Object Rest and Spread Properties.", "We're taking advantage of these supported and developing standards in order to provide a cleaner syntax in JSX.", "For those who come from the Python world, JSX Spread Attributes are equivalent to Unpacking Argument Lists (the Python **-operator).", "I'm aware this is a JSX question, but working with analogies sometimes helps to get it faster.", "Three dots ... represents Spread Operators or Rest Parameters, It allows an array expression or string or anything which can be iterating to be expanded in places where zero or more arguments for function calls or elements for array are expected.", "Merge two arrays var arr1 = [1,2,3]; var arr2 = [4,5,6]; arr1 = [...arr1, ...arr2]; console.log(arr1); //[1, 2, 3, 4, 5, 6] Copying array: var arr = [1, 2, 3]; var arr2 = [...arr]; console.log(arr); //[1, 2, 3] Note: Spread syntax effectively goes one level deep while copying an array.", "Therefore, it may be unsuitable for copying multidimensional arrays as the following example shows (it's the same with Object.assign() and spread syntax).", "Add values of one array to other at specific index e.g 3: var arr1 = [4,5] var arr2 = [1,2,3,...arr1,6] console.log(arr2); // [1, 2, 3, 4, 5, 6] When calling a constructor with new: var dateFields = [1970, 0, 1]; // 1 Jan 1970 var d = new Date(...dateFields); console.log(d); Spread in object literals: var obj1 = { foo: 'bar', x: 42 }; var obj2 = { foo: 'baz', y: 13 }; var clonedObj = { ...obj1 }; console.log(clonedObj); //{foo: \"bar\", x: 42} var mergedObj = { ...obj1, ...obj2 }; console.log(mergedObj); //{foo: \"baz\", x: 42, y: 13} Note that foo property of obj1 has been overwritten by obj2 foo property As a rest parameter syntax which allows us to represent an indefinite number of arguments as an array: function sum(...theArgs) { return theArgs.reduce((previous, current) => { return previous + current; }); } console.log(sum(1, 2, 3)); //6 console.log(sum(1, 2, 3, 4)); //10 Note:Spread syntax (other than in the case of spread properties) can be applied only to iterable objects: So following will throw error var obj = {'key1': 'value1'}; var array = [...obj]; // TypeError: obj is not iterable Reference1 Reference2 The ...(spread operator) is used in react to: provide a neat way to pass props from parent to child components.", "e.g given these props in a parent component, this.props = { username: \"danM\", email: \"dan@mail.com\" } they could be passed in the following manner to the child, <ChildComponent {...this.props} /> which is similar to this <ChildComponent username={this.props.username} email={this.props.email} /> but way cleaner.", "Kudos to Brandon Morelli.", "He explained perfectly here, but links may die so I am just pasting the content below: The spread syntax is simply three dots: ...", "It allows an iterable to expand in places where 0+ arguments are expected.", "Definitions are tough without context.", "Let's explore some different use cases to help understand what this means.", "Example #1 \u2014 Inserting Arrays Take a look at the code below.", "In this code, we don\u2019t use the spread syntax: var mid = [3, 4]; var arr = [1, 2, mid, 5, 6]; console.log(arr); Above, we\u2019ve created an array named mid.", "We then create a second array which contains our mid array.", "Finally, we log out the result.", "What do you expect arr to print?", "Click run above to see what happens.", "Here is the output: [1, 2, [3, 4], 5, 6] Is that the result you expected?", "By inserting the mid array into the arr array, we\u2019ve ended up with an array within an array.", "That\u2019s fine if that was the goal.", "But what if you want only a single array with the values of 1 through 6?", "To accomplish this, we can use the spread syntax!", "Remember, the spread syntax allows the elements of our array to expand.", "Lets look at the code below.", "Everything is the same \u2014 except we\u2019re now using the spread syntax to insert the mid array into the arr array: var mid = [3, 4]; var arr = [1, 2, ...mid, 5, 6]; console.log(arr); And when you hit the run button, here\u2019s the result: [1, 2, 3, 4, 5, 6] Awesome!", "Remember the spread syntax definition you just read above?", "Here\u2019s where it comes into play.", "As you can see, when we create the arr array and use the spread operator on the mid array, instead of just being inserted, the mid array expands.", "This expansion means that each and every element in the mid array is inserted into the arr array.", "Instead of nested arrays, the result is a single array of numbers ranging from 1 to 6.", "Example #2 \u2014 Math JavaScript has a built in math object that allows us to do some fun math calculations.", "In this example we\u2019ll be looking at Math.max().", "If you\u2019re unfamiliar, Math.max() returns the largest of zero or more numbers.", "Here are a few examples: Math.max(); // -Infinity Math.max(1, 2, 3); // 3 Math.max(100, 3, 4); // 100 As you can see, if you want to find the maximum value of multiple numbers, Math.max() requires multiple parameters.", "You unfortunately can\u2019t simply use a single array as input.", "Before the spread syntax, the easiest way to use Math.max() on an array is to use .apply() var arr = [2, 4, 8, 6, 0]; function max(arr) { return Math.max.apply(null, arr); } console.log(max(arr)); It works, it\u2019s just really annoying.", "Now take a look at how we do the same exact thing with the spread syntax: var arr = [2, 4, 8, 6, 0]; var max = Math.max(...arr); console.log(max); Instead of having to create a function and utilize the apply method to return the result of Math.max() , we only need two lines of code!", "The spread syntax expands our array elements and inputs each element in our array individually into the Math.max() method!", "Example #3 \u2014 Copy an Array In JavaScript, you can\u2019t just copy an array by setting a new variable equal to already existing array.", "Consider the following code example: var arr = ['a', 'b', 'c']; var arr2 = arr; console.log(arr2); When you press run, you\u2019ll get the following output: ['a', 'b', 'c'] Now, at first glance, it looks like it worked \u2014 it looks like we\u2019ve copied the values of arr into arr2.", "But that\u2019s not what has happened.", "You see, when working with objects in javascript (arrays are a type of object) we assign by reference, not by value.", "This means that arr2 has been assigned to the same reference as arr.", "In other words, anything we do to arr2 will also affect the original arr array (and vice versa).", "Take a look below: var arr = ['a', 'b', 'c']; var arr2 = arr; arr2.push('d'); console.log(arr); Above, we\u2019ve pushed a new element d into arr2.", "Yet, when we log out the value of arr, you\u2019ll see that the d value was also added to that array: ['a', 'b', 'c', 'd'] No need to fear though!", "We can use the spread operator!", "Consider the code below.", "It\u2019s almost the same as above.", "Instead though, we\u2019ve used the spread operator within a pair of square brackets: var arr = ['a', 'b', 'c']; var arr2 = [...arr]; console.log(arr2); Hit run, and you\u2019ll see the expected output: ['a', 'b', 'c'] Above, the array values in arr expanded to become individual elements which were then assigned to arr2.", "We can now change the arr2 array as much as we\u2019d like with no consequences on the original arr array: var arr = ['a', 'b', 'c']; var arr2 = [...arr]; arr2.push('d'); console.log(arr); Again, the reason this works is because the value of arr is expanded to fill the brackets of our arr2 array definition.", "Thus, we are setting arr2 to equal the individual values of arr instead of the reference to arr like we did in the first example.", "Bonus Example \u2014 String to Array As a fun final example, you can use the spread syntax to convert a string into an array.", "Simply use the spread syntax within a pair of square brackets: var str = \"hello\"; var chars = [...str]; console.log(chars); The three dots (...) are called the spread operator, and this is conceptually similar to the ES6 array spread operator, JSX taking advantage of these supported and developing standards in order to provide a cleaner syntax in JSX Spread properties in object initializers copies own enumerable properties from a provided object onto the newly created object.", "let n = { x, y, ...z }; n; // { x: 1, y: 2, a: 3, b: 4 } Reference: 1) https://github.com/sebmarkbage/ecmascript-rest-spread#spread-properties 2) https://facebook.github.io/react/docs/jsx-spread.html ... (three dots in Javascript) is called the Spread Syntax or Spread Operator.", "This allows an iterable such as an array expression or string to be expanded or an object expression to be expanded wherever placed.", "This is not specific to React.", "It is a Javascript operator.", "All these answers here are helpful, but I want to list down the mostly used practical Use Cases of the Spread Syntax (Spread Operator).", "1.", "Combine Arrays (Concatenate Arrays) There are a variety of ways to combine arrays, but the spread operator allows you to place this at any place in an array.", "If you'd like to combine two arrays and place elements at any point within the array, you can do as follows: var arr1 = ['two', 'three']; var arr2 = ['one', ...arr1, 'four', 'five']; // arr2 = [\"one\", \"two\", \"three\", \"four\", \"five\"] 2.", "Copying Arrays When we wanted a copy of an array, we used to have the Array.prototypr.slice() method.", "But, you can do the same with the spread operator.", "var arr = [1,2,3]; var arr2 = [...arr]; // arr2 = [1,2,3] 3.", "Calling Functions without Apply In ES5, to pass an array of two numbers to the doStuff() function, you often use the Function.prototype.apply() method as follows: function doStuff (x, y, z) { } var args = [0, 1, 2]; // Call the function, passing args doStuff.apply(null, args); However, by using the spread operator, you can pass an array into the function.", "doStuff(...args); 4.", "Destructuring Arrays You can use destructuring and the rest operator together to extract the information into variables as you'd like them: let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // 1 console.log(y); // 2 console.log(z); // { a: 3, b: 4 } 5.", "Function Arguments as Rest Parameters ES6 also has the three dots ( ...) which is a rest parameter that collects all remaining arguments of a function into an array.", "function f(a, b, ...args) { console.log(args); } f(1,2,3,4,5); // [ 3, 4, 5 ] 6.", "Using Math Functions Any function where spread is used as the argument can be used by functions that can accept any number of arguments.", "let numbers = [9, 4, 7, 1]; Math.min(...numbers); // 1 7.", "Combining Two Objects You can use the spread operator to combine two objects.", "This is an easy and cleaner way to do it.", "var carType = { model: 'Toyota', yom: '1995' }; var carFuel = 'Petrol'; var carData = { ...carType, carFuel } console.log(carData); // { // model: 'Toyota', // yom: '1995', // carFuel = 'Petrol' // } 8.", "Separate a String into Separate Characters You can use the spread operator to spread a string into separate characters.", "let chars = ['A', ...'BC', 'D']; console.log(chars); // [\"A\", \"B\", \"C\", \"D\"] You can think of more ways to use the Spread Operator.", "What I have listed here are the popular use cases of it.", "The meaning of ... depends on where you use it in the code, Used for spreading/copying the array/object - It helps to copy array/object and also add new array values/add new properties to object, which is optional.", "const numbers = [1,2,3]; const newNumbers = [...numbers, 4]; console.log(newNumbers) //prints [1,2,3,4] const person = { name: 'Max' }; const newPerson = {...person, age:28}; console.log(newPerson); //prints {name:'Max', age:28} Used for merging the function arguments into a single array - You can then use array functions on it.", "const filter = (...args) => { return args.filter(el => el ===1); } console.log(filter(1,2,3)); //prints [1] This a spread operator... For example if you have an array first=[1,2,3,4,5] and another second=[6,7,8].", "[...first, ...second] //result is [1,2,3,4,5,6,7,8] The same can also be done with json objects.", "In a short, the three dots ... is a spread operator in ES6(ES2015).", "Spread operator will fetch all the data.", "let a = [1, 2, 3, 4]; let b = [...a, 4, 5, 6]; let c = [7,8,...a]; console.log(b); Will give the result [1,2,3,4,5,6] console.log(c); Will give the result [7,8,1,2,3,4] Spread Attributes used to Pass the multiple Properties in a Simple Way { ... this.props } is Holding the property of this.props Use of the { ... } Spread Operator with below props this.props = { firstName: 'Dan', lastName: 'Abramov', city: 'New York', country: 'USA' } Without { ... } Spread <Child firstName={this.props.firstName} lastName={this.props.lastName} city={this.props.city} country={this.props.country} > With { ... } Spread <Child { ...this.props } /> Dan Abramov's Tweet about Spread operator (Creator of Redux) Is usually called spread operator, it is use to expand wherever is required example const SomeStyle = { margin:10, background:#somehexa } you can use this where ever you requires it more about spread operator Spread syntax.", "... this syntax is part of ES6 and not something which you can use only in React.It can be used in two different ways; as a spread operator OR as a rest parameter.You can find more from this article: https://www.techiediaries.com/react-spread-operator-props-setstate/ what you have mentioned in the question is something like this, let's assume like this, function HelloUser() { return <Hello Name=\"ABC\" City=\"XYZ\" />; } with the use of spread operator you can pass props to the component like this.", "function HelloUser() { const props = {Name: 'ABC', City: 'XYZ'}; return <Hello {...props} />; } It is common practice to pass props around in a React application.", "In doing this we able to apply state changes to the child component regardless of whether it is Pure or Impure (stateless or stateful).", "There are times when the best approach, when passing in props, is to pass in singular properties or an entire object of properties.", "With the support for arrays in ES6 we were given the \"...\" notation and with this we are now able to achieve passing an entire object to a child.", "The typical process of passing props to a child is noted with this syntax: var component = <Component foo={x} bar={y} />; This is fine to use when the number of props is minimal but becomes unmanageable when the prop numbers get too much higher.", "A problem with this method occurs when you do not know the properties needed within a child component and the typical JavaScript method is to simple set those properties and bind to the object later.", "This causes issues with propType checking and cryptic stack trace errors that are not helpful and cause delays in debugging.", "The following is an example of this practice, and what not to do: var component = <Component />; component.props.foo = x; // bad component.props.bar = y; This same result can be achieved but with more appropriate success by doing this: var props = {}; props.foo = x; props.bar = y; var component = Component(props); // Where did my JSX go?", "But does not use JSX spread or JSX so to loop this back into the equation we can now do something like this: var props = {}; props.foo = x; props.bar = y; var component = <Component {...props} />; The properties included in \"...props\" are foo: x, bar: y.", "This can be combined with other attributes to override the properties of \"...props\" using this syntax: var props = { foo: 'default' }; var component = <Component {...props} foo={'override'} />; console.log(component.props.foo); // 'override' In addition we can copy other property objects onto each other or combine them in this manner: var oldObj = { foo: 'hello', bar: 'world' }; var newObj = { ...oldObj, foo: 'hi' }; console.log(newObj.foo); // 'hi'; console.log(newObj.bar); // 'world'; Or merge two different objects like this (this is not yet available in all react versions): var ab = { ...a, ...b }; // merge(a, b) Another way of explaining this, according to Facebook's react/docs site is: If you already have \"props\" as an object, and you want to pass it in JSX, you can use \"...\" as a SPREAD operator to pass the whole props object.", "The following two examples are equivalent: function App1() { return <Greeting firstName=\"Ben\" lastName=\"Hector\" />; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return <Greeting {...props} />; } Spread attributes can be useful when you are building generic containers.", "However, they can also make your code messy by making it easy to pass a lot of irrelevant props to components that don't care about them.", "This syntax should be used sparingly.", "Its called spread operator.", "For eg let hello={name: '',msg:''} let hello1={...hello} Now hello object properties is copied to hello1.", "It is called spreads syntax in javascript.", "It use for destructuring an array or object in javascript.", "example: const objA = { a: 1, b: 2, c: 3 } const objB = { ...objA, d: 1 } /* result of objB will be { a: 1, b: 2, c: 3, d: 1 } */ console.log(objB) const objC = { ....objA, a: 3 } /* result of objC will be { a: 3, b: 2, c: 3, d: 1 } */ console.log(objC) You can do it same result with Object.assign() function in javascript.", "Reference:Spread syntax This will be compiled into: React.createElement(Modal, { ...this.props, title: \"Modal heading\", animation: false }, child0, child1, child2, ...) where it gives more two properties title & animation beyond the props the host element has.", "... is the ES6 operator called Spread.", "See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax spread operator(triple operator) introduce in ecama script 6(ES6).Ecama script(ES6) is a wrapper of javascript.", "spread operator enumerable properties in props.", "this.props = { firstName: 'Dan', lastName: 'Abramov', city: 'New York', country: 'USA' } {...this.props} = { firstName: 'Dan', lastName: 'Abramov', city: 'New York', country: 'USA' } But the main feature spread operator is used for a reference type.", "For example let person= { name: 'Alex', age: 35 } person1= person; person1.name = \"Raheel\"; console.log( person.name); // output: Raheel This is called reference type, one object affects other objects because they are shareable in memory.", "If you getting value independently mean spread memory both use spread operator.", "let person= { name: 'Alex', age: 35 } person2 = {...person}; person2.name = \"Shahzad\"; console.log(person.name); // output: Alex if you have an array of elements and you want to display the elements you just use ...arrayemaments and it will iterate over all the elements const Profile = { firstName: \"kazi\", lastName: \"ahsan\" } const ProfileUpdate = { firstName: \"kazi\", lastName: \"ahsan\" } const newProfile = {...Profile, ...ProfileUpdate} Hope this helps someone.", "These three dots are called spread operator.", "Spread operator helps us to create a copy state or props in react.", "Using spread operator in react state const [myState, setMyState] = useState({ variable1: 'test', variable2: '', variable3: '' }); setMyState({...myState, variable2: 'new value here'}); in the above code spread operator will maintain a copy of current state and we will also add new value at same time, if we don't do this then state will have only value of variable2 spread operator helps us to write optimize code This is a new feature in ES6/Harmony.", "It is called the Spread Operator.", "It lets you either separate the constituent parts of an array/object, or take multiple items/parameters and glue them together.", "Here is an example: let array = [1,2,3] let array2 = [...array] // array2 is now filled with the items from array And with an object/keys: // lets pass an object as props to a react component let myParameters = {myKey: 5, myOtherKey: 7} let component = <MyComponent {...myParameters}/> // this is equal to <MyComponent myKey=5 myOtherKey=7 /> What's really cool is you can use it to mean \"the rest of the values\".", "const myFunc = (value1, value2, ...values) { // Some code } myFunc(1, 2, 3, 4, 5) // when myFunc is called, the rest of the variables are placed into the \"values\" array For someone who wants to understand this simple and fast: First of all, this is not a syntax only to react.", "this is a syntax from ES6 called Spread syntax which iterate(merge, add..etc) array and object.", "read more about here So answer to the question: let's imagine you have this tag: <UserTag name=\"Supun\" age=\"66\" gender=\"male\" /> and You do this: const user = { \"name\"=>\"Joe\", \"age\"=>\"50\" \"test\"=>\"test-val\" }; <UserTag name=\"Supun\" gender=\"male\" {...user} age=\"66\" /> then the tag will equal this: <UserTag name=\"Joe\" gender=\"male\" test=\"test-val\" age=\"66\" /> So what happened was when you use Spread syntax in a react tag it takes tag's attribute as object attributes which merge(replace if it exists) with the given object user.", "also, you might have noticed one thing that it only replaces before attribute, not after attributes.", "so in this example age remains as it is.", "Hopes this helps :) Those are called spreads.", "Just as the name implies.", "It means it's putting whatever the value of it in those array or objects.", "Such as : let a = [1, 2, 3]; let b = [...a, 4, 5, 6]; console.log(b); > [1, 2, 3, 4, 5, 6]", "I'm trying to find the proper way to define some components which could be used in a generic way: <Parent> <Child value=\"1\"> <Child value=\"2\"> </Parent> There is a logic going on for rendering between parent and children components of course, you can imagine <select> and <option> as an example of this logic.", "This is a dummy implementation for the purpose of the question: var Parent = React.createClass({ doSomething: function(value) { }, render: function() { return (<div>{this.props.children}</div>); } }); var Child = React.createClass({ onClick: function() { this.props.doSomething(this.props.value); // doSomething is undefined }, render: function() { return (<div onClick={this.onClick}></div>); } }); The question is whenever you use {this.props.children} to define a wrapper component, how do you pass down some property to all its children?", "Cloning children with new props You can use React.Children to iterate over the children, and then clone each element with new props (shallow merged) using React.cloneElement.", "For example: const Child = ({ doSomething, value }) => ( <button onClick={() => doSomething(value)}>Click Me</button> ); class Parent extends React.Component{ doSomething = value => { console.log(\"doSomething called by child with value:\", value); } render() { const childrenWithProps = React.Children.map(this.props.children, child => { // checking isValidElement is the safe way and avoids a typescript error too const props = { doSomething }; if (React.isValidElement(child)) { return React.cloneElement(child, props); } return child; }); return <div>{childrenWithProps}</div>; } } function App() { return ( <Parent> <Child value={1} /> <Child value={2} /> </Parent> ); } ReactDOM.render(<App />, document.getElementById(\"container\")); Fiddle: https://jsfiddle.net/2q294y43/2/ Calling children as a function Alternatively, you can pass props to children with render props.", "In this approach, the children (which can be children or any other prop name) is a function which can accept any arguments you want to pass and returns the children: const Child = ({ doSomething, value }) => ( <button onClick={() => doSomething(value)}>Click Me</button> ); class Parent extends React.Component{ doSomething = value => { console.log(\"doSomething called by child with value:\", value); } render(){ // note that children is called as a function and we can pass args to it return <div>{this.props.children(doSomething)}</div> } }; function App(){ return ( <Parent> {doSomething => ( <React.Fragment> <Child doSomething={doSomething} value={1} /> <Child doSomething={doSomething} value={2} /> </React.Fragment> )} </Parent> ); } ReactDOM.render(<App />, document.getElementById(\"container\")); Instead of <React.Fragment> or simply <> you can also return an array if you prefer.", "Fiddle: https://jsfiddle.net/ferahl/y5pcua68/7/ For a slightly cleaner way to do it, try: <div> {React.cloneElement(this.props.children, { loggedIn: this.state.loggedIn })} </div> Edit: To use with multiple individual children (the child must itself be a component) you can do.", "Tested in 16.8.6 <div> {React.cloneElement(props.children[0], { loggedIn: true, testingTwo: true })} {React.cloneElement(props.children[1], { loggedIn: true, testProp: false })} </div> Try this <div>{React.cloneElement(this.props.children, {...this.props})}</div> It worked for me using react-15.1.", "Pass props to direct children.", "See all other answers Pass shared, global data through the component tree via context Context is designed to share data that can be considered \u201cglobal\u201d for a tree of React components, such as the current authenticated user, theme, or preferred language.", "1 Disclaimer: This is an updated answer, the previous one used the old context API It is based on Consumer / Provide principle.", "First, create your context const { Provider, Consumer } = React.createContext(defaultValue); Then use via <Provider value={/* some value */}> {children} /* potential consumers */ <Provider /> and <Consumer> {value => /* render something based on the context value */} </Consumer> All Consumers that are descendants of a Provider will re-render whenever the Provider\u2019s value prop changes.", "The propagation from Provider to its descendant Consumers is not subject to the shouldComponentUpdate method, so the Consumer is updated even when an ancestor component bails out of the update.", "1 Full example, semi-pseudo code.", "import React from 'react'; const { Provider, Consumer } = React.createContext({ color: 'white' }); class App extends React.Component { constructor(props) { super(props); this.state = { value: { color: 'black' }, }; } render() { return ( <Provider value={this.state.value}> <Toolbar /> </Provider> ); } } class Toolbar extends React.Component { render() { return ( <div> <p> Consumer can be arbitrary levels deep </p> <Consumer> {value => <p> The toolbar will be in color {value.color} </p>} </Consumer> </div> ); } } 1 https://facebook.github.io/react/docs/context.html Passing Props to Nested Children With the update to React 16.6 you can now use React.createContext and contextType.", "import * as React from 'react'; // React.createContext accepts a defaultValue as the first param const MyContext = React.createContext(); class Parent extends React.Component { doSomething = (value) => { // Do something here with value }; render() { return ( <MyContext.Provider value={{ doSomething: this.doSomething }}> {this.props.children} </MyContext.Provider> ); } } class Child extends React.Component { static contextType = MyContext; onClick = () => { this.context.doSomething(this.props.value); }; render() { return ( <div onClick={this.onClick}>{this.props.value}</div> ); } } // Example of using Parent and Child import * as React from 'react'; class SomeComponent extends React.Component { render() { return ( <Parent> <Child value={1} /> <Child value={2} /> </Parent> ); } } React.createContext shines where React.cloneElement case couldn't handle nested components class SomeComponent extends React.Component { render() { return ( <Parent> <Child value={1} /> <SomeOtherComp><Child value={2} /></SomeOtherComp> </Parent> ); } } You can use React.cloneElement, it's better to know how it works before you start using it in your application.", "It's introduced in React v0.13, read on for more information, so something along with this work for you: <div>{React.cloneElement(this.props.children, {...this.props})}</div> So bring the lines from React documentation for you to understand how it's all working and how you can make use of them: In React v0.13 RC2 we will introduce a new API, similar to React.addons.cloneWithProps, with this signature: React.cloneElement(element, props, ...children); Unlike cloneWithProps, this new function does not have any magic built-in behavior for merging style and className for the same reason we don't have that feature from transferPropsTo.", "Nobody is sure what exactly the complete list of magic things are, which makes it difficult to reason about the code and difficult to reuse when style has a different signature (e.g.", "in the upcoming React Native).", "React.cloneElement is almost equivalent to: <element.type {...element.props} {...props}>{children}</element.type> However, unlike JSX and cloneWithProps, it also preserves refs.", "This means that if you get a child with a ref on it, you won't accidentally steal it from your ancestor.", "You will get the same ref attached to your new element.", "One common pattern is to map over your children and add a new prop.", "There were many issues reported about cloneWithProps losing the ref, making it harder to reason about your code.", "Now following the same pattern with cloneElement will work as expected.", "For example: var newChildren = React.Children.map(this.props.children, function(child) { return React.cloneElement(child, { foo: true }) }); Note: React.cloneElement(child, { ref: 'newRef' }) DOES override the ref so it is still not possible for two parents to have a ref to the same child, unless you use callback-refs.", "This was a critical feature to get into React 0.13 since props are now immutable.", "The upgrade path is often to clone the element, but by doing so you might lose the ref.", "Therefore, we needed a nicer upgrade path here.", "As we were upgrading callsites at Facebook we realized that we needed this method.", "We got the same feedback from the community.", "Therefore we decided to make another RC before the final release to make sure we get this in.", "We plan to eventually deprecate React.addons.cloneWithProps.", "We're not doing it yet, but this is a good opportunity to start thinking about your own uses and consider using React.cloneElement instead.", "We'll be sure to ship a release with deprecation notices before we actually remove it so no immediate action is necessary.", "more here...", "The best way, which allows you to make property transfer is children like a function pattern https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9 Code snippet: https://stackblitz.com/edit/react-fcmubc Example: const Parent = ({ children }) => { const somePropsHere = { style: { color: \"red\" } // any other props here... } return children(somePropsHere) } const ChildComponent = props => <h1 {...props}>Hello world!</h1> const App = () => { return ( <Parent> {props => ( <ChildComponent {...props}> Bla-bla-bla </ChildComponent> )} </Parent> ) } None of the answers address the issue of having children that are NOT React components, such as text strings.", "A workaround could be something like this: // Render method of Parent component render(){ let props = { setAlert : () => {alert(\"It works\")} }; let childrenWithProps = React.Children.map( this.props.children, function(child) { if (React.isValidElement(child)){ return React.cloneElement(child, props); } return child; }); return <div>{childrenWithProps}</div> } I needed to fix accepted answer above to make it work using that instead of this pointer.", "This within the scope of map function didn't have doSomething function defined.", "var Parent = React.createClass({ doSomething: function() { console.log('doSomething!", "'); }, render: function() { var that = this; var childrenWithProps = React.Children.map(this.props.children, function(child) { return React.cloneElement(child, { doSomething: that.doSomething }); }); return <div>{childrenWithProps}</div> }}) Update: this fix is for ECMAScript 5, in ES6 there is no need in var that=this Cleaner way considering one or more children <div> { React.Children.map(this.props.children, child => React.cloneElement(child, {...this.props}))} </div> You no longer need {this.props.children}.", "Now you can wrap your child component using render in Route and pass your props as usual: <BrowserRouter> <div> <ul> <li><Link to=\"/\">Home</Link></li> <li><Link to=\"/posts\">Posts</Link></li> <li><Link to=\"/about\">About</Link></li> </ul> <hr/> <Route path=\"/\" exact component={Home} /> <Route path=\"/posts\" render={() => ( <Posts value1={1} value2={2} data={this.state.data} /> )} /> <Route path=\"/about\" component={About} /> </div> </BrowserRouter> If you have multiple children you want to pass props to, you can do it this way, using the React.Children.map: render() { let updatedChildren = React.Children.map(this.props.children, (child) => { return React.cloneElement(child, { newProp: newProp }); }); return ( <div> { updatedChildren } </div> ); } If your component is having just one child, there's no need for mapping, you can just cloneElement straight away: render() { return ( <div> { React.cloneElement(this.props.children, { newProp: newProp }) } </div> ); } Parent.jsx: import React from 'react'; const doSomething = value => {}; const Parent = props => ( <div> { !props || !props.children ?", "<div>Loading... (required at least one child)</div> : !props.children.length ?", "<props.children.type {...props.children.props} doSomething={doSomething} {...props}>{props.children}</props.children.type> : props.children.map((child, key) => React.cloneElement(child, {...props, key, doSomething})) } </div> ); Child.jsx: import React from 'react'; /* but better import doSomething right here, or use some flux store (for example redux library) */ export default ({ doSomething, value }) => ( <div onClick={() => doSomething(value)}/> ); and main.jsx: import React from 'react'; import { render } from 'react-dom'; import Parent from './Parent'; import Child from './Child'; render( <Parent> <Child/> <Child value='1'/> <Child value='2'/> </Parent>, document.getElementById('...') ); see example here: https://plnkr.co/edit/jJHQECrKRrtKlKYRpIWl?p=preview Maybe you can also find useful this feature, though many people have considered this as an anti-pattern it still can be used if you're know what you're doing and design your solution well.", "Function as Child Components According to the documentation of cloneElement() React.cloneElement( element, [props], [...children] ) Clone and return a new React element using element as the starting point.", "The resulting element will have the original element\u2019s props with the new props merged in shallowly.", "New children will replace existing children.", "key and ref from the original element will be preserved.", "React.cloneElement() is almost equivalent to: <element.type {...element.props} {...props}>{children}</element.type> However, it also preserves refs.", "This means that if you get a child with a ref on it, you won\u2019t accidentally steal it from your ancestor.", "You will get the same ref attached to your new element.", "So cloneElement is what you would use to provide custom props to the children.", "However there can be multiple children in the component and you would need to loop over it.", "What other answers suggest is for you to map over them using React.Children.map.", "However React.Children.map unlike React.cloneElement changes the keys of the Element appending and extra .$ as the prefix.", "Check this question for more details: React.cloneElement inside React.Children.map is causing element keys to change If you wish to avoid it, you should instead go for the forEach function like render() { const newElements = []; React.Children.forEach(this.props.children, child => newElements.push( React.cloneElement( child, {...this.props, ...customProps} ) ) ) return ( <div>{newElements}</div> ) } Method 1 - clone children const Parent = (props) => { const attributeToAddOrReplace= \"Some Value\" const childrenWithAdjustedProps = React.Children.map(props.children, child => React.cloneElement(child, { attributeToAddOrReplace}) ); return <div>{childrenWithAdjustedProps }</div> } Method 2 - use composable context Context allows you to pass a prop to a deep child component without explicitly passing it as a prop through the components in between.", "Context comes with drawbacks: Data doesn't flow in the regular way - via props.", "Using context creates a contract between the consumer and the provider.", "It might be more difficult to understand and replicate the requirements needed to reuse a component.", "Using a composable context export const Context = createContext<any>(null); export const ComposableContext = ({ children, ...otherProps }:{children:ReactNode, [x:string]:any}) => { const context = useContext(Context) return( <Context.Provider {...context} value={{...context, ...otherProps}}>{children}</Context.Provider> ); } function App() { return ( <Provider1> <Provider2> <Displayer /> </Provider2> </Provider1> ); } const Provider1 =({children}:{children:ReactNode}) => ( <ComposableContext greeting=\"Hello\">{children}</ComposableContext> ) const Provider2 =({children}:{children:ReactNode}) => ( <ComposableContext name=\"world\">{children}</ComposableContext> ) const Displayer = () => { const context = useContext(Context); return <div>{context.greeting}, {context.name}</div>; }; Further to @and_rest answer, this is how I clone the children and add a class.", "<div className=\"parent\"> {React.Children.map(this.props.children, child => React.cloneElement(child, {className:'child'}))} </div> I think a render prop is the appropriate way to handle this scenario You let the Parent provide the necessary props used in child component, by refactoring the Parent code to look to something like this: const Parent = ({children}) => { const doSomething(value) => {} return children({ doSomething }) } Then in the child Component you can access the function provided by the parent this way: class Child extends React { onClick() => { this.props.doSomething } render() { return (<div onClick={this.onClick}></div>); } } Now the fianl stucture will look like this: <Parent> {(doSomething) => (<Fragment> <Child value=\"1\" doSomething={doSomething}> <Child value=\"2\" doSomething={doSomething}> <Fragment /> )} </Parent> When using functional components, you will often get the TypeError: Cannot add property myNewProp, object is not extensible error when trying to set new properties on props.children.", "There is a work around to this by cloning the props and then cloning the child itself with the new props.", "const MyParentComponent = (props) => { return ( <div className='whatever'> {props.children.map((child) => { const newProps = { ...child.props } // set new props here on newProps newProps.myNewProp = 'something' const preparedChild = { ...child, props: newProps } return preparedChild })} </div> ) } The slickest way to do this: {React.cloneElement(this.props.children, this.props)} For any one who has a single child element this should do it.", "{React.isValidElement(this.props.children) ?", "React.cloneElement(this.props.children, { ...prop_you_want_to_pass }) : null} Got inspired by all the answers above and this is what I have done.", "I am passing some props like some data, and some components.", "import React from \"react\"; const Parent = ({ children }) => { const { setCheckoutData } = actions.shop; const { Input, FieldError } = libraries.theme.components.forms; const onSubmit = (data) => { setCheckoutData(data); }; const childrenWithProps = React.Children.map( children, (child) => React.cloneElement(child, { Input: Input, FieldError: FieldError, onSubmit: onSubmit, }) ); return <>{childrenWithProps}</>; }; Is this what you required?", "var Parent = React.createClass({ doSomething: function(value) { } render: function() { return <div> <Child doSome={this.doSomething} /> </div> } }) var Child = React.createClass({ onClick:function() { this.props.doSome(value); // doSomething is undefined }, render: function() { return <div onClick={this.onClick}></div> } }) Some reason React.children was not working for me.", "This is what worked for me.", "I wanted to just add a class to the child.", "similar to changing a prop var newChildren = this.props.children.map((child) => { const className = \"MenuTooltip-item \" + child.props.className; return React.cloneElement(child, { className }); }); return <div>{newChildren}</div>; The trick here is the React.cloneElement.", "You can pass any prop in a similar manner Render props is most accurate approach to this problem.", "Instead of passing the child component to parent component as children props, let parent render child component manually.", "Render is built-in props in react, which takes function parameter.", "In this function you can let parent component render whatever you want with custom parameters.", "Basically it does the same thing as child props but it is more customizable.", "class Child extends React.Component { render() { return <div className=\"Child\"> Child <p onClick={this.props.doSomething}>Click me</p> {this.props.a} </div>; } } class Parent extends React.Component { doSomething(){ alert(\"Parent talks\"); } render() { return <div className=\"Parent\"> Parent {this.props.render({ anythingToPassChildren:1, doSomething: this.doSomething})} </div>; } } class Application extends React.Component { render() { return <div> <Parent render={ props => <Child {...props} /> }/> </div>; } } Example at codepen I came to this post while researching for a similar need, but i felt cloning solution that is so popular, to be too raw and takes my focus away from the functionality.", "I found an article in react documents Higher Order Components Here is my sample: import React from 'react'; const withForm = (ViewComponent) => { return (props) => { const myParam = \"Custom param\"; return ( <> <div style={{border:\"2px solid black\", margin:\"10px\"}}> <div>this is poc form</div> <div> <ViewComponent myParam={myParam} {...props}></ViewComponent> </div> </div> </> ) } } export default withForm; const pocQuickView = (props) => { return ( <div style={{border:\"1px solid grey\"}}> <div>this is poc quick view and it is meant to show when mouse hovers over a link</div> </div> ) } export default withForm(pocQuickView); For me i found a flexible solution in implementing the pattern of Higher Order Components.", "Of course it depends on the functionality, but it is good if someone else is looking for a similar requirement, it is much better than being dependent on raw level react code like cloning.", "Other pattern that i actively use is the container pattern.", "do read about it, there are many articles out there."]