["\nI am trying to learn hooks and the useState method has made me confused. I am assigning an initial value to a state in the form of an array. The set method in useState is not working for me even with spread(...) or without spread operator.\nI have made an API on another PC that I am calling and fetching the data which I want to set into the state. \nHere is my code:\nimport React, { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst StateSelector = () => {\n  const initialValue = [\n    {\n      category: \"\",\n      photo: \"\",\n      description: \"\",\n      id: 0,\n      name: \"\",\n      rating: 0\n    }\n  ];\n\n  const [movies, setMovies] = useState(initialValue);\n\n  useEffect(() => {\n    (async function() {\n      try {\n        //const response = await fetch(\n        //`http://192.168.1.164:5000/movies/display`\n        //);\n        //const json = await response.json();\n        //const result = json.data.result;\n        const result = [\n          {\n            category: \"cat1\",\n            description: \"desc1\",\n            id: \"1546514491119\",\n            name: \"randomname2\",\n            photo: null,\n            rating: \"3\"\n          },\n          {\n            category: \"cat2\",\n            description: \"desc1\",\n            id: \"1546837819818\",\n            name: \"randomname1\",\n            rating: \"5\"\n          }\n        ];\n        console.log(result);\n        setMovies(result);\n        console.log(movies);\n      } catch (e) {\n        console.error(e);\n      }\n    })();\n  }, []);\n\n  return <p>hello</p>;\n};\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<StateSelector />, rootElement);\n\nThe setMovies(result) as well as setMovies(...result) is not working. Could use some help here.\nI expect the result variable to be pushed into the movies array.\n \nMuch like setState in Class components created by extending React.Component or React.PureComponent, the state update using the updater provided by useState hook is also asynchronous, and will not be reflected immediately.\nAlso, the main issue here is not just the asynchronous nature but the fact that state values are used by functions based on their current closures, and state updates will reflect in the next re-render by which the existing closures are not affected, but new ones are created. Now in the current state, the values within hooks are obtained by existing closures, and when a re-render happens, the closures are updated based on whether the function is recreated again or not.\nEven if you add a setTimeout the function, though the timeout will run after some time by which the re-render would have happened, the setTimeout will still use the value from its previous closure and not the updated one.\nsetMovies(result);\nconsole.log(movies) // movies here will not be updated\n\nIf you want to perform an action on state update, you need to use the useEffect hook, much like using componentDidUpdate in class components since the setter returned by useState doesn't have a callback pattern\nuseEffect(() => {\n    // action on update of movies\n}, [movies]);\n\nAs far as the syntax to update state is concerned, setMovies(result) will replace the previous movies value in the state with those available from the async request.\nHowever, if you want to merge the response with the previously existing values, you must use the callback syntax of state updation along with the correct use of spread syntax like\nsetMovies(prevMovies => ([...prevMovies, ...result]));\n\n \nAddional details to the previous answer:\nWhile React's setState is asynchronous (both classes and hooks), and it's tempting to use that fact to explain the observed behaviour, it is not the reason why it happens.\nTLDR: The reason is a closure scope around an immutable const value.\n\nSolutions:\n\nread the value in render function (not inside nested functions):\nuseEffect(() => { setMovies(result) }, [])\nconsole.log(movies)\n\nadd the variable into dependencies (and use the react-hooks/exhaustive-deps eslint rule):\nuseEffect(() => { setMovies(result) }, [])\nuseEffect(() => { console.log(movies) }, [movies])\n\nuse a mutable reference (when the above is not possible):\nconst moviesRef = useRef(initialValue)\nuseEffect(() => {\n  moviesRef.current = result\n  console.log(moviesRef.current)\n}, [])\n\n\n\nExplanation why it happens:\nIf async was the only reason, it would be possible to await setState().\nHowerver, both props and state are assumed to be unchanging during 1 render.\n\nTreat this.state as if it were immutable.\n\nWith hooks, this assumption is enhanced by using constant values with the const keyword:\nconst [state, setState] = useState('initial')\n\nThe value might be different between 2 renders, but remains a constant inside the render itself and inside any closures (functions that live longer even after render is finished, e.g. useEffect, event handlers, inside any Promise or  setTimeout).\nConsider following fake, but synchronous, React-like implementation:\n\n\n// sync implementation:\r\n\r\nlet internalState\r\nlet renderAgain\r\n\r\nconst setState = (updateFn) => {\r\n  internalState = updateFn(internalState)\r\n  renderAgain()\r\n}\r\n\r\nconst useState = (defaultState) => {\r\n  if (!internalState) {\r\n    internalState = defaultState\r\n  }\r\n  return [internalState, setState]\r\n}\r\n\r\nconst render = (component, node) => {\r\n  const {html, handleClick} = component()\r\n  node.innerHTML = html\r\n  renderAgain = () => render(component, node)\r\n  return handleClick\r\n}\r\n\r\n// test:\r\n\r\nconst MyComponent = () => {\r\n  const [x, setX] = useState(1)\r\n  console.log('in render:', x) // \u2705\r\n  \r\n  const handleClick = () => {\r\n    setX(current => current + 1)\r\n    console.log('in handler/effect/Promise/setTimeout:', x) // \u274c NOT updated\r\n  }\r\n  \r\n  return {\r\n    html: `<button>${x}</button>`,\r\n    handleClick\r\n  }\r\n}\r\n\r\nconst triggerClick = render(MyComponent, document.getElementById('root'))\r\ntriggerClick()\r\ntriggerClick()\r\ntriggerClick()\n<div id=\"root\"></div>\n\n\n\n \nI just finished a rewrite with useReducer, following @kentcdobs article (ref below) which really gave me a solid result that suffers not one bit from these closure problems. \nsee: https://kentcdodds.com/blog/how-to-use-react-context-effectively\nI condensed his readable boilerplate to my preferred level of DRYness -- reading his sandbox implementation will show you how it actually works.\nEnjoy, I know I am !!\nimport React from 'react'\n\n// ref: https://kentcdodds.com/blog/how-to-use-react-context-effectively\n\nconst ApplicationDispatch = React.createContext()\nconst ApplicationContext = React.createContext()\n\nfunction stateReducer(state, action) {\n  if (state.hasOwnProperty(action.type)) {\n    return { ...state, [action.type]: state[action.type] = action.newValue };\n  }\n  throw new Error(`Unhandled action type: ${action.type}`);\n}\n\nconst initialState = {\n  keyCode: '',\n  testCode: '',\n  testMode: false,\n  phoneNumber: '',\n  resultCode: null,\n  mobileInfo: '',\n  configName: '',\n  appConfig: {},\n};\n\nfunction DispatchProvider({ children }) {\n  const [state, dispatch] = React.useReducer(stateReducer, initialState);\n  return (\n    <ApplicationDispatch.Provider value={dispatch}>\n      <ApplicationContext.Provider value={state}>\n        {children}\n      </ApplicationContext.Provider>\n    </ApplicationDispatch.Provider>\n  )\n}\n\nfunction useDispatchable(stateName) {\n  const context = React.useContext(ApplicationContext);\n  const dispatch = React.useContext(ApplicationDispatch);\n  return [context[stateName], newValue => dispatch({ type: stateName, newValue })];\n}\n\nfunction useKeyCode() { return useDispatchable('keyCode'); }\nfunction useTestCode() { return useDispatchable('testCode'); }\nfunction useTestMode() { return useDispatchable('testMode'); }\nfunction usePhoneNumber() { return useDispatchable('phoneNumber'); }\nfunction useResultCode() { return useDispatchable('resultCode'); }\nfunction useMobileInfo() { return useDispatchable('mobileInfo'); }\nfunction useConfigName() { return useDispatchable('configName'); }\nfunction useAppConfig() { return useDispatchable('appConfig'); }\n\nexport {\n  DispatchProvider,\n  useKeyCode,\n  useTestCode,\n  useTestMode,\n  usePhoneNumber,\n  useResultCode,\n  useMobileInfo,\n  useConfigName,\n  useAppConfig,\n}\n\nwith a usage similar to this:\nimport { useHistory } from \"react-router-dom\";\n\n// https://react-bootstrap.github.io/components/alerts\nimport { Container, Row } from 'react-bootstrap';\n\nimport { useAppConfig, useKeyCode, usePhoneNumber } from '../../ApplicationDispatchProvider';\n\nimport { ControlSet } from '../../components/control-set';\nimport { keypadClass } from '../../utils/style-utils';\nimport { MaskedEntry } from '../../components/masked-entry';\nimport { Messaging } from '../../components/messaging';\nimport { SimpleKeypad, HandleKeyPress, ALT_ID } from '../../components/simple-keypad';\n\nexport const AltIdPage = () => {\n  const history = useHistory();\n  const [keyCode, setKeyCode] = useKeyCode();\n  const [phoneNumber, setPhoneNumber] = usePhoneNumber();\n  const [appConfig, setAppConfig] = useAppConfig();\n\n  const keyPressed = btn => {\n    const maxLen = appConfig.phoneNumberEntry.entryLen;\n    const newValue = HandleKeyPress(btn, phoneNumber).slice(0, maxLen);\n    setPhoneNumber(newValue);\n  }\n\n  const doSubmit = () => {\n    history.push('s');\n  }\n\n  const disableBtns = phoneNumber.length < appConfig.phoneNumberEntry.entryLen;\n\n  return (\n    <Container fluid className=\"text-center\">\n      <Row>\n        <Messaging {...{ msgColors: appConfig.pageColors, msgLines: appConfig.entryMsgs.altIdMsgs }} />\n      </Row>\n      <Row>\n        <MaskedEntry {...{ ...appConfig.phoneNumberEntry, entryColors: appConfig.pageColors, entryLine: phoneNumber }} />\n      </Row>\n      <Row>\n        <SimpleKeypad {...{ keyboardName: ALT_ID, themeName: appConfig.keyTheme, keyPressed, styleClass: keypadClass }} />\n      </Row>\n      <Row>\n        <ControlSet {...{ btnColors: appConfig.buttonColors, disabled: disableBtns, btns: [{ text: 'Submit', click: doSubmit }] }} />\n      </Row>\n    </Container>\n  );\n};\n\nAltIdPage.propTypes = {};\n\nNow everything persists smoothly everywhere across all my pages\nNice!\nThanks Kent!\n \nuseEffect has its own state/lifecycle, it will not update until you pass a function in parameters or effect destroyed.\nobject and array spread or rest will not work inside useEffect.\nReact.useEffect(() => {\n    console.log(\"effect\");\n    (async () => {\n        try {\n            let result = await fetch(\"/query/countries\");\n            const res = await result.json();\n            let result1 = await fetch(\"/query/projects\");\n            const res1 = await result1.json();\n            let result11 = await fetch(\"/query/regions\");\n            const res11 = await result11.json();\n            setData({\n                countries: res,\n                projects: res1,\n                regions: res11\n            });\n        } catch {}\n    })(data)\n}, [setData])\n# or use this\nuseEffect(() => {\n    (async () => {\n        try {\n            await Promise.all([\n                fetch(\"/query/countries\").then((response) => response.json()),\n                fetch(\"/query/projects\").then((response) => response.json()),\n                fetch(\"/query/regions\").then((response) => response.json())\n            ]).then(([country, project, region]) => {\n                // console.log(country, project, region);\n                setData({\n                    countries: country,\n                    projects: project,\n                    regions: region\n                });\n            })\n        } catch {\n            console.log(\"data fetch error\")\n        }\n    })()\n}, [setData]);\n\n \n// replace\nreturn <p>hello</p>;\n// with\nreturn <p>{JSON.stringify(movies)}</p>;\n\nNow you should see, that your code actually does work. What does not work is the console.log(movies). This is because movies points to the old state. If you move your console.log(movies) outside of useEffect, right above the return, you will see the updated movies object.\n", "\nI'm reading Forms section of reactjs documentation and just tried this code to demonstrate onChange usage (JSBIN).\nvar React= require('react');\n\nvar ControlledForm= React.createClass({\n    getInitialState: function() {\n        return {\n            value: \"initial value\"\n        };\n    },\n\n    handleChange: function(event) {\n        console.log(this.state.value);\n        this.setState({value: event.target.value});\n        console.log(this.state.value);\n\n    },\n\n    render: function() {\n        return (\n            <input type=\"text\" value={this.state.value} onChange={this.handleChange}/>\n        );\n    }\n});\n\nReact.render(\n    <ControlledForm/>,\n  document.getElementById('mount')\n);\n\nWhen I update the <input/> value in the browser, the second console.log inside the handleChange callback prints the same value as the first console.log, Why I can't see the result of this.setState({value: event.target.value}) in the scope of handleChange callback?\n \nFrom React's documentation:\n\nsetState() does not immediately mutate this.state but creates a\n  pending state transition. Accessing this.state after calling this\n  method can potentially return the existing value. There is no\n  guarantee of synchronous operation of calls to setState and calls may\n  be batched for performance gains.\n\nIf you want a function to be executed after the state change occurs, pass it in as a callback.\nthis.setState({value: event.target.value}, function () {\n    console.log(this.state.value);\n});\n\n \nAs mentioned in the React documentation, there is no guarantee of setState being fired synchronously, so your console.log may return the state prior to it updating.\nMichael Parker mentions passing a callback within the setState. Another way to handle the logic after state change is via the componentDidUpdate lifecycle method, which is the method recommended in React docs.\n\nGenerally we recommend using componentDidUpdate() for such logic instead.\n\nThis is particularly useful when there may be successive setStates fired, and you would like to fire the same function after every state change. Rather than adding a callback to each setState, you could place the function inside of the componentDidUpdate, with specific logic inside if necessary.\n// example\ncomponentDidUpdate(prevProps, prevState) {\n  if (this.state.value > prevState.value) {\n    this.foo();  \n  }\n}\n\n \nYou could try using ES7 async/await. For instance using your example:\nhandleChange: async function(event) {\n    console.log(this.state.value);\n    await this.setState({value: event.target.value});\n    console.log(this.state.value);\n}\n\n \nWatch out the react lifecycle methods\uff01\n\nhttp://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\nhttps://reactjs.org/docs/react-component.html\n\nI worked for several hours to find out that getDerivedStateFromProps will be called after every setState(). \n\ud83d\ude02\n \nasync-await syntax works perfectly for something like the following...\nchangeStateFunction = () => {\n  // Some Worker..\n\n  this.setState((prevState) => ({\n  year: funcHandleYear(),\n  month: funcHandleMonth()\n}));\n\ngoNextMonth = async () => {\n  await this.changeStateFunction();\n  const history = createBrowserHistory();\n  history.push(`/calendar?year=${this.state.year}&month=${this.state.month}`);\n}\n\ngoPrevMonth = async () => {\n  await this.changeStateFunction();\n  const history = createBrowserHistory();\n  history.push(`/calendar?year=${this.state.year}&month=${this.state.month}`);\n}\n\n \n\nSimply putting - this.setState({data: value}) is asynchronous in\n  nature that means it moves out of the Call Stack and only comes back\n  to the Call Stack unless it is resolved.\n\nPlease read about Event Loop to have a clear picture about Asynchronous nature in JS and why it takes time to update - \n\nhttps://medium.com/front-end-weekly/javascript-event-loop-explained-4cd26af121d4\n\nHence - \n    this.setState({data:value});\n    console.log(this.state.data); // will give undefined or unupdated value\n\nas it takes time to update.\nTo achieve the above process - \n    this.setState({data:value},function () {\n     console.log(this.state.data);\n    });\n\n", "\nWith react-router I can use the Link element to create links which are natively handled by react router. \nI see internally it calls this.context.transitionTo(...).\nI want to do a navigation. Not from a link, but from a dropdown selection (as an example). How can I do this in code? What is this.context? \nI saw the Navigation mixin, but can I do this without mixins?\n \n\nReact Router v5.1.0 with hooks\n\nThere is a new useHistory hook in React Router >5.1.0 if you are using React >16.8.0 and functional components.\nimport { useHistory } from \"react-router-dom\";\n\nfunction HomeButton() {\n  const history = useHistory();\n\n  function handleClick() {\n    history.push(\"/home\");\n  }\n\n  return (\n    <button type=\"button\" onClick={handleClick}>\n      Go home\n    </button>\n  );\n}\n\n\nReact Router v4\n\nWith v4 of React Router, there are three approaches that you can take to programmatic routing within components.\n\nUse the withRouter higher-order component.\nUse composition and render a <Route>\nUse the context.\n\nReact Router is mostly a wrapper around the history library. history handles interaction with the browser's window.history for you with its browser and hash histories. It also provides a memory history which is useful for environments that don't have a global history. This is particularly useful in mobile app development (react-native) and unit testing with Node.\nA history instance has two methods for navigating: push and replace. If you think of the history as an array of visited locations, push will add a new location to the array and replace will replace the current location in the array with the new one. Typically you will want to use the push method when you are navigating.\nIn earlier versions of React Router, you had to create your own history instance, but in v4 the <BrowserRouter>, <HashRouter>, and <MemoryRouter> components will create a browser, hash, and memory instances for you. React Router makes the properties and methods of the history instance associated with your router available through the context, under the router object.\n1. Use the withRouter higher-order component\nThe withRouter higher-order component will inject the history object as a prop of the component. This allows you to access the push and replace methods without having to deal with the context.\nimport { withRouter } from 'react-router-dom'\n// this also works with react-router-native\n\nconst Button = withRouter(({ history }) => (\n  <button\n    type='button'\n    onClick={() => { history.push('/new-location') }}\n  >\n    Click Me!\n  </button>\n))\n\n2. Use composition and render a <Route>\nThe <Route> component isn't just for matching locations. You can render a pathless route and it will always match the current location. The <Route> component passes the same props as withRouter, so you will be able to access the history methods through the history prop.\nimport { Route } from 'react-router-dom'\n\nconst Button = () => (\n  <Route render={({ history}) => (\n    <button\n      type='button'\n      onClick={() => { history.push('/new-location') }}\n    >\n      Click Me!\n    </button>\n  )} />\n)\n\n3. Use the context*\nBut you probably should not\nThe last option is one that you should only use if you feel comfortable working with React's context model (React's Context API is stable as of v16).\nconst Button = (props, context) => (\n  <button\n    type='button'\n    onClick={() => {\n      // context.history.push === history.push\n      context.history.push('/new-location')\n    }}\n  >\n    Click Me!\n  </button>\n)\n\n// you need to specify the context type so that it\n// is available within the component\nButton.contextTypes = {\n  history: React.PropTypes.shape({\n    push: React.PropTypes.func.isRequired\n  })\n}\n\n1 and 2 are the simplest choices to implement, so for most use cases, they are your best bets.\n \n\nReact-Router 5.1.0+ Answer (using hooks and React >16.8)\n\nYou can use the new useHistory hook on Functional Components and Programmatically navigate:\nimport { useHistory } from \"react-router-dom\";\n\nfunction HomeButton() {\n  let history = useHistory();\n  // use history.push('/some/path') here\n};\n\n\nReact-Router 4.0.0+ Answer\n\nIn 4.0 and above, use the history as a prop of your component.\nclass Example extends React.Component {\n   // use `this.props.history.push('/some/path')` here\n};\n\nNOTE: this.props.history does not exist in the case your component was not rendered by <Route>. You should use <Route path=\"...\" component={YourComponent}/> to have this.props.history in YourComponent\n\nReact-Router 3.0.0+ Answer\n\nIn 3.0 and above, use the router as a prop of your component.\nclass Example extends React.Component {\n   // use `this.props.router.push('/some/path')` here\n};\n\n\nReact-Router 2.4.0+ Answer\n\nIn 2.4 and above, use a higher order component to get the router as a prop of your component.\nimport { withRouter } from 'react-router';\n\nclass Example extends React.Component {\n   // use `this.props.router.push('/some/path')` here\n};\n\n// Export the decorated class\nvar DecoratedExample = withRouter(Example);\n\n// PropTypes\nExample.propTypes = {\n  router: React.PropTypes.shape({\n    push: React.PropTypes.func.isRequired\n  }).isRequired\n};\n\n\nReact-Router 2.0.0+ Answer\n\nThis version is backwards compatible with 1.x so there's no need to an Upgrade Guide. Just going through the examples should be good enough.\nThat said, if you wish to switch to the new pattern, there's a browserHistory module inside the router that you can access with\nimport { browserHistory } from 'react-router'\nNow you have access to your browser history, so you can do things like push, replace, etc... Like:\nbrowserHistory.push('/some/path')\nFurther reading:\nHistories and\nNavigation\n\n\nReact-Router 1.x.x Answer\n\nI will not go into upgrading details. You can read about that in the Upgrade Guide\nThe main change about the question here is the change from Navigation mixin to History. Now it's using the browser historyAPI to change route so we will use pushState() from now on.\nHere's an exemple using Mixin:\nvar Example = React.createClass({\n  mixins: [ History ],\n  navigateToHelpPage () {\n    this.history.pushState(null, `/help`);\n  }\n})\n\nNote that this History comes from rackt/history project. Not from React-Router itself.\nIf you don't want to use Mixin for some reason (maybe because of ES6 class), then you can access the history that you get from the router from this.props.history. It will be only accessible for the components rendered by your Router. So, if you want to use it in any child components it needs to be passed down as an attribute via props.\nYou can read more about the new release at their 1.0.x documentation\nHere is a help page specifically about navigating outside your component\nIt recommends grabbing a reference history = createHistory() and calling replaceState on that.\n\nReact-Router 0.13.x Answer\n\nI got into the same problem and could only find the solution with the Navigation mixin that comes with react-router.\nHere's how I did it\nimport React from 'react';\nimport {Navigation} from 'react-router';\n\nlet Authentication = React.createClass({\n  mixins: [Navigation],\n\n  handleClick(e) {\n    e.preventDefault();\n\n    this.transitionTo('/');\n  },\n\n  render(){\n    return (<div onClick={this.handleClick}>Click me!</div>);\n  }\n});\n\nI was able to call transitionTo() without the need to access .context\nOr you could try the fancy ES6 class\nimport React from 'react';\n\nexport default class Authentication extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick(e) {\n    e.preventDefault();\n\n    this.context.router.transitionTo('/');\n  }\n\n  render(){\n    return (<div onClick={this.handleClick}>Click me!</div>);\n  }\n}\n\nAuthentication.contextTypes = {\n  router: React.PropTypes.func.isRequired\n};\n\n\nReact-Router-Redux\nNote: if you're using Redux, there is another project called\n  React-Router-Redux that gives you\n  redux bindings for ReactRouter, using somewhat the same approach that\n  React-Redux does\n\nReact-Router-Redux has a few methods available that allow for simple navigating from inside action creators. These can be particularly useful for people that have existing architecture in React Native, and they wish to utilize the same patterns in React Web with minimal boilerplate overhead.\nExplore the following methods:\n\npush(location)\nreplace(location)\ngo(number)\ngoBack()\ngoForward()\n\nHere is an example usage, with Redux-Thunk:\n./actioncreators.js\nimport { goBack } from 'react-router-redux'\n\nexport const onBackPress = () => (dispatch) => dispatch(goBack())\n\n./viewcomponent.js\n<button\n  disabled={submitting}\n  className=\"cancel_button\"\n  onClick={(e) => {\n    e.preventDefault()\n    this.props.onBackPress()\n  }}\n>\n  CANCEL\n</button>\n\n \n\nReact-Router v2\n\nFor the most recent release (v2.0.0-rc5), the recommended navigation method is by directly pushing onto the history singleton. You can see that in action in the Navigating outside of Components doc. \nRelevant excerpt:\nimport { browserHistory } from 'react-router';\nbrowserHistory.push('/some/path');\n\nIf using the newer react-router API, you need to make use of the history from this.props when inside of components so:\nthis.props.history.push('/some/path');\n\nIt also offers pushState but that is deprecated per logged warnings.\nIf using react-router-redux, it offers a push function you can dispatch like so:\nimport { push } from 'react-router-redux';\nthis.props.dispatch(push('/some/path'));\n\nHowever this may be only used to change the URL, not to actually navigate to the page.\n \nHere's how you do this with react-router v2.0.0 with ES6. react-router has moved away from mixins.\nimport React from 'react';\n\nexport default class MyComponent extends React.Component {\n  navigateToPage = () => {\n    this.context.router.push('/my-route')\n  };\n\n  render() {\n    return (\n      <button onClick={this.navigateToPage}>Go!</button>\n    );\n  }\n}\n\nMyComponent.contextTypes = {\n  router: React.PropTypes.object.isRequired\n}\n\n \n\nReact-Router 4.x Answer :\n\nOn my end, I like to have a single history object that I can carry even outside components. What I like to do is to have a single history.js file that I import on demand, and just manipulate it.\nYou just have to change BrowserRouter to Router, and specify the history prop. This doesn't change anything for you except that you have your own history object that you can manipulate as you want.\nYou need to install history, the library used by react-router.\nExample usage, ES6 notation :\nhistory.js\nimport createBrowserHistory from 'history/createBrowserHistory'\nexport default createBrowserHistory()\n\nBasicComponent.js\nimport React, { Component } from 'react';\nimport history from './history';\n\nclass BasicComponent extends Component {\n\n    goToIndex(e){\n        e.preventDefault();\n        history.push('/');\n    }\n\n    render(){\n        return <a href=\"#\" onClick={this.goToIndex}>Previous</a>;\n    }\n}\n\n\nEDIT April 16th, 2018 :\n\nIf you have to navigate from a component that is actually rendered from a Route component, you can also access history from props, like that :\nBasicComponent.js\nimport React, { Component } from 'react';\n\nclass BasicComponent extends Component {\n\n    navigate(e){\n        e.preventDefault();\n        this.props.history.push('/url');\n    }\n\n    render(){\n        return <a href=\"#\" onClick={this.navigate}>Previous</a>;\n    }\n}\n\n \nFor this one, who does not control the server side and because of this is using hash router v2:\nPlace your history into separate file (e.g. app_history.js ES6):\nimport { useRouterHistory } from 'react-router'\nimport { createHashHistory } from 'history'\nconst appHistory = useRouterHistory(createHashHistory)({ queryKey: false });\n\nexport default appHistory;\n\nAnd use it everywhere!\nYour entry point for react-router (app.js ES6):\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Router, Route, Redirect } from 'react-router'\nimport appHistory from './app_history'\n...\nconst render((\n  <Router history={appHistory}>\n  ...\n  </Router>\n), document.querySelector('[data-role=\"app\"]'));\n\nYour navigation inside any component (ES6):\nimport appHistory from '../app_history'\n...\najaxLogin('/login', (err, data) => {\n  if (err) {\n    console.error(err); // login failed\n  } else {\n    // logged in\n    appHistory.replace('/dashboard'); // or .push() if you don't need .replace()\n  }\n})\n\n \nEDIT: React Router v6\nI haven't touched React in a while, but want to thank and highlight the comment below by @Shimrit Snapir\n\non React-Router 6.0 <Redirect /> changed to <Navigate />\n\nReact Router V4\ntl:dr;\nif (navigate) {\n  return <Redirect to=\"/\" push={true} />\n}\n\nThe simple and declarative answer is that you need to use <Redirect to={URL} push={boolean} /> in combination with setState()\n\npush: boolean - when true, redirecting will push a new entry onto the history instead of replacing the current one.\n\n\nimport { Redirect } from 'react-router'\n\nclass FooBar extends React.Component {\n  state = {\n    navigate: false\n  }\n\n  render() {\n    const { navigate } = this.state\n    \n    // here is the important part\n    if (navigate) {\n      return <Redirect to=\"/\" push={true} />\n    }\n   // ^^^^^^^^^^^^^^^^^^^^^^^\n    \n    return (\n      <div>\n        <button onClick={() => this.setState({ navigate: true })}>\n          Home\n        </button>\n      </div>\n    )\n  }\n}\n\nFull example here.\nRead more here.\nPS. The example uses ES7+ Property Initializers to initialise state. Look here as well, if you're interested.\n \n\nWarning: this answer covers only ReactRouter versions before 1.0\nI will update this answer with 1.0.0-rc1 use cases after!\n\nYou can do this without mixins too.\nlet Authentication = React.createClass({\n  contextTypes: {\n    router: React.PropTypes.func\n  },\n  handleClick(e) {\n    e.preventDefault();\n    this.context.router.transitionTo('/');\n  },\n  render(){\n    return (<div onClick={this.handleClick}>Click me!</div>);\n  }\n});\n\nThe gotcha with contexts is that it is not accessible unless you define the contextTypes on the class.\nAs for what is context, it is an object, like props, that are passed down from parent to child, but it is passed down implicitly, without having to redeclare props each time. See https://www.tildedave.com/2014/11/15/introduction-to-contexts-in-react-js.html\n \nI tried at least 10 ways of doing this before something worked right!\n@Felipe Skinner's withRouter answer was a bit overwhelming to me, and I wasn't sure I wanted to make new \"ExportedWithRouter\" class names.\nHere's the simplest and cleanest way to do it, circa current React-Router 3.0.0 and ES6:\n\nReact-Router 3.x.x with ES6:\n\nimport { withRouter } from 'react-router';\n\nclass Example extends React.Component {\n   // use `this.props.router.push('/some/path')` here\n};\n\n// Export the decorated class\nexport default withRouter(Example);\n\nor, if it's not your default class, export like:\nwithRouter(Example);\nexport { Example };\n\nNote that in 3.x.x, the <Link> component itself is using router.push, so you can pass it anything you would pass the <Link to= tag, like:\n   this.props.router.push({pathname: '/some/path', query: {key1: 'val1', key2: 'val2'})'\n\n \nTo do the navigation programmatically, you need to push a new history to the props.history in your component, so something like this can do the work for you:\n//using ES6\nimport React from 'react';\n\nclass App extends React.Component {\n\n  constructor(props) {\n    super(props)\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleClick(e) {\n    e.preventDefault()\n    /* Look at here, you can add it here */\n    this.props.history.push('/redirected');\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick}>\n          Redirect!!!\n        </button>\n      </div>\n    )\n  }\n}\n\nexport default App;\n\n \nMay not be the best approach but... Using react-router v4, the following Typescript could give an idea for some. \nIn the rendered component below, e.g. LoginPage, router object is accessible and just call router.transitionTo('/homepage') to navigate.\nNavigation code was taken from.   \n\"react-router\": \"^4.0.0-2\",\n\"react\": \"^15.3.1\",\n\n\nimport Router from 'react-router/BrowserRouter';\r\nimport { History } from 'react-history/BrowserHistory';\r\nimport createHistory from 'history/createBrowserHistory';\r\nconst history = createHistory();\r\n\r\ninterface MatchWithPropsInterface {\r\n  component: typeof React.Component,\r\n  router: Router,\r\n  history: History,\r\n  exactly?: any,\r\n  pattern: string\r\n}\r\n\r\nclass MatchWithProps extends React.Component<MatchWithPropsInterface,any> {\r\n  render() {\r\n    return(\r\n      <Match {...this.props} render={(matchProps) => (\r\n             React.createElement(this.props.component, this.props)\r\n\r\n        )}\r\n       />\r\n    )\r\n  }\r\n}\r\n\r\nReactDOM.render(\r\n    <Router>\r\n      {({ router }) => (\r\n        <div>\r\n          <MatchWithProps exactly pattern=\"/\" component={LoginPage} router={router} history={history} />\r\n          <MatchWithProps pattern=\"/login\" component={LoginPage} router={router} history={history} />\r\n          <MatchWithProps pattern=\"/homepage\" component={HomePage} router={router} history={history} />\r\n          <Miss component={NotFoundView} />\r\n        </div>\r\n      )}\r\n    </Router>,\r\n\r\n   document.getElementById('app')\r\n);\n\n\n\n \nFor ES6 + React components, the following solution worked for me.\nI followed Felippe skinner, but added an end to end solution to help beginners like me.\nBelow are the versions I used:\n\n\"react-router\": \"^2.7.0\"\n\"react\": \"^15.3.1\"\n\nBelow is my react component where I used programmatic navigation using react-router:\nimport React from 'react';\n\nclass loginComp extends React.Component {\n   constructor( context) {\n    super(context);\n    this.state = {\n      uname: '',\n      pwd: ''\n    };\n  }\n\n  redirectToMainPage(){\n        this.context.router.replace('/home');\n  }\n\n  render(){\n    return <div>\n           // skipping html code \n             <button onClick={this.redirectToMainPage.bind(this)}>Redirect</button>\n    </div>;\n  }\n};\n\n loginComp.contextTypes = {\n    router: React.PropTypes.object.isRequired\n }\n\n module.exports = loginComp;\n\nBelow is the configuration for my router:\n import { Router, Route, IndexRedirect, browserHistory } from 'react-router'\n\n render(<Router history={browserHistory}>\n          <Route path='/' component={ParentComp}>\n            <IndexRedirect to = \"/login\"/>\n            <Route path='/login' component={LoginComp}/>\n            <Route path='/home' component={HomeComp}/>\n            <Route path='/repair' component={RepairJobComp} />\n            <Route path='/service' component={ServiceJobComp} />\n          </Route>\n        </Router>, document.getElementById('root'));\n\n \n\nIn React-Router v4 and ES6\n\nYou can use withRouter and this.props.history.push.\nimport {withRouter} from 'react-router-dom';\n\nclass Home extends Component {\n\n    componentDidMount() {\n        this.props.history.push('/redirect-to');\n    }\n}\n\nexport default withRouter(Home);\n\n \nTo use withRouter with a class-based component, try something like this below.\nDon't forget to change the export statement to use withRouter:\nimport { withRouter } from 'react-router-dom'\nclass YourClass extends React.Component {\n  yourFunction = () => {\n    doSomeAsyncAction(() =>\n      this.props.history.push('/other_location')\n    )\n  }\n\n  render() {\n    return (\n      <div>\n        <Form onSubmit={ this.yourFunction } />\n      </div>\n    )\n  }\n}\n\nexport default withRouter(YourClass);\n\n \nwith React-Router v4 on the horizon, there is now a new way of doing this.\nimport { MemoryRouter, BrowserRouter } from 'react-router';\n\nconst navigator = global && global.navigator && global.navigator.userAgent;\nconst hasWindow = typeof window !== 'undefined';\nconst isBrowser = typeof navigator !== 'undefined' && navigator.indexOf('Node.js') === -1;\nconst Router = isBrowser ? BrowserRouter : MemoryRouter;\n\n<Router location=\"/page-to-go-to\"/>\n\nreact-lego is an example app that shows how to use/update react-router and it includes example functional tests which navigate the app.\n \nbased on the previous answer\nfrom Jos\u00c3\u00a9 Antonio Postigo and Ben Wheeler\nthe novelty? is to be written in Typescript\nand the use of decorators\nOR static property/field  \nimport * as React from \"react\";\nimport Component = React.Component;\nimport { withRouter } from \"react-router\";\n\nexport interface INavigatorProps {\n    router?: ReactRouter.History.History;\n}\n\n/**\n * Note: goes great with mobx \n * @inject(\"something\") @withRouter @observer\n */\n@withRouter\nexport class Navigator extends Component<INavigatorProps, {}>{\n    navigate: (to: string) => void;\n    constructor(props: INavigatorProps) {\n        super(props);\n        let self = this;\n        this.navigate = (to) => self.props.router.push(to);\n    }\n    render() {\n        return (\n            <ul>\n                <li onClick={() => this.navigate(\"/home\")}>\n                    Home\n                </li>\n                <li onClick={() => this.navigate(\"/about\")}>\n                    About\n                </li>\n            </ul>\n        )\n    }\n}\n\n/**\n * Non decorated \n */\nexport class Navigator2 extends Component<INavigatorProps, {}> {\n\n    static contextTypes = {\n        router: React.PropTypes.object.isRequired,\n    };\n\n    navigate: (to: string) => void;\n    constructor(props: INavigatorProps, context: any) {\n        super(props, context);\n        let s = this;\n        this.navigate = (to) =>\n            s.context.router.push(to);\n    }\n    render() {\n        return (\n            <ul>\n                <li onClick={() => this.navigate(\"/home\")}>\n                    Home\n                </li>\n                <li onClick={() => this.navigate(\"/about\")}>\n                    About\n                </li>\n            </ul>\n        )\n    }\n}\n\nwith whatever npm installed today.\n\"react-router\": \"^3.0.0\" and\n\"@types/react-router\": \"^2.0.41\"\n \nIn react router v4. I follow this two way to route programmatically.\n1. this.props.history.push(\"/something/something\")\n2. this.props.history.replace(\"/something/something\")\n\nNumber two \n\nReplaces the current entry on the history stack\n\nTo get history in props you may have to wrap your component with \n\nwithRouter \n\n \nIf you are using hash or browser history then you can do\nhashHistory.push('/login');\nbrowserHistory.push('/login');\n\n \nWith the current React version (15.3), this.props.history.push('/location'); worked for me, but it showed the following warning:\n\nbrowser.js:49 Warning: [react-router] props.history and\n  context.history are deprecated. Please use context.router.\n\nand I solved it using context.router like this:\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.backPressed = this.backPressed.bind(this);\n    }\n\n    backPressed() {\n        this.context.router.push('/back-location');\n    }\n\n    ...\n}\n\nMyComponent.contextTypes = {\n    router: React.PropTypes.object.isRequired\n};\n\nexport default MyComponent;\n\n \nReact-Router V4\nif you're using version 4 then you can use my library (Shameless plug) where you simply dispatch an action and everything just works!\ndispatch(navigateTo(\"/aboutUs\"));\n\ntrippler\n \nThose who are facing issues in implementing this on react-router v4.\nHere is a working solution for navigating through the react app from redux actions.\nhistory.js\nimport createHistory from 'history/createBrowserHistory'\n\nexport default createHistory()\n\nApp.js/Route.jsx\nimport { Router, Route } from 'react-router-dom'\nimport history from './history'\n...\n<Router history={history}>\n <Route path=\"/test\" component={Test}/>\n</Router>\n\nanother_file.js OR redux file\nimport history from './history' \n\nhistory.push('/test') // this should change the url and re-render Test component\n\nAll thanks to this comment:\nReactTraining issues comment\n \nYou can also use the useHistory hook in a stateless component. Example from the docs.\nimport { useHistory } from \"react-router\"\n\nfunction HomeButton() {\n  const history = useHistory()\n\n  return (\n    <button type=\"button\" onClick={() => history.push(\"/home\")}>\n      Go home\n    </button>\n  )\n}\n\n\nNote: Hooks were added in react-router@5.1.0 and require react@>=16.8\n\n \nThe right answer was for me at the time of writing\nthis.context.router.history.push('/');\n\nBut you need to add PropTypes to your component\nHeader.contextTypes = {\n  router: PropTypes.object.isRequired\n}\nexport default Header;\n\nDon't forget to import PropTypes\nimport PropTypes from 'prop-types';\n\n \nMaybe not the best solution but it gets the job done:\nimport { Link } from 'react-router-dom';\n\n// create functional component Post\nexport default Post = () => (\n    <div className=\"component post\">\n\n        <button className=\"button delete-post\" onClick={() => {\n            // ... delete post\n            // then redirect, without page reload, by triggering a hidden Link\n            document.querySelector('.trigger.go-home').click();\n        }}>Delete Post</button>\n\n        <Link to=\"/\" className=\"trigger go-home hidden\"></Link>\n\n    </div>\n);\n\nBasically, a logic tied to one action (in this case a post deletion) will end up calling a trigger for redirect. This is not ideal because you will add a DOM node 'trigger' to your markup just so you can conveniently call it when needed. Also, you will directly interact with the DOM, which in a React component may not be desired.\nStill, this type of redirect is not required that often. So one or two extra, hidden links in your component markup would not hurt that much, especially if you give them meaningful names.\n \nIf happen to pair RR4 w/ redux through react-router-redux, use the routing action creators from react-router-redux is a option as well.\nimport { push, replace, ... } from 'react-router-redux'\n\nclass WrappedComponent extends React.Component {\n  handleRedirect(url, replaceState = true) { \n    replaceState \n      ? this.props.dispatch(replace(url)) \n      : this.props.dispatch(push(url)) \n  }\n  render() { ... }\n}\n\nexport default connect(null)(WrappedComponent)\n\nIf use redux thunk/saga to manage async flow, import the above action creators in redux actions and hook to react components using mapDispatchToProps might be better.\n \nUpdate : React Router v6 with hooks\nimport {useNavigate} from 'react-router-dom';\nlet navigate = useNavigate();\nnavigate('home');\n\nAnd to move across the browser history, \nnavigate(-1); ---> Go back\nnavigate(1);  ---> Go forward\nnavigate(-2); ---> Move two steps backward.\n\n \nThis worked for me, no special imports needed:\n<input \n  type=\"button\" \n  name=\"back\" \n  id=\"back\" \n  class=\"btn btn-primary\" \n  value=\"Back\" \n  onClick={() => { this.props.history.goBack() }} \n/>\n\n \nTry hookrouter instead, \"the modern alternative to react-router\"\nhttps://www.npmjs.com/package/hookrouter\nimport { useRoutes, usePath, A} from \"hookrouter\";\n\nto answer OP question about linking through select box you can do it:\nnavigate('/about');\n\n*** UPDATED ANSWER ***\nI think hook-router was a good starter kit and helped me learn about routing but have since updated to react-router for it's history and query parameter handling.\nimport { useLocation, useHistory } from 'react-router-dom';\n\n\nconst Component = (props) => {\n    const history = useHistory();\n    \n    // Programmatically navigate\n    history.push(newUrlString);\n}\n\nYou push where you want to navigate into the location.history.\n \n\nFor React Router v4+\n\nAssuming that you won't be needing to navigate during the initial render itself (for which you can use <Redirect> component), this is what we are doing in our app.\nDefine an empty route which returns null, this will allow you to get the access to the history object. You need to do this at the top level where your Router is defined.\nNow you can do all the things that can be done on history like history.push(), history.replace(), history.go(-1) etc!\nimport React from 'react';\nimport { HashRouter, Route } from 'react-router-dom';\n\nlet routeHistory = null;\n\nexport function navigateTo(path) {\n  if(routeHistory !== null) {\n    routeHistory.push(path);\n  }\n}\n\nexport default function App(props) {\n  return (\n    <HashRouter hashType=\"noslash\">\n      <Route\n        render={({ history }) => {\n          routeHistory = history;\n          return null;\n        }}\n      />\n      {/* Rest of the App */}\n    </HashRouter>\n  );\n}\n\n \nreact-router-dom: 5.1.2 \n\nThis site has 3 pages, all of which are rendered  dynamically in the browser. \nAlthough the page does not ever refresh, notice how  React Router\nkeeps the URL up to date as you navigate  through the site. This\npreserves the browser history,  making sure things like the back\nbutton and bookmarks work properly \nA Switch looks through all its children \n      elements and renders the first one whose path\n      matches the current URL. Use a  any time\n      you have multiple routes, but you want only one\n      of them to render at a time\n\nimport React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\";\n\n\n\nexport default function BasicExample() {\n  return (\n    <Router>\n      <div>\n        <ul>\n          <li>\n            <Link to=\"/\">Home</Link>\n          </li>\n          <li>\n            <Link to=\"/about\">About</Link>\n          </li>\n          <li>\n            <Link to=\"/dashboard\">Dashboard</Link>\n          </li>\n        </ul>\n\n        <hr />\n\n        <Switch>\n          <Route exact path=\"/\">\n            <Home />\n          </Route>\n          <Route path=\"/about\">\n            <About />\n          </Route>\n          <Route path=\"/dashboard\">\n            <Dashboard />\n          </Route>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\n// You can think of these components as \"pages\"\n// in your app.\n\nfunction Home() {\n  return (\n    <div>\n      <h2>Home</h2>\n    </div>\n  );\n}\n\nfunction About() {\n  return (\n    <div>\n      <h2>About</h2>\n    </div>\n  );\n}\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h2>Dashboard</h2>\n    </div>\n  );\n}```\n\n", "\nI'm using React-router and it works fine while I'm clicking on link buttons, but when I refresh my webpage it does not load what I want.\nFor instance, I am in localhost/joblist and everything is fine because I arrived here pressing a link. But If I refresh the webpage I get:\nCannot GET /joblist\n\nBy default, it didn't work like this. Initially I had my URL as localhost/#/ and localhost/#/joblist and they worked perfectly fine. But I don't like this kind of URL, so trying to erase that #, I wrote:\nRouter.run(routes, Router.HistoryLocation, function (Handler) {\n React.render(<Handler/>, document.body);\n});\n\nThis problem does not happen with localhost/, this one always returns what I want.\nEDIT: This app is single-page, so /joblist doesn't need to ask anything to any server.\nEDIT2: My entire router.\nvar routes = (\n    <Route name=\"app\" path=\"/\" handler={App}>\n        <Route name=\"joblist\" path=\"/joblist\" handler={JobList}/>\n        <DefaultRoute handler={Dashboard}/>\n        <NotFoundRoute handler={NotFound}/>\n    </Route>\n);\n\nRouter.run(routes, Router.HistoryLocation, function (Handler) {\n  React.render(<Handler/>, document.body);\n});\n\n \nLooking at the comments on the accepted answer and the generic nature of this question ('don't work'), I thought this might be a good place for some general explanations about the issues involved here. So this answer is intended as background info / elaboration on the specific use case of the OP. Please bear with me.\nServer-side vs Client-side\nThe first big thing to understand about this is that there are now 2 places where the URL is interpreted, whereas there used to be only 1 in 'the old days'. In the past, when life was simple, some user sent a request for http://example.com/about to the server, which inspected the path part of the URL, determined the user was requesting the about page and then sent back that page.\nWith client-side routing, which is what React-Router provides, things are less simple. At first, the client does not have any JS code loaded yet. So the very first request will always be to the server. That will then return a page that contains the needed script tags to load React and React Router etc. Only when those scripts have loaded does phase 2 start. In phase 2, when the user clicks on the 'About us' navigation link for example, the URL is changed locally only to http://example.com/about (made possible by the History API), but no request to the server is made.  Instead, React Router does its thing on the client side, determines which React view to render and renders it. Assuming your about page does not need to make any REST calls, it's done already. You have transitioned from Home to About Us without any server request having fired.\nSo basically when you click a link, some Javascript runs that manipulates the URL in the address bar, without causing a page refresh, which in turn causes React Router to perform a page transition on the client side.\nBut now consider what happens if you copy-paste the URL in the address bar and e-mail it to a friend. Your friend has not loaded your website yet. In other words, she is still in phase 1. No React Router is running on her machine yet. So her browser will make a server request to http://example.com/about. \nAnd this is where your trouble starts. Until now, you could get away with just placing a static HTML at the webroot of your server. But that would give 404 errors for all other URLs when requested from the server. Those same URLs work fine on the client side, because there React Router is doing the routing for you, but they fail on the server side unless you make your server understand them.\nCombining server- and client-side routing\nIf you want the http://example.com/about URL to work on both the server- and the client-side, you need to set up routes for it on both the server- and the client side. Makes sense right?\nAnd this is where your choices begin. Solutions range from bypassing the problem altogether, via a catch-all route that returns the bootstrap HTML, to the full-on isomorphic approach where both the server and the client run the same JS code.\n.\nBypassing the problem altogether: Hash History\nWith Hash History instead of Browser History, your URL for the about page would look something like this:\nhttp://example.com/#/about\nThe part after the hash (#) symbol is not sent to the server. So the server only sees http://example.com/ and sends the index page as expected. React-Router will pick up the #/about part and show the correct page.\nDownsides: \n\n'ugly' URLs\nServer-side rendering is not possible with this approach. As far as Search Engine Optimization (SEO) is concerned, your website consists of a single page with hardly any content on it.\n\n.\nCatch-all\nWith this approach you do use Browser History, but just set up a catch-all on the server that sends /* to index.html, effectively giving you much the same situation as with Hash History. You do have clean URLs however and you could improve upon this scheme later without having to invalidate all your user's favorites.\nDownsides: \n\nMore complex to set up\nStill no good SEO\n\n.\nHybrid\nIn the hybrid approach you expand upon the catch-all scenario by adding specific scripts for specific routes. You could make some simple PHP scripts to return the most important pages of your site with content included, so Googlebot can at least see what's on your page.\nDownsides:\n\nEven more complex to set up\nOnly good SEO for those routes you give the special treatment\nDuplicating code for rendering content on server and client\n\n.\nIsomorphic\nWhat if we use Node JS as our server so we can run the same JS code on both ends? Now, we have all our routes defined in a single react-router config and we don't need to duplicate our rendering code. This is 'the holy grail' so to speak. The server sends the exact same markup as we would end up with if the page transition had happened on the client. This solution is optimal in terms of SEO.\nDownsides:\n\nServer must (be able to) run JS. I've experimented with Java i.c.w. Nashorn but it's not working for me. In practice it mostly means you must use a Node JS based server.\nMany tricky environmental issues (using window on server-side etc)\nSteep learning curve\n\n.\nWhich should I use?\nChoose the one that you can get away with. Personally I think the catch-all is simple enough to set up, so that would be my minimum. This setup allows you to improve on things over time. If you are already using Node JS as your server platform, I'd definitely investigate doing an isomorphic app. Yes it's tough at first, but once you get the hang of it it's actually a very elegant solution to the problem. \nSo basically, for me, that would be the deciding factor. If my server runs on Node JS, I'd go isomorphic; otherwise I would go for the Catch-all solution and just expand on it (Hybrid solution) as time progresses and SEO requirements demand it.\nIf you'd like to learn more on isomorphic (also called 'universal') rendering with React, there are some good tutorials on the subject:\n\nReact to the future with isomorphic apps\nThe Pain and the Joy of creating isomorphic apps in ReactJS\nHow to Implement Node + React Isomorphic JavaScript & Why it Matters\n\nAlso, to get you started, I recommend looking at some starter kits. Pick one that matches your choices for the technology stack (remember, React is just the V in MVC, you need more stuff to build a full app). Start with looking at the one published by Facebook itself:\n\nCreate React App \n\nOr pick one of the many by the community. There is a nice site now that tries to index all of them:\n\nPick your perfect React starter project\n\nI started with these:\n\nReact Isomorphic Starterkit\nReact Redux Universal Hot Example\n\nCurrently I am using a home-brew version of universal rendering that was inspired by the two starter kits above, but they are out of date now. \nGood luck with your quest!\n \nThe answers here are all extremely helpful, what worked for me was configuring my Webpack server to expect the routes.\ndevServer: {\n   historyApiFallback: true,\n   contentBase: './',\n   hot: true\n},\n\nThe historyApiFallback is what fixed this issue for me. Now routing works correctly and I can refresh the page or type in the URL directly. No need to worry about work arounds on your node server. This answer obviously only works if you're using webpack.\nEDIT: see my answer here for a more detailed reason why this is necessary:\nhttps://stackoverflow.com/a/37622953/5217568\n \nYou can change your .htaccess file and insert this:\n<IfModule mod_rewrite.c>\n  RewriteEngine On\n  RewriteBase /\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-l\n  RewriteRule . /index.html [L]\n</IfModule>\n\nI am using react: \"^16.12.0\" and react-router: \"^5.1.2\"\nThis method is the Catch-all and is probably the easiest way to get you started.\n \nFor React Router V4 Users:\nIf you try to solve this problem by Hash History technique mentioned in other answers, note that \n<Router history={hashHistory} >\n\ndoes not work in V4, please use HashRouter instead:\nimport { HashRouter } from 'react-router-dom'\n\n<HashRouter>\n  <App/>\n</HashRouter>\n\nReference: HashRouter\n \nI used create-react-app to make a website just now and had the same issue presented here. I use BrowserRouting from the react-router-dom package. I am running on a Nginx server and what solved it for me was adding the following to /etc/nginx/yourconfig.conf\nlocation / {\n  if (!-e $request_filename){\n    rewrite ^(.*)$ /index.html break;\n  }\n}\n\nWhich corresponds to adding the following to the .htaccess in case you are running Appache\nOptions -MultiViews\nRewriteEngine On\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.html [QSA,L]\n\nThis also seems to be the solution suggested by Facebook themselves and can be found here\n \nIn your index.html head, add the following:\n<base href=\"/\">\n<!-- This must come before the css and javascripts -->\n\nThen when running with webpack dev server use this command.\nwebpack-dev-server --mode development --hot --inline --content-base=dist --history-api-fallback\n\n--history-api-fallback is the important part\n \nThe router can be called in two different ways, depending on whether the navigation occurs on the client or on the server. You have it configured for client-side operation. The key parameter is the second one to the run method, the location.\nWhen you use the React Router Link component, it blocks browser navigation and calls transitionTo to do a client-side navigation. You are using HistoryLocation, so it uses the HTML5 history API to complete the illusion of navigation by simulating the new URL in the address bar. If you're using older browsers, this won't work. You would need to use the HashLocation component.\nWhen you hit refresh, you bypass all of the React and React Router code. The server gets the request for /joblist and it must return something. On the server you need to pass the path that was requested to the run method in order for it to render the correct view. You can use the same route map, but you'll probably need a different call to Router.run.  As Charles points out, you can use URL rewriting to handle this. Another option is to use a node.js server to handle all requests and pass the path value as the location argument. \nIn express, for example, it might look like this:\nvar app = express();\n\napp.get('*', function (req, res) { // This wildcard method handles all requests\n\n    Router.run(routes, req.path, function (Handler, state) {\n        var element = React.createElement(Handler);\n        var html = React.renderToString(element);\n        res.render('main', { content: html });\n    });\n});\n\nNote that the request path is being passed to run. To do this, you'll need to have a server-side view engine that you can pass the rendered HTML to. There are a number of other considerations using renderToString and in running React on the server. Once the page is rendered on the server, when your app loads in the client, it will render again, updating the server-side rendered HTML as needed.\n \nIf you're hosting a react app via AWS Static S3 Hosting & CloudFront\nThis problem presented itself by CloudFront responding with a 403 Access Denied message because it expected /some/other/path to exist in my S3 folder, but that path only exists internally in React's routing with react-router. \nThe solution was to set up a distribution Error Pages rule. Go to the CloudFront settings and choose your distribution. Next go to the \"Error Pages\" tab. Click \"Create Custom Error Response\" and add an entry for 403 since that's the error status code we get. Set the Response Page Path to /index.html and the status code to 200. The end result astonishes me with its simplicity. The index page is served, but the URL is preserved in the browser, so once the react app loads, it detects the URL path and navigates to the desired route. \nError Pages 403 Rule\n \nThis can solve your problem\nI also faced the same problem in the ReactJS application in Production mode.\nHere is the 2 solution to the problem.\n1.Change the routing history to \"hashHistory\" instead of browserHistory in the place of\n<Router history={hashHistory} >\n   <Route path=\"/home\" component={Home} />\n   <Route path=\"/aboutus\" component={AboutUs} />\n</Router>\n\nNow build the app using the command\nsudo npm run build\n\nThen place the build folder in your var/www/ folder, Now the application is working fine with the addition of # tag in each and every URL. like\nlocalhost/#/home\nlocalhost/#/aboutus\nSolution 2: Without # tag using browserHistory,\nSet your history = {browserHistory} in your Router, Now build it using sudo npm run build.\nYou need to create the \"conf\" file to solve the 404 not found page,\nthe conf file should be like this.\nopen your terminal type the below commands\ncd /etc/apache2/sites-available\nls\nnano sample.conf\nAdd the below content in it.\n<VirtualHost *:80>\n    ServerAdmin admin@0.0.0.0\n    ServerName 0.0.0.0\n    ServerAlias 0.0.0.0\n    DocumentRoot /var/www/html/\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n    <Directory \"/var/www/html/\">\n            Options Indexes FollowSymLinks\n            AllowOverride all\n            Require all granted\n    </Directory>\n</VirtualHost>\n\nNow you need to enable the sample.conf file by using the following command\ncd /etc/apache2/sites-available\nsudo a2ensite sample.conf\n\nthen it will ask you to reload the apache server, using\nsudo service apache2 reload or restart\nthen open your localhost/build folder and add the .htaccess file with the content of below.\n   RewriteEngine On\n   RewriteBase /\n   RewriteCond %{REQUEST_FILENAME} !-f\n   RewriteCond %{REQUEST_FILENAME} !-d\n   RewriteCond %{REQUEST_FILENAME} !-l\n   RewriteRule ^.*$ / [L,QSA]\n\nNow the app is working normally.\nNote: change 0.0.0.0 IP to your local IP address.\nIf any doubts regarding this feel free to raise a comment.\nI hope it is helpful to others.\n \nIf you are hosting your react app on IIS, just add a web.config file containing :\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <system.webServer>\n    <httpErrors errorMode=\"Custom\" existingResponse=\"Replace\">\n        <remove statusCode=\"404\" subStatusCode=\"-1\" />\n        <error statusCode=\"404\" path=\"/\" responseMode=\"ExecuteURL\" />\n    </httpErrors>\n  </system.webServer>\n</configuration>\n\nThis will tell IIS server to return the main page to the client instead of 404 error and no need to use hash history.\n \nThe Webpack Dev Server has an option to enable this. Open up package.json and add --history-api-fallback.\nThis solutions worked for me.\nreact-router-tutorial\n \nIf you are using Create React App:\nThere's a great walk though of this issue with solutions for many major hosting platforms that you can find HERE on the Create React App page.  For example, I use React Router v4 and Netlify for my frontend code.  All it took was adding 1 file to my public folder (\"_redirects\") and one line of code in that file:\n/*  /index.html  200\n\nNow my website properly renders paths like mysite.com/pricing when entered into the browser or when someone hits refresh.\n \nAdd this to webpack.config.js:\ndevServer: {\n    historyApiFallback: true\n}\n\n \nProduction stack: React, React Router v4, BrowswerRouter, Express, Nginx\n1) User BrowserRouter for pretty urls \n// app.js\n\nimport { BrowserRouter as Router } from 'react-router-dom'\n\nconst App = () {\n  render() {\n    return (\n        <Router>\n           // your routes here\n        </Router>\n    )\n  }\n}\n\n2) Add index.html to all unknown requests by using /*\n// server.js\n\napp.get('/*', function(req, res) {   \n  res.sendFile(path.join(__dirname, 'path/to/your/index.html'), function(err) {\n    if (err) {\n      res.status(500).send(err)\n    }\n  })\n})\n\n3) bundle webpack with webpack -p\n4) run nodemon server.js or node server.js\nEDIT: You may want to let nginx handle this in the server block and disregard step 2:\nlocation / {\n    try_files $uri /index.html;\n}\n\n \nTry adding \".htaccess\" file inside the public folder with the below code.\nRewriteEngine On\nRewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -f [OR]\nRewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -d\nRewriteRule ^ - [L]\n\nRewriteRule ^ /index.html [L]  \n\n \nIf you do have a fallback to your index.html, make sure that in your index.html file you have this:\n<script>\n  System.config({ baseURL: '/' });\n</script>\n\nThis may differ from project to project.\n \nIf you're using firebase all you have to do is make sure you've got a rewrites property in your firebase.json file in the root of your app (in the hosting section). \nFor example:\n{ \n  \"hosting\": {\n    \"rewrites\": [{\n      \"source\":\"**\",\n      \"destination\": \"/index.html\"\n    }]    \n  }\n}\n\nHope this saves somebody else a hoard of frustration and wasted time.\nHappy coding...\nFurther reading on the subject:\nhttps://firebase.google.com/docs/hosting/full-config#rewrites\nFirebase CLI: \"Configure as a single-page app (rewrite all urls to /index.html)\"\n \nI found the solution for my SPA with react router (Apache). Just add in .htaccess\n<IfModule mod_rewrite.c>\n\n  RewriteEngine On\n  RewriteBase /\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-l\n  RewriteRule . /index.html [L]\n\n</IfModule>\n\nsource: https://gist.github.com/alexsasharegan/173878f9d67055bfef63449fa7136042\n \nI'm not using server side rendering yet but I hit the same problem as the OP where Link seemed to work fine most of the time but failed when I had a parameter. I'll document my solution here to see if it helps anyone.\nMy main jsx contains this:\n<Route onEnter={requireLogin} path=\"detail/:id\" component={ModelDetail} />\n\nThis works fine for the first matching link but when the :id changes in <Link> expressions nested on that model's detail page, the url changes in the browser bar but the content of the page did not initially change to reflect the linked model.\nThe trouble was that I had used the props.params.id to set the model in componentDidMount. The component is just mounted once so this means that the first model is the one that sticks on the page and the subsequent Links change the props but leave the page looking unchanged.\nSetting the model in the component state in both componentDidMount and in componentWillReceiveProps (where it is based on the next props) solves the problem and the page content changes to reflect the desired model.\n \nThis topic is a little bit old and solved but I would like to suggest you a simply, clear and better solution. It works if you use web server.\nEach web server has an ability to redirect the user to an error page in case of http 404. To solve this issue you need to redirect user to the index page.\nIf you use Java base server (tomcat or any java application server) the solution could be the following:\nweb.xml:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n         version=\"3.1\">\n\n    <!-- WELCOME FILE LIST -->\n    <welcome-file-list>\n        <welcome-file>index.jsp</welcome-file>\n    </welcome-file-list>\n\n    <!-- ERROR PAGES DEFINITION -->\n    <error-page>\n        <error-code>404</error-code>\n        <location>/index.jsp</location>\n    </error-page>\n\n</web-app>\n\nExample:\n\nGET http://example.com/about\nWeb server throws http 404 because this page does not exist on the server side\nthe error page configuration tells to the server that send the index.jsp page back to the user\nthen JS will do the rest of the job on the clien side because the url on the client side is still http://example.com/about.\n\nThat is it, no more magic needs:)\n \nFor those who are using IIS 10, this is what you should do to make this right. Be sure that you are using browserHistory with this. As for reference I will give the code for the routing, but this is not what matters, what matters is the next step after the component code below:\nclass App extends Component {\n    render() {\n        return (\n            <Router history={browserHistory}>\n                <div>\n                    <Root>\n                        <Switch>\n                            <Route exact path={\"/\"} component={Home} />    \n                            <Route path={\"/home\"} component={Home} />\n                            <Route path={\"/createnewproject\"} component={CreateNewProject} />\n                            <Route path={\"/projects\"} component={Projects} />\n                            <Route path=\"*\" component={NotFoundRoute} />\n                        </Switch>\n                    </Root>\n                </div>\n            </Router>\n        )\n    }\n}\nrender (<App />, window.document.getElementById(\"app\"));\n\nSince the problem is IIS receives request from client browsers, it will interpret the URL as if it is asking for a page, then returns a 404 page since there is no available page. Do the following:\n\nOpen IIS\nExpand Server then open the Sites Folder\nClick the website/application\nGo to the Error Pages\nOpen the 404 error status item in the list\nInstead of the option \"Insert content from static file into the error response\", change it to \"Execute a URL on this site\" and add \"/\" slash value to the URL.\n\nAnd it will now work fine.\n\n\nI hope it helps. :-)\n \nIf you are using Express or some other framework in the backend , you can add the similar configuration as below and check out the Webpack public path in the configuration, it should work fine even on reload if you are using BrowserRouter\nexpressApp.get('/*', (request, response) => {\n    response.sendFile(path.join(__dirname, '../public/index.html'));\n});\n\n \nFixing the \"cannot GET /URL\" error on refresh or on calling the URL directly.\nConfigure your webpack.config.js to expect the given link the routes like this.\nmodule.exports = {\n  entry: './app/index.js',\n  output: {\n       path: path.join(__dirname, '/bundle'),\n       filename: 'index_bundle.js',\n       publicPath: '/'\n  },\n\n \nAs I am using .Net Core MVC something like this helped me:\n    public class HomeController : Controller\n    {\n        public IActionResult Index()\n        {\n            var url = Request.Path + Request.QueryString;\n            return App(url);\n        }\n\n        [Route(\"App\")]\n        public IActionResult App(string url)\n        {\n            return View(\"/wwwroot/app/build/index.html\");\n        }\n   }\n\nBasically in MVC side, all the routes not matching will fall into to Home/Index as it specified in startup.cs. Inside Index it is possible to get the original request url and pass it wherever needed.\n\nstartup.cs\n\n        app.UseMvc(routes =>\n        {\n            routes.MapRoute(\n                name: \"default\",\n                template: \"{controller=Home}/{action=Index}/{id?}\");\n\n            routes.MapSpaFallbackRoute(\n                name: \"spa-fallback\",\n                defaults: new { controller = \"Home\", action = \"Index\" });\n        });\n\n \nIf you are hosting in IIS ; Adding this to my webconfig solved my problem\n<httpErrors errorMode=\"Custom\" defaultResponseMode=\"ExecuteURL\">\n    <remove statusCode=\"500\" subStatusCode=\"100\" />\n    <remove statusCode=\"500\" subStatusCode=\"-1\" />\n    <remove statusCode=\"404\" subStatusCode=\"-1\" />\n    <error statusCode=\"404\" path=\"/\" responseMode=\"ExecuteURL\" />\n    <error statusCode=\"500\" prefixLanguageFilePath=\"\" path=\"/error_500.asp\" responseMode=\"ExecuteURL\" />\n    <error statusCode=\"500\" subStatusCode=\"100\" path=\"/error_500.asp\" responseMode=\"ExecuteURL\" />\n</httpErrors>\n\nYou can make similar configuration for any other server\n \nUsing HashRouter worked for me with Redux also, just simply replace:\nimport {\n  Router //replace Router\n} from \"react-router-dom\";\n\nReactDOM.render(\n    <LocaleProvider locale={enUS}>\n    <Provider store={Store}>\n        <Router history={history}> //replace here saying Router\n            <Layout/>\n        </Router>\n    </Provider>\n</LocaleProvider>, document.getElementById(\"app\"));\nregisterServiceWorker();\n\nto:\nimport {\n  HashRouter //replaced with HashRouter\n} from \"react-router-dom\";\n\nReactDOM.render(\n    <LocaleProvider locale={enUS}>\n    <Provider store={Store}>\n        <HashRouter history={history}> //replaced with HashRouter\n            <Layout/>\n        </HashRouter>\n    </Provider>\n</LocaleProvider>, document.getElementById(\"app\"));\nregisterServiceWorker();\n\n \nIn case, anyone is here looking for solution on React JS SPA with Laravel.\nThe accepted answer is the best explanation of why such problems happen. As already explained you have to configure both client side and server side.\nIn your blade template, include the js bundled file, make sure to use URL facade like this\n<script src=\"{{ URL::to('js/user/spa.js') }}\"></script>\n\nIn your routes, make sure add this to the main endpoint where the blade template is. For example,\nRoute::get('/setting-alerts', function () {\n   return view('user.set-alerts');\n});\n\nThe above is the main endpoint for the blade template. Now add an optional route too,\nRoute::get('/setting-alerts/{spa?}', function () {\n  return view('user.set-alerts');\n});\n\nThe problem that happens is that first the blade template is loaded, then the react router. So, when you're loading '/setting-alerts', it loads the html and the js. But when you load '/setting-alerts/about', it first loads on the server side. Since on the server side, there is nothing on this location, it returns not found. When you have that optional router, it loads that same page and react router is also loaded, then react loader decides which component to show.\nHope this helps.\n \nI am using WebPack, I had same problem Solution=>\nIn your server.js file\nconst express = require('express');\nconst app = express();\n\napp.use(express.static(path.resolve(__dirname, '../dist')));\n  app.get('*', function (req, res) {\n    res.sendFile(path.resolve(__dirname, '../dist/index.html'));\n    // res.end();\n  });\n\nWhy doesn't my application render after refreshing?\n \nyou can try reading this all though it's not mine:\nhttps://www.andreasreiterer.at/fix-browserrouter-on-apache/\nFixing the app\u2019s routing\nNow here\u2019s how to finally fix the routing. To tell Apache to redirect requests to index.html where our app lives, we have to modify the .htaccess file. If there is no such file in your app\u2019s folder yet, just create it.\nThen be sure that you put in those 4 lines that will magically make your routing work.\nOptions -MultiViews\nRewriteEngine On\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.html [QSA,L]\n\nAfter we put that .htaccess file into the same directory as the index.html, Apache will redirect each new request directly to your app.\nBonus: Deploying the React app to a sub directory\nIf you\u2019re deploying your app into a sub directory, so it\u2019s accessible e.g. via https://myapp.com/the-app, you\u2019ll soon notice that there is another issue. Each click to a new route will transform the URL to something like https://myapp.com/route-abc \u2013 which will break again after a reload. But there is a simple fix for that:\nBrowserRouter has a prop called basename where you can specify your sub-directory path:\n\nFrom now on, each Route like /contacts will result in an URL like http://myapp.com/the-app/contacts.\n \nI had this same problem and this solution worked for us..\nBackground:\nWe are hosting multiple apps on the same server.  When we would refresh the server would not understand where to look for our index in the dist folder for that particular app.  The above link will take you to what worked for us... Hope this helps, as we have spent quite a hours on figuring out a solution for our needs. \nWe are using:\npackage.json\n\n\"dependencies\": {\n\"babel-polyfill\": \"^6.23.0\",\n\"ejs\": \"^2.5.6\",\n\"express\": \"^4.15.2\",\n\"prop-types\": \"^15.5.6\",\n\"react\": \"^15.5.4\",\n\"react-dom\": \"^15.5.4\",\n\"react-redux\": \"^5.0.4\",\n\"react-router\": \"^3.0.2\",\n\"react-router-redux\": \"^4.0.8\",\n\"redux\": \"^3.6.0\",\n\"redux-persist\": \"^4.6.0\",\n\"redux-thunk\": \"^2.2.0\",\n\"webpack\": \"^2.4.1\"\n}\n\nmy webpack.config.js\nwebpack.config.js\n\n/* eslint-disable */\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst babelPolyfill = require('babel-polyfill');\nconst HTMLWebpackPluginConfig = new HtmlWebpackPlugin({\n  template: __dirname + '/app/views/index.html',\n  filename: 'index.html',\n  inject: 'body'\n});\n\nmodule.exports = {\n  entry: [\n    'babel-polyfill', './app/index.js'\n  ],\n  output: {\n    path: __dirname + '/dist/your_app_name_here',\n    filename: 'index_bundle.js'\n  },\n  module: {\n    rules: [{\n      test: /\\.js$/,\n      loader: 'babel-loader',\n      query : {\n          presets : [\"env\", \"react\", \"stage-1\"]\n      },\n      exclude: /node_modules/\n    }]\n  },\n  plugins: [HTMLWebpackPluginConfig]\n}\n\nmy index.js\nindex.js\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport Routes from './Routes'\nimport { Provider } from 'react-redux'\nimport { createHistory } from 'history'\nimport { useRouterHistory } from 'react-router'\nimport configureStore from './store/configureStore'\nimport { syncHistoryWithStore } from 'react-router-redux'\nimport { persistStore } from 'redux-persist'\n\nconst store = configureStore();\n\nconst browserHistory = useRouterHistory(createHistory) ({\n  basename: '/your_app_name_here'\n})\nconst history = syncHistoryWithStore(browserHistory, store)\n\npersistStore(store, {blacklist: ['routing']}, () => {\n  console.log('rehydration complete')\n})\n// persistStore(store).purge()\n\n\nReactDOM.render(\n    <Provider store={store}>\n      <div>\n        <Routes history={history} />\n      </div>\n    </Provider>,\n  document.getElementById('mount')\n)\n\nmy app.js\nvar express = require('express');\nvar app = express();\n\napp.use(express.static(__dirname + '/dist'));\n// app.use(express.static(__dirname + '/app/assets'));\napp.set('views', __dirname + '/dist/your_app_name_here');\napp.engine('html', require('ejs').renderFile);\napp.set('view engine', 'html');\n\napp.get('/*', function (req, res) {\n    res.render('index');\n});\n\napp.listen(8081, function () {\n  console.log('MD listening on port 8081!');\n});\n\n", "\nI would like to ask why my state is not changing when I do an onclick event. I've search a while ago that I need to bind the onclick function in constructor but still the state is not updating. Here's my code:\nimport React from 'react';\n\nimport Grid from 'react-bootstrap/lib/Grid';\nimport Row from 'react-bootstrap/lib/Row';\nimport Col from 'react-bootstrap/lib/Col';\n\nimport BoardAddModal from 'components/board/BoardAddModal.jsx';\n\nimport style from 'styles/boarditem.css';\n\nclass BoardAdd extends React.Component {\n\n    constructor(props){\n        super(props);\n\n        this.state = {\n            boardAddModalShow: false\n        }\n\n        this.openAddBoardModal = this.openAddBoardModal.bind(this);\n    }\n    openAddBoardModal(){\n        this.setState({ boardAddModalShow: true });\n// After setting a new state it still return a false value\n        console.log(this.state.boardAddModalShow);\n\n    }\n\n    render() {\n\n        return (\n            <Col lg={3}>\n                <a href=\"javascript:;\" className={style.boardItemAdd} onClick={this.openAddBoardModal}>\n                    <div className={[style.boardItemContainer,style.boardItemGray].join(' ')}>\n                        Create New Board\n                    </div>\n                </a>\n\n\n\n            </Col>\n        )\n    }\n}\n\nexport default BoardAdd\n\n \nThis callback is really messy. Just use async await instead:\nasync openAddBoardModal(){\n    await this.setState({ boardAddModalShow: true });\n    console.log(this.state.boardAddModalShow);\n}\n\n \nYour state needs some time to mutate, and since console.log(this.state.boardAddModalShow) executes before the state mutates, you get the previous value as output. So you need to write the console in the callback to the setState function\nopenAddBoardModal() {\n  this.setState({ boardAddModalShow: true }, function () {\n    console.log(this.state.boardAddModalShow);\n  });\n}\n\nsetState is asynchronous. It means you can\u2019t call it on one line and assume the state has changed on the next.\nAccording to React docs\n\nsetState() does not immediately mutate this.state but creates a\n  pending state transition. Accessing this.state after calling this\n  method can potentially return the existing value. There is no\n  guarantee of synchronous operation of calls to setState and calls may\n  be batched for performance gains.\n\nWhy would they make setState async\n\nThis is because setState alters the state and causes rerendering. This\n  can be an expensive operation and making it synchronous might leave\n  the browser unresponsive. \nThus the setState calls are asynchronous as well as batched for better\n  UI experience and performance.\n\n \nFortunately setState() takes a callback. And this is where we get updated state.\nConsider this example.\nthis.setState({ name: \"myname\" }, () => {                              \n        //callback\n        console.log(this.state.name) // myname\n      });\n\nSo When callback fires, this.state is the updated state.\nYou can get mutated/updated data in callback.\n \nSince setSatate is a asynchronous function so you need to console the state as a callback like this. \nopenAddBoardModal(){\n    this.setState({ boardAddModalShow: true }, () => {\n        console.log(this.state.boardAddModalShow)\n    });\n}\n\n \nsetState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below.\nsetState() will always lead to a re-render unless shouldComponentUpdate() returns false. If mutable objects are being used and conditional rendering logic cannot be implemented in shouldComponentUpdate(), calling setState() only when the new state differs from the previous state will avoid unnecessary re-renders.\nThe first argument is an updater function with the signature:\n(state, props) => stateChange\n\nstate is a reference to the component state at the time the change is being applied. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from state and props. For instance, suppose we wanted to increment a value in state by props.step:\nthis.setState((state, props) => {\n    return {counter: state.counter + props.step};\n});\n\n \nIf you want to track the state is updating or not then the another way of doing the same thing is \n_stateUpdated(){\n  console.log(this.state. boardAddModalShow);\n}\n\nopenAddBoardModal(){\n  this.setState(\n    {boardAddModalShow: true}, \n    this._stateUpdated.bind(this)\n  );\n}\n\nThis way you can call the method \"_stateUpdated\" every time you try to update the state for debugging.\n \nsetState() is asynchronous. The best way to verify if the state is updating would be in the componentDidUpdate() and not to put a console.log(this.state.boardAddModalShow) after this.setState({ boardAddModalShow: true }) .\naccording to React Docs\n\nThink of setState() as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately\n\n \nAccording to React Docs\n\nReact does not guarantee that the state changes are applied immediately.\n  This makes reading this.state right after calling setState() a potential pitfall and can potentially return the existing value due to async nature . \n  Instead, use componentDidUpdate or a setState callback that is executed right after setState operation is successful.Generally we recommend using componentDidUpdate() for such logic instead.\n\nExample:\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport \"./styles.css\";\n\nclass App extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      counter: 1\n    };\n  }\n  componentDidUpdate() {\n    console.log(\"componentDidUpdate fired\");\n    console.log(\"STATE\", this.state);\n  }\n\n  updateState = () => {\n    this.setState(\n      (state, props) => {\n        return { counter: state.counter + 1 };\n      });\n  };\n  render() {\n    return (\n      <div className=\"App\">\n        <h1>Hello CodeSandbox</h1>\n        <h2>Start editing to see some magic happen!</h2>\n        <button onClick={this.updateState}>Update State</button>\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n\n\n \nFor anyone trying to do this with hooks, you need useEffect.\nfunction App() {\n  const [x, setX] = useState(5)\n  const [y, setY] = useState(15) \n\n  console.log(\"Element is rendered:\", x, y)\n\n  // setting y does not trigger the effect\n  // the second argument is an array of dependencies\n  useEffect(() => console.log(\"re-render because x changed:\", x), [x])\n\n  function handleXClick() {\n    console.log(\"x before setting:\", x)\n    setX(10)\n    console.log(\"x in *line* after setting:\", x)\n  }\n\n  return <>\n    <div> x is {x}. </div>\n    <button onClick={handleXClick}> set x to 10</button>\n    <div> y is {y}. </div>\n    <button onClick={() => setY(20)}> set y to 20</button>\n  </>\n}\n\nOutput:\nElement is rendered: 5 15\nre-render because x changed: 5\n(press x button)\nx before setting: 5\nx in *line* after setting: 5\nElement is rendered: 10 15\nre-render because x changed: 10\n(press y button)\nElement is rendered: 10 20\n\n \nwhen i was running the code and checking my output at console it showing the that it is undefined.\nAfter i search around and find something that worked for me.\ncomponentDidUpdate(){}\n\nI added this method in my code after constructor().\ncheck out the life cycle of react native workflow.\nhttps://images.app.goo.gl/BVRAi4ea2P4LchqJ8\n \n this.setState({\n    isMonthFee: !this.state.isMonthFee,\n  }, () => {\n    console.log(this.state.isMonthFee);\n  })\n\n \nYes because setState is an asynchronous function. The best way to set state right after you write set state is by using Object.assign like this: \nFor eg you want to set a property isValid to true, do it like this\n\n\nObject.assign(this.state, { isValid: true })\n\n\nYou can access updated state just after writing this line.\n", "\n\n\n\n\n\n\nThis question already has answers here:\r\n                        \r\n                    \n\n\n\nHow to access the correct `this` inside a callback?\n\r\n                                (12 answers)\r\n                            \n\nClosed 6 months ago.\n\n\n\nI am writing a simple component in ES6 (with BabelJS), and functions this.setState is not working. \nTypical errors include something like\n\nCannot read property 'setState' of undefined \n\nor\n\nthis.setState is not a function\n\nDo you know why? Here is the code:\nimport React from 'react'\n\nclass SomeClass extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {inputContent: 'startValue'}\n  }\n\n  sendContent(e) {\n    console.log('sending input content '+React.findDOMNode(React.refs.someref).value)\n  }\n\n  changeContent(e) {\n    this.setState({inputContent: e.target.value})\n  } \n\n  render() {\n    return (\n      <div>\n        <h4>The input form is here:</h4>\n        Title: \n        <input type=\"text\" ref=\"someref\" value={this.inputContent} \n          onChange={this.changeContent} /> \n        <button onClick={this.sendContent}>Submit</button>\n      </div>\n    )\n  }\n}\n\nexport default SomeClass\n\n \nthis.changeContent needs to be bound to the component instance via this.changeContent.bind(this) before being passed as the onChange prop, otherwise the this variable in the body of the function will not refer to the component instance but to window. See Function::bind.\nWhen using React.createClass instead of ES6 classes, every non-lifecycle method defined on a component is automatically bound to the component instance. See Autobinding.\nBe aware that binding a function creates a new function. You can either bind it directly in render, which means a new function will be created every time the component renders, or bind it in your constructor, which will only fire once.\nconstructor() {\n  this.changeContent = this.changeContent.bind(this);\n}\n\nvs\nrender() {\n  return <input onChange={this.changeContent.bind(this)} />;\n}\n\n\nRefs are set on the component instance and not on React.refs: you need to change React.refs.someref to this.refs.someref. You'll also need to bind the sendContent method to the component instance so that this refers to it.\n \nMorhaus is correct, but this can be solved without bind.\nYou can use an arrow function together with the class properties proposal: \nclass SomeClass extends React.Component {\n  changeContent = (e) => {\n    this.setState({inputContent: e.target.value})\n  } \n\n  render() {\n    return <input type=\"text\" onChange={this.changeContent} />;\n  }\n}\n\nBecause the arrow function is declared in the scope of the constructor, and because arrow functions maintain this from their declaring scope, it all works. The downside here is that these wont be functions on the prototype, they will all be recreated with each component. However, this isn't much of a downside since bind results in the same thing.\n \nThis issue is one of the first things most of us experience, when transitioning from the React.createClass() component definition syntax to the ES6 class way of extending React.Component.\nIt is caused by the this context differences in React.createClass() vs extends React.Component.\nUsing React.createClass() will automatically bind this context (values) correctly, but that is not the case when using ES6 classes. When doing it the ES6 way (by extending React.Component) the this context is null by default. Properties of the class do not automatically bind to the React class (component) instance.\n\nApproaches to Solve this Issue\nI know a total of 4 general approaches.\n\nBind your functions in the class constructor. Considered by many as a best-practice approach that avoids touching JSX at all and doesn't create a new function on each component re-render.\nclass SomeClass extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    console.log(this); // the React Component instance\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}></button>\n    );\n  }\n}\n\nBind your functions inline. You can still find this approach used here and there in some tutorials / articles / etc, so it's important you're aware of it. It it the same concept like #1, but be aware that binding a function creates a new function per each re-render.\nclass SomeClass extends React.Component {\n  handleClick() {\n    console.log(this); // the React Component instance\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick.bind(this)}></button>\n    );\n  }\n}\n\nUse a fat arrow function. Until arrow functions, every new function defined its own this value. However, the arrow function does not create its own this context, so this has the original meaning from the React component instance. Therefore, we can:\nclass SomeClass extends React.Component {\n  handleClick() {\n    console.log(this); // the React Component instance\n  }\n  render() {\n    return (\n      <button onClick={ () => this.handleClick() }></button>\n    );\n  }\n}\n\nor\nclass SomeClass extends React.Component {\n  handleClick = () => {\n    console.log(this); // the React Component instance\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}></button>\n    );\n  }\n}\n\nUse utility function library to automatically bind your functions. There are a few utility libraries out there, that automatically does the job for you. Here are some of the popular, just to mention a few:\n\nAutobind Decorator is an NPM package which binds methods of a class to the correct instance of this, even when the methods are detached. The package uses @autobind before methods to bind this to the correct reference to the component's context.\nimport autobind from 'autobind-decorator';\n\nclass SomeClass extends React.Component {\n  @autobind\n  handleClick() {\n    console.log(this); // the React Component instance\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}></button>\n    );\n  }\n}\n\nAutobind Decorator is smart enough to let us bind all methods inside a component class at once, just like approach #1.\nClass Autobind is another NPM package that is widely used to solve this binding issue. Unlike Autobind Decorator, it does not use of the decorator pattern, but really just uses a function inside your constructor that automatically binds the Component's methods to the correct reference of this.\nimport autobind from 'class-autobind';\n\nclass SomeClass extends React.Component {\n  constructor() {\n    autobind(this);\n    // or if you want to bind only only select functions:\n    // autobind(this, 'handleClick');\n  }\n  handleClick() {\n    console.log(this); // the React Component instance\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}></button>\n    );\n  }\n}\n\nPS: Other very similar library is React Autobind.\n\n\n\nRecommendation\nIf I were you, I would stick with approach #1. However, as soon as you get a ton of binds in your class constructor, I would recommend you to explore one of the helper libraries mentioned in approach #4.\n\nOther\nIt's not related to the issue you have, but you shouldn't overuse refs.\n\nYour first inclination may be to use refs to \"make things happen\" in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy.\n\nFor similar purposes, just like the one you need, using a controlled component is the preferred way. I suggest you to consider using your Component state. So, you can simply access the value like this: this.state.inputContent.\n \nAlthough the previous answers have provided the basic overview of solutions (i.e. binding, arrow functions, decorators that do this for you), I've yet to come across an answer which actually explains why this is necessary\u2014which in my opinion is the root of confusion, and leads to unnecessary steps such as needless rebinding and blindly following what others do.\nthis is dynamic\nTo understand this specific situation, a brief introduction to how this works. The key thing here is that this is a runtime binding and depends on the current execution context. Hence why it's commonly referred to as \"context\"\u2014giving information on the current execution context, and why you need to bind is because you loose \"context\". But let me illustrate the issue with a snippet:\nconst foobar = {\n  bar: function () {\n    return this.foo;\n  },\n  foo: 3,\n};\nconsole.log(foobar.bar()); // 3, all is good!\n\nIn this example, we get 3, as expected. But take this example:\nconst barFunc = foobar.bar;\nconsole.log(barFunc()); // Uh oh, undefined!\n\nIt may be unexpected to find that it logs undefined\u2014where did the 3 go? The answer lies in \"context\", or how you execute a function. Compare how we call the functions:\n// Example 1\nfoobar.bar();\n// Example 2\nconst barFunc = foobar.bar;\nbarFunc();\n\nNotice the difference. In the first example, we are specifying exactly where the bar method1 is located\u2014on the foobar object:\nfoobar.bar();\n^^^^^^\n\nBut in the second, we store the method into a new variable, and use that variable to call the method, without explicitly stating where the method actually exists, thus losing context:\nbarFunc(); // Which object is this function coming from?\n\nAnd therein lies the problem, when you store a method in a variable, the original information about where that method is located (the context in which the method is being executed), is lost. Without this information, at runtime, there is no way for the JavaScript interpreter to bind the correct this\u2014without specific context, this does not work as expected2. \nRelating to React\nHere's an example of a React component (shortened for brevity) suffering from the this problem:\nhandleClick() {\n  this.setState(({ clicks }) => ({ // setState is async, use callback to access previous state\n    clicks: clicks + 1, // increase by 1\n  }));\n}\n\nrender() {\n  return (\n    <button onClick={this.handleClick}>{this.state.clicks}</button>\n  );\n}\n\nBut why, and how does the previous section relate to this? This is because they suffer from an abstraction of the same problem. If you take a look how React handles event handlers:\n// Edited to fit answer, React performs other checks internally\n// props is the current React component's props, registrationName is the name of the event handle prop, i.e \"onClick\"\nlet listener = props[registrationName];\n// Later, listener is called\n\nSo, when you do onClick={this.handleClick}, the method this.handleClick is eventually assigned to the variable listener3. But now you see the problem arise\u2014since we've assigned this.handleClick to listener, we no longer specify exactly where handleClick is coming from! From React's point of view, listener is just some function, not attached to any object (or in this case, React component instance). We have lost context and thus the interpreter cannot infer a this value to use inside handleClick.\nWhy binding works\nYou might be wondering, if the interpreter decides the this value at runtime, why can I bind the handler so that it does work? This is because you can use Function#bind to guarantee the this value at runtime. This is done by setting an internal this binding property on a function, allowing it to not infer this:\nthis.handleClick = this.handleClick.bind(this);\n\nWhen this line is executed, presumably in the constructor, the current this is captured (the React component instance) and set as an internal this binding of a entirely new function, returned from Function#bind. This makes sure that when this is being calculated at runtime, the interpreter will not try to infer anything, but use the provided this value you given it.\nWhy arrow function properties work\nArrow function class properties currently work through Babel based on the transpilation:\nhandleClick = () => { /* Can use this just fine here */ }\n\nBecomes:\nconstructor() {\n  super();\n  this.handleClick = () => {}\n}\n\nAnd this works due to the fact arrow functions do not bind their own this, but take the this of their enclosing scope. In this case, the constructor's this, which points to the React component instance\u2014thus giving you the correct this.4\n\n1 I use \"method\" to refer to a function that is supposed to be bound to an object, and \"function\" for those not.\n2 In the second snippet, undefined is logged instead of 3 because this defaults to the global execution context (window when not in strict mode, or else undefined) when it cannot be determined via specific context. And in the example window.foo does not exist thus yielding undefined.\n3 If you go down the rabbit hole of how events in the event queue are executed, invokeGuardedCallback is called on the listener. \n4 It's actually a lot more complicated. React internally tries to use Function#apply on listeners for its own use, but this does not work arrow functions as they simply do not bind this. That means, when this inside the arrow function is actually evaluated, the this is resolved up each lexical environment of each execution context of the current code of the module. The execution context which finally resolves to have a this binding is the constructor, which has a this pointing to the current React component instance, allowing it to work.\n \nYou can tackle this by three ways \n1.Bind the event function in the constructor itself as follows\nimport React from 'react'\n\nclass SomeClass extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {inputContent: 'startValue'}\n    this.changeContent = this.changeContent.bind(this);\n  }\n\n  sendContent(e) {\n    console.log('sending input content '+React.findDOMNode(React.refs.someref).value)\n  }\n\n  changeContent(e) {\n    this.setState({inputContent: e.target.value})\n  } \n\n  render() {\n    return (\n      <div>\n        <h4>The input form is here:</h4>\n        Title: \n        <input type=\"text\" ref=\"someref\" value={this.inputContent} \n          onChange={this.changeContent} /> \n        <button onClick={this.sendContent}>Submit</button>\n      </div>\n    )\n  }\n}\n\nexport default SomeClass\n\n2.Bind when it is called \nimport React from 'react'\n\nclass SomeClass extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {inputContent: 'startValue'}\n  }\n\n  sendContent(e) {\n    console.log('sending input content '+React.findDOMNode(React.refs.someref).value)\n  }\n\n  changeContent(e) {\n    this.setState({inputContent: e.target.value})\n  } \n\n  render() {\n    return (\n      <div>\n        <h4>The input form is here:</h4>\n        Title: \n        <input type=\"text\" ref=\"someref\" value={this.inputContent} \n          onChange={this.changeContent} /> \n        <button onClick={this.sendContent.bind(this)}>Submit</button>\n      </div>\n    )\n  }\n}\n\nexport default SomeClass\n\n3.By using Arrow functions\nimport React from 'react'\n\nclass SomeClass extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {inputContent: 'startValue'}\n  }\n\n  sendContent(e) {\n    console.log('sending input content '+React.findDOMNode(React.refs.someref).value)\n  }\n\n  changeContent(e) {\n    this.setState({inputContent: e.target.value})\n  } \n\n  render() {\n    return (\n      <div>\n        <h4>The input form is here:</h4>\n        Title: \n        <input type=\"text\" ref=\"someref\" value={this.inputContent} \n          onChange={this.changeContent} /> \n        <button onClick={()=>this.sendContent()}>Submit</button>\n      </div>\n    )\n  }\n}\n\nexport default SomeClass\n\n \nWe need to bind the event function with the component in constructor as follows,\nimport React from 'react'\n\nclass SomeClass extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {inputContent: 'startValue'}\n    this.changeContent = this.changeContent.bind(this);\n  }\n\n  sendContent(e) {\n    console.log('sending input content '+React.findDOMNode(React.refs.someref).value)\n  }\n\n  changeContent(e) {\n    this.setState({inputContent: e.target.value})\n  } \n\n  render() {\n    return (\n      <div>\n        <h4>The input form is here:</h4>\n        Title: \n        <input type=\"text\" ref=\"someref\" value={this.inputContent} \n          onChange={this.changeContent} /> \n        <button onClick={this.sendContent}>Submit</button>\n      </div>\n    )\n  }\n}\n\nexport default SomeClass\n\nThanks\n \nMy recommendation is use arrow functions as a properties  \nclass SomeClass extends React.Component {\n  handleClick = () => {\n    console.log(this); // the React Component instance\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}></button>\n    );\n  }\n}\n\nand do not use arrow functions as \nclass SomeClass extends React.Component {\n      handleClick(){\n        console.log(this); // the React Component instance\n      }\n      render() {\n        return (\n          <button onClick={()=>{this.handleClick}}></button>\n        );\n      }\n    }\n\nbecause second approach will generate new function every render call in fact this means new pointer new version of props, than if you will later care about performance you are able use React.PureComponent or in React.Component  you can override shouldComponentUpdate(nextProps, nextState) and shallow check when props arrived\n \nYou can solve this following these steps\nChange  sendContent function with\n sendContent(e) {\n    console.log('sending input content '+this.refs.someref.value)\n  }\n\nChange render function with \n<input type=\"text\" ref=\"someref\" value={this.state.inputContent} \n          onChange={(event)=>this.changeContent(event)} /> \n   <button onClick={(event)=>this.sendContent(event)}>Submit</button>\n\n \nWe have to bind our function with this to get instance of the function in class. Like so in example\n<button onClick={this.sendContent.bind(this)}>Submit</button>\n\nThis way this.state will be valid object.\n \nif anyone will ever reach this answer,\nhere is a way to bind all of the functions without needing to bind them manually\nin the constructor():\nfor (let member of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n    this[member] = this[member].bind(this)\n}\n\nor create this function in a global.jsx file\nexport function bindAllFunctions({ bindTo: dis }) {\nfor (let member of Object.getOwnPropertyNames(Object.getPrototypeOf(dis))) {\n    dis[member] = dis[member].bind(dis)\n    }\n}\n\nand in your constructor() call it like:\nbindAllFunctions({ bindTo: this })\n\n \nThis issue is happening because this.changeContent and onClick={this.sendContent} are not bound to this of the instance of the component .\nThere is another solution (In addition to use bind() in the constructor() ) to use the arrow functions of ES6  which share the same lexical scope of the surrounding code and maintain this ,  so you can change your code in render() to be :\nrender() {\n    return (\n\n        <input type=\"text\"\n          onChange={ () => this.changeContent() } /> \n\n        <button onClick={ () => this.sendContent() }>Submit</button>\n\n    )\n  }\n\n \nHello if you want to dont care about binding yourself your function call. You can use 'class-autobind' and import it like that\nimport autobind from 'class-autobind';\n\nclass test extends Component {\n  constructor(props){\n  super(props);\n  autobind(this);\n}\n\nDont write autobind before the super call because it will not work\n \nIn case you want to keep the bind in constructor syntax, you can use the proposal-bind-operator and transform your code like follow :\nconstructor() {\n  this.changeContent = ::this.changeContent;\n}\n\nInstead of :\nconstructor() {\n  this.changeContent = this.changeContent.bind(this);\n}\n\nmuch simpler, no need of bind(this) or fatArrow.\n \nthis problem happen after react15.0 ,which event handler didn't auto bind to the component. so you must bind this to component manually whenever the event handler will be called.\n\nthere are several methods to solve the problem. but you need to know which method is best and why? In general, we recommend that binding your functions in the class constructor or use a arrow function.\n// method 1\uff1a use a arrow function\n    class ComponentA extends React.Component {\n      eventHandler = () => {\n        console.log(this)\n      }\n      render() {\n        return ( \n        <ChildComponent onClick={this.eventHandler} /> \n        );\n      }\n\n// method 2: Bind your functions in the class constructor.\n    class ComponentA extends React.Component {\n      constructor(props) {\n        super(props);\n        this.eventHandler = this.eventHandler.bind(this);\n      }\n      render() {\n        return ( \n        <ChildComponent onClick={this.eventHandler} /> \n        );\n      }\n\nthese two methods will not creates a new function when the component render everytime. so our ChildComponent will not reRender becaue of the new function props change, or may produce the performance problem.\n \nYou are using ES6 so functions will not bind to \"this\" context automatically. You have to manually bind the function to the context.\nconstructor(props) {\n  super(props);\n  this.changeContent = this.changeContent.bind(this);\n}\n\n \nYour functions needs binding in order to play with state or props in event handlers\nIn ES5, bind your event handler functions only in constructor but don't bind directly in render. If you do binding directly in render then it creates a new function every time your component renders and re-renders. So you should always bind it in constructor\nthis.sendContent = this.sendContent.bind(this)\n\nIn ES6, use arrow functions\nWhen you use arrow functions then you no need to do binding and you can also stay away from scope related issues\nsendContent = (event) => {\n\n}\n\n \nAlexandre Kirszenberg is correct, But another important thing to pay attention to , is where you put your binding. I have been stuck with a situation for days(probably because I'm a beginner), but unlike others, I knew about bind(Which I had applied already) so I just couldn't get my head around why I was still having those errors. It turns out that I had the bind in wrong order. \nAnother is also perhaps  the fact that I was calling the function within \"this.state\", which was not aware of the bind because it happened to be above the bind line,\nBelow is what I had(By the way this is my first ever posting, But I thought it was very important, as I couldn't find solution any where else):\nconstructor(props){\n    super(props);\n\n       productArray=//some array\n\n    this.state={ \n        // Create an Array  which will hold components to be displayed\n        proListing:productArray.map(product=>{return(<ProRow dele={this.this.popRow()} prodName={product.name} prodPrice={product.price}/>)})\n    }\n\n    this.popRow=this.popRow.bind(this);//This was the Issue, This line //should be kept above \"this.state\"\n\n \nSolution:\n\nWithout explicitly binding, bind with the method name you can use fat arrow functions syntax  ()=>{}  that maintains the context of this.\n\nimport React from 'react'\n\nclass SomeClass extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      inputContent: 'startValue'\n    }\n  }\n\n  sendContent = (e) => {\n    console.log('sending input content ',this.state.inputContent);\n  }\n\n  changeContent = (e) => {\n    this.setState({inputContent: e.target.value},()=>{\n      console.log('STATE:',this.state);\n    })\n  } \n\n  render() {\n    return (\n      <div>\n        <h4>The input form is here:</h4>\n        Title: \n        <input type=\"text\" value={this.state.inputContent} \n          onChange={this.changeContent} /> \n        <button onClick={this.sendContent}>Submit</button>\n      </div>\n    )\n  }\n}\n\nexport default SomeClass\n\n\n\nOther Solutions:\n\n\nBind your functions in the class constructor. \nBind your functions in the JSX Template escaping braces {}\n{this.methodName.bind(this)}\n\n \nbind(this) can fix this issue, and nowadays we can use another 2 ways to achieve this if you don't like using bind .\n1) As the traditional way, we can use bind(this) in the constructor, so that when we use the function as JSX callback, the context of this is the class itself.\nclass App1 extends React.Component {\n  constructor(props) {\n    super(props);\n    // If we comment out the following line,\n    // we will get run time error said `this` is undefined.\n    this.changeColor = this.changeColor.bind(this);\n  }\n\n  changeColor(e) {\n    e.currentTarget.style.backgroundColor = \"#00FF00\";\n    console.log(this.props);\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.changeColor}> button</button>\n      </div>\n    );\n  }\n}\n\n2) If we define the function as an attribute/field of the class with arrow function, we don't need to use bind(this) any more. \nclass App2 extends React.Component {\n  changeColor = e => {\n    e.currentTarget.style.backgroundColor = \"#00FF00\";\n    console.log(this.props);\n  };\n  render() {\n    return (\n      <div>\n        <button onClick={this.changeColor}> button 1</button>\n      </div>\n    );\n  }\n}\n\n3) If we use arrow function as JSX callback, we don't need to use bind(this) either. And further more, we can pass in the parameters. Looks good, isn't it? but its drawback is the performance concern, for details please refer ReactJS doco.\nclass App3 extends React.Component {\n  changeColor(e, colorHex) {\n    e.currentTarget.style.backgroundColor = colorHex;\n    console.log(this.props);\n  }\n  render() {\n    return (\n      <div>\n        <button onClick={e => this.changeColor(e, \"#ff0000\")}> button 1</button>\n      </div>\n    );\n  }\n}\n\nAnd I have created a Codepen to demo these code snippets, hope it helps.\n", "\nI'm building a React component that accepts a JSON data source and creates a sortable table.\nEach of the dynamic data rows has a unique key assigned to it but I'm still getting an error of: \n\nEach child in an array should have a unique \"key\" prop.\n  Check the render method of TableComponent.\n\nMy TableComponent render method returns:\n<table>\n  <thead key=\"thead\">\n    <TableHeader columns={columnNames}/>\n  </thead>\n  <tbody key=\"tbody\">\n    { rows }\n  </tbody>\n</table>\n\nThe TableHeader component is a single row and also has a unique key assigned to it.\nEach row in rows is built from a component with a unique key:\n<TableRowItem key={item.id} data={item} columns={columnNames}/>\n\nAnd the TableRowItem looks like this:\nvar TableRowItem = React.createClass({\n  render: function() {\n\n    var td = function() {\n        return this.props.columns.map(function(c) {\n          return <td key={this.props.data[c]}>{this.props.data[c]}</td>;\n        }, this);\n      }.bind(this);\n\n    return (\n      <tr>{ td(this.props.item) }</tr>\n    )\n  }\n});\n\nWhat is causing the unique key prop error? \n \nYou should add a key to each child as well as each element inside children.\nThis way React can handle the minimal DOM change. \nIn your code, each <TableRowItem key={item.id} data={item} columns={columnNames}/> is trying to render some children inside them without a key.\nCheck this example.\nTry removing the key={i} from the <b></b> element inside the div's (and check the console).\nIn the sample, if we don't give a key to the <b> element and we want to update only the object.city, React needs to re-render the whole row vs just the  element. \nHere is the code:\nvar data = [{name:'Jhon', age:28, city:'HO'},\n            {name:'Onhj', age:82, city:'HN'},\n            {name:'Nohj', age:41, city:'IT'}\n           ];\n\nvar Hello = React.createClass({\n\n    render: function() {\n\n      var _data = this.props.info;\n      console.log(_data);\n      return(\n        <div>\n            {_data.map(function(object, i){\n               return <div className={\"row\"} key={i}> \n                          {[ object.name ,\n                             // remove the key\n                             <b className=\"fosfo\" key={i}> {object.city} </b> , \n                             object.age\n                          ]}\n                      </div>; \n             })}\n        </div>\n       );\n    }\n});\n\nReact.render(<Hello info={data} />, document.body);\n\nThe answer posted by @Chris at the bottom goes into much more detail than this answer. \nPlease take a look at https://stackoverflow.com/a/43892905/2325522\nReact documentation on the importance of keys in reconciliation: Keys\n \nBe careful when iterating over arrays!!\nIt is a common misconception that using the index of the element in the array is an acceptable way of suppressing the error you are probably familiar with:\nEach child in an array should have a unique \"key\" prop.\n\nHowever, in many cases it is not! This is anti-pattern that can in some situations lead to unwanted behavior.\n\nUnderstanding the key prop\nReact uses the key prop to understand the component-to-DOM Element relation, which is then used for the reconciliation process. It is therefore very important that the key always remains unique, otherwise there is a good chance React will mix up the elements and mutate the incorrect one. It is also important that these keys remain static throughout all re-renders in order to maintain best performance.\nThat being said, one does not always need to apply the above, provided it is known that the array is completely static. However, applying best practices is encouraged whenever possible.\nA React developer said in this GitHub issue:\n\n\nkey is not really about performance, it's more about identity (which in turn leads to better performance). randomly assigned and changing values are not identity\nWe can't realistically provide keys [automatically] without knowing how your data is modeled. I would suggest maybe using some sort of hashing function if you don't have ids\nWe already have internal keys when we use arrays, but they are the index in the array. When you insert a new element, those keys are wrong.\n\n\nIn short, a key should be:\n\nUnique - A key cannot be identical to that of a sibling component.\nStatic - A key should not ever change between renders.\n\n\nUsing the key prop\nAs per the explanation above, carefully study the following samples and try to implement, when possible, the recommended approach.\n\nBad (Potentially)\n<tbody>\n    {rows.map((row, i) => {\n        return <ObjectRow key={i} />;\n    })}\n</tbody>\n\nThis is arguably the most common mistake seen when iterating over an array in React. This approach isn't technically \"wrong\", it's just... \"dangerous\" if you don't know what you are doing. If you are iterating through a static array then this is a perfectly valid approach (e.g. an array of links in your navigation menu). However, if you are adding, removing, reordering or filtering items, then you need to be careful. Take a look at this detailed explanation in the official documentation.\n\n\nclass MyApp extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      arr: [\"Item 1\"]\n    }\n  }\n  \n  click = () => {\n    this.setState({\n      arr: ['Item ' + (this.state.arr.length+1)].concat(this.state.arr),\n    });\n  }\n  \n  render() {\n    return(\n      <div>\n        <button onClick={this.click}>Add</button>\n        <ul>\n          {this.state.arr.map(\n            (item, i) => <Item key={i} text={\"Item \" + i}>{item + \" \"}</Item>\n          )}\n        </ul>\n      </div>\n    );\n  }\n}\n\nconst Item = (props) => {\n  return (\n    <li>\n      <label>{props.children}</label>\n      <input value={props.text} />\n    </li>\n  );\n}\n\nReactDOM.render(<MyApp />, document.getElementById(\"app\"));\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js\"></script>\n<div id=\"app\"></div>\n\n\n\nIn this snippet we are using a non-static array and we are not restricting ourselves to using it as a stack. This is an unsafe approach (you'll see why). Note how as we add items to the beginning of the array (basically unshift), the value for each <input> remains in place. Why? Because the key doesn't uniquely identify each item.\nIn other words, at first Item 1 has key={0}. When we add the second item, the top item becomes Item 2, followed by Item 1 as the second item. However, now Item 1 has key={1} and not key={0} anymore. Instead, Item 2 now has key={0}!!\nAs such, React thinks the <input> elements have not changed, because the Item with key 0 is always at the top!\nSo why is this approach only sometimes bad?\nThis approach is only risky if the array is somehow filtered, rearranged, or items are added/removed. If it is always static, then it's perfectly safe to use. For example, a navigation menu like [\"Home\", \"Products\", \"Contact us\"] can safely be iterated through with this method because you'll probably never add new links or rearrange them.\nIn short, here's when you can safely use the index as key:\n\nThe array is static and will never change.\nThe array is never filtered (display a subset of the array).\nThe array is never reordered.\nThe array is used as a stack or LIFO (last in, first out). In other words, adding can only be done at the end of the array (i.e push), and only the last item can ever be removed (i.e pop).\n\nHad we instead, in the snippet above, pushed the added item to the end of the array, the order for each existing item would always be correct.\n\nVery bad\n<tbody>\n    {rows.map((row) => {\n        return <ObjectRow key={Math.random()} />;\n    })}\n</tbody>\n\nWhile this approach will probably guarantee uniqueness of the keys, it will always force react to re-render each item in the list, even when this is not required. This a very bad solution as it greatly impacts performance. Not to mention that one cannot exclude the possibility of a key collision in the event that Math.random() produces the same number twice.\n\nUnstable keys (like those produced by Math.random()) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.\n\n\nVery good\n<tbody>\n    {rows.map((row) => {\n        return <ObjectRow key={row.uniqueId} />;\n    })}\n</tbody>\n\nThis is arguably the best approach because it uses a property that is unique for each item in the dataset. For example, if rows contains data fetched from a database, one could use the table's Primary Key (which typically is an auto-incrementing number).\n\nThe best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys\n\n\nGood\ncomponentWillMount() {\n  let rows = this.props.rows.map(item => { \n    return {uid: SomeLibrary.generateUniqueID(), value: item};\n  });\n}\n\n...\n\n<tbody>\n    {rows.map((row) => {\n        return <ObjectRow key={row.uid} />;\n    })}\n</tbody>\n\nThis is also a good approach. If your dataset does not contain any data that guarantees uniqueness (e.g. an array of arbitrary numbers), there is a chance of a key collision. In such cases, it is best to manually generate a unique identifier for each item in the dataset before iterating over it. Preferably when mounting the component or when the dataset is received (e.g. from props or from an async API call), in order to do this only once, and not each time the component re-renders. There are already a handful of libraries out there that can provide you such keys. Here is one example: react-key-index.\n \nThis may or not help someone, but it might be a quick reference. This is also similar to all the answers presented above.\nI have a lot of locations that generate list using the structure below:\nreturn (\n    {myList.map(item => (\n       <>\n          <div class=\"some class\"> \n             {item.someProperty} \n              ....\n          </div>\n       </>\n     )}\n )\n         \n\nAfter a little trial and error (and some frustrations), adding a key property to the outermost block resolved it. Also, note that the <> tag is now replaced with the <div> tag now.\nreturn (\n  \n    {myList.map((item, index) => (\n       <div key={index}>\n          <div class=\"some class\"> \n             {item.someProperty} \n              ....\n          </div>\n       </div>\n     )}\n )\n\nOf course, I've been naively using the iterating index (index) to populate the key value in the above example. Ideally, you'd use something which is unique to the list item.\n \nJust add the unique key to the your Components \ndata.map((marker)=>{\n    return(\n        <YourComponents \n            key={data.id}     // <----- unique key\n        />\n    );\n})\n\n \nCheck: key = undef !!!\nYou got also the warn message:\nEach child in a list should have a unique \"key\" prop.\n\nif your code is complete right, but if on\n<ObjectRow key={someValue} />\n\nsomeValue is undefined!!! Please check this first. You can save hours.\n \nWarning: Each child in an array or iterator should have a unique \"key\" prop.\nThis is a warning as for array items which we are going to iterate over will need a unique resemblance.\nReact handles iterating component rendering as arrays.\nBetter way to resolve this is provide index on the array items you are going to iterate over.for example: \nclass UsersState extends Component\n    {\n        state = {\n            users: [\n                {name:\"shashank\", age:20},\n                {name:\"vardan\", age:30},\n                {name:\"somya\", age:40}\n            ]\n        }\n    render()\n        {\n            return(\n                    <div>\n                        {\n                            this.state.users.map((user, index)=>{\n                                return <UserState key={index} age={user.age}>{user.name}</UserState>\n                            })\n                        }\n                    </div>\n                )\n        }\n\nindex is React built-in props.\n \nBest solution of define unique key in react:\ninside the map you initialized the name post then key define by key={post.id} or in my code you see i define the name item then i define key by key={item.id}:\n\n\n<div className=\"container\">\r\n                {posts.map(item =>(\r\n\r\n                    <div className=\"card border-primary mb-3\" key={item.id}>\r\n                        <div className=\"card-header\">{item.name}</div>\r\n                    <div className=\"card-body\" >\r\n                <h4 className=\"card-title\">{item.username}</h4>\r\n                <p className=\"card-text\">{item.email}</p>\r\n                    </div>\r\n                  </div>\r\n                ))}\r\n            </div>\n\n\n\n \nI was running into this error message because of <></> being returned for some items in the array when instead null needs to be returned.\n \nThis is a warning, But addressing this will make Reacts rendering much FASTER,\nThis is because React needs to uniquely identify each items in the list. Lets say if the state of an element of that list changes in Reacts Virtual DOM then React needs to figure out which element got changed and where in the DOM it needs to change so that browser DOM will be in sync with the Reacts Virtual DOM.\nAs a solution just introduce a key attribute to each li tag. This key should be a unique value to each element.\n \nvar TableRowItem = React.createClass({\n  render: function() {\n\n    var td = function() {\n        return this.props.columns.map(function(c, i) {\n          return <td key={i}>{this.props.data[c]}</td>;\n        }, this);\n      }.bind(this);\n\n    return (\n      <tr>{ td(this.props.item) }</tr>\n    )\n  }\n});\n\nThis will sove the problem. \n \nIn ReactJS if you are rendering an array of elements you should have a unique key for each those elements. Normally those kinda situations are creating a list.\nExample:\nfunction List() {\n  const numbers = [0,1,2,3];\n \n  return (\n    <ul>{numbers.map((n) => <li> {n} </li>)}</ul>\n  );\n}\n\n ReactDOM.render(\n  <List />,\n  document.getElementById('root')\n);\n\nIn the above example, it creates a dynamic list using li tag, so since li tag does not have a unique key it shows an error.\nAfter fixed:\nfunction List() {\n  const numbers = [0,1,2,3];\n \n  return (\n    <ul>{numbers.map((n) => <li key={n}> {n} </li>)}</ul>\n  );\n}\n\n ReactDOM.render(\n  <List />,\n  document.getElementById('root')\n);\n\nAlternative solution when use map when you don't have a unique key (this is not recommended by react eslint ):\nfunction List() {\n  const numbers = [0,1,2,3,4,4];\n \n  return (\n    <ul>{numbers.map((n,i) => <li key={i}> {n} </li>)}</ul>\n  );\n}\n\n ReactDOM.render(\n  <List />,\n  document.getElementById('root')\n);\n\nLive example: https://codepen.io/spmsupun/pen/wvWdGwG\n \nI fixed this using Guid for each key like this:\nGenerating Guid:\nguid() {\n    return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' +\n        this.s4() + '-' + this.s4() + this.s4() + this.s4();\n}\n\ns4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n        .toString(16)\n        .substring(1);\n}\n\nAnd then assigning this value to markers:\n{this.state.markers.map(marker => (\n              <MapView.Marker\n                  key={this.guid()}\n                  coordinate={marker.coordinates}\n                  title={marker.title}\n              />\n          ))}\n\n", "\nI'm trying to organize my state by using nested property like this:\nthis.state = {\n   someProperty: {\n      flag:true\n   }\n}\n\nBut updating state like this,\nthis.setState({ someProperty.flag: false });\n\ndoesn't work. How can this be done correctly?\n \nIn order to setState for a nested object you can follow the below approach as I think setState doesn't handle nested updates.\nvar someProperty = {...this.state.someProperty}\nsomeProperty.flag = true;\nthis.setState({someProperty})\n\nThe idea is to create a dummy object perform operations on it and then replace the component's state with the updated object\nNow, the spread operator creates only one level nested copy of the object. If your state is highly nested like:\nthis.state = {\n   someProperty: {\n      someOtherProperty: {\n          anotherProperty: {\n             flag: true\n          }\n          ..\n      }\n      ...\n   }\n   ...\n}\n\nYou could setState using spread operator at each level like\nthis.setState(prevState => ({\n    ...prevState,\n    someProperty: {\n        ...prevState.someProperty,\n        someOtherProperty: {\n            ...prevState.someProperty.someOtherProperty, \n            anotherProperty: {\n               ...prevState.someProperty.someOtherProperty.anotherProperty,\n               flag: false\n            }\n        }\n    }\n}))\n\nHowever the above syntax get every ugly as the state becomes more and more nested and hence I recommend you to use immutability-helper package to update the state. \nSee this answer on how to update state with immutability helper. \n \nTo write it in one line\nthis.setState({ someProperty: { ...this.state.someProperty, flag: false} });\n\n \nSometimes direct answers are not the best ones :)\nShort version:\nthis code\nthis.state = {\n    someProperty: {\n        flag: true\n    }\n}\n\nshould be simplified as something like\nthis.state = {\n    somePropertyFlag: true\n}\n\nLong version:\nCurrently you shouldn't want to work with nested state in React. Because React is not oriented to work with nested states and all solutions proposed here look as hacks. They don't use the framework but fight with it. They suggest to write not so clear code for doubtful purpose of grouping some properties. So they are very interesting as an answer to the challenge but practically useless.\nLets imagine the following state:\n{\n    parent: {\n        child1: 'value 1',\n        child2: 'value 2',\n        ...\n        child100: 'value 100'\n    }\n}\n\nWhat will happen if you change just a value of child1? React will not re-render the view because it uses shallow comparison and it will find that parent property didn't change. BTW mutating the state object directly is considered to be a bad practice in general.\nSo you need to re-create the whole parent object. But in this case we will meet another problem. React will think that all children have changed their values and will re-render all of them. Of course it is not good for performance.\nIt is still possible to solve that problem by writing some complicated logic in shouldComponentUpdate() but I would prefer to stop here and use simple solution from the short version.\n \nDisclaimer\n\nNested State in React is wrong design\nRead this excellent answer.\n\n\u00a0\n\nReasoning behind this answer:\nReact's setState is just a built-in convenience, but you soon realise\n  that it has its limits. Using custom properties and intelligent use of\n  forceUpdate gives you much more.\n  eg:  \nclass MyClass extends React.Component {\n    myState = someObject\n    inputValue = 42\n...\n\nMobX, for example, ditches state completely and uses custom observable properties.\nUse Observables instead of state in React components. \n\n\u00a0\n\nthe answer to your misery - see example here\nThere is another shorter way to update whatever nested property.\nthis.setState(state => {\n  state.nested.flag = false\n  state.another.deep.prop = true\n  return state\n})\n\nOn one line\n this.setState(state => (state.nested.flag = false, state))\n\nnote: This here is Comma operator ~MDN, see it in action here (Sandbox).\nIt is similar to (though this doesn't change state reference)\nthis.state.nested.flag = false\nthis.forceUpdate()\n\nFor the subtle difference in this context between forceUpdate and setState see the linked example.\nOf course this is abusing some core principles, as the state should be read-only, but since you are immediately discarding the old state and replacing it with new state, it is completely ok.\nWarning\nEven though the component containing the state will update and rerender properly (except this gotcha), the props will fail to propagate to children (see Spymaster's comment below). Only use this technique if you know what you are doing.\nFor example, you may pass a changed flat prop that is updated and passed easily.\nrender(\n  //some complex render with your nested state\n  <ChildComponent complexNestedProp={this.state.nested} pleaseRerender={Math.random()}/>\n)\n\nNow even though reference for complexNestedProp did not change (shouldComponentUpdate)\nthis.props.complexNestedProp === nextProps.complexNestedProp\n\nthe component will rerender whenever parent component updates, which is the case after calling this.setState or this.forceUpdate in the parent.\nEffects of mutating the state\nUsing nested state and mutating the state directly is dangerous because different objects might hold (intentionally or not) different (older) references to the state and might not necessarily know when to update (for example when using PureComponent or if shouldComponentUpdate is implemented to return false) OR are intended to display old data like in the example below.\n\nImagine a timeline that is supposed to render historic data, mutating the data under the hand will result in unexpected behaviour as it will also change previous items.\n\n\n\nAnyway here you can see that Nested PureChildClass it not rerendered due to props failing to propagate.\n \nIf you are using ES2015 you have access to the Object.assign. You can use it as follows to update a nested object.\nthis.setState({\n  someProperty: Object.assign({}, this.state.someProperty, {flag: false})\n});\n\nYou merge the updated properties with the existing and use the returned object to update the state.\nEdit: Added an empty object as target to the assign function to make sure the state isn't mutated directly as carkod pointed out.\n \nconst newState = Object.assign({}, this.state);\nnewState.property.nestedProperty = \"new value\";\nthis.setState(newState);\n\n \nThere are many libraries to help with this. For example, using immutability-helper:\nimport update from 'immutability-helper';\n\nconst newState = update(this.state, {\n  someProperty: {flag: {$set: false}},\n};\nthis.setState(newState);\n\nUsing lodash/fp set:\nimport {set} from 'lodash/fp';\n\nconst newState = set([\"someProperty\", \"flag\"], false, this.state);\n\nUsing lodash/fp merge:\nimport {merge} from 'lodash/fp';\n\nconst newState = merge(this.state, {\n  someProperty: {flag: false},\n});\n\n \nWe use Immer https://github.com/mweststrate/immer to handle these kinds of issues.\nJust replaced this code in one of our components\nthis.setState(prevState => ({\n   ...prevState,\n        preferences: {\n            ...prevState.preferences,\n            [key]: newValue\n        }\n}));\n\nWith this\nimport produce from 'immer';\n\nthis.setState(produce(draft => {\n    draft.preferences[key] = newValue;\n}));\n\nWith immer you handle your state as a \"normal object\".\nThe magic happens behind the scene with proxy objects.\n \nHere's a variation on the first answer given in this thread which doesn't require any extra packages, libraries or special functions.\nstate = {\n  someProperty: {\n    flag: 'string'\n  }\n}\n\nhandleChange = (value) => {\n  const newState = {...this.state.someProperty, flag: value}\n  this.setState({ someProperty: newState })\n}\n\nIn order to set the state of a specific nested field, you have set the whole object. I did this by creating a variable, newState and spreading the contents of the current state into it first using the ES2015 spread operator. Then, I replaced the value of this.state.flag with the new value (since I set flag: value after I spread the current state into the object, the flag field in the current state is overridden). Then, I simply set the state of someProperty to my newState object.\n \nAlthough nesting isn't really how you should treat a component state, sometimes for something easy for single tier nesting.\nFor a state like this\nstate = {\n contact: {\n  phone: '888-888-8888',\n  email: 'test@test.com'\n }\n address: {\n  street:''\n },\n occupation: {\n }\n}\n\nA re-useable method ive used would look like this.\nhandleChange = (obj) => e => {\n  let x = this.state[obj];\n  x[e.target.name] = e.target.value;\n  this.setState({ [obj]: x });\n};\n\nthen just passing in the obj name for each nesting you want to address...\n<TextField\n name=\"street\"\n onChange={handleChange('address')}\n />\n\n \nI used this solution.\nIf you have a  nested state like this:\n   this.state = {\n          formInputs:{\n            friendName:{\n              value:'',\n              isValid:false,\n              errorMsg:''\n            },\n            friendEmail:{\n              value:'',\n              isValid:false,\n              errorMsg:''\n            }\n}\n\nyou can declare the handleChange function that copy current status and re-assigns it with changed values\nhandleChange(el) {\n    let inputName = el.target.name;\n    let inputValue = el.target.value;\n\n    let statusCopy = Object.assign({}, this.state);\n    statusCopy.formInputs[inputName].value = inputValue;\n\n    this.setState(statusCopy);\n  }\n\nhere the html with the event listener \n<input type=\"text\" onChange={this.handleChange} \" name=\"friendName\" />\n\n \nCreate a copy of the state:\nlet someProperty = JSON.parse(JSON.stringify(this.state.someProperty))\n\nmake changes in this object:\nsomeProperty.flag = \"false\"\n\nnow update the state\nthis.setState({someProperty})\n\n \nAlthough you asked about a state of class-based React component, the same problem exists with useState hook. Even worse: useState hook does not accept partial updates. So this question became very relevant when useState hook was introduced.\nI have decided to post the following answer to make sure the question covers more modern scenarios where the useState hook is used:\nIf you have got:\nconst [state, setState] = useState({ someProperty: { flag: true, otherNestedProp: 1 }, otherProp: 2 })\n\nyou can set the nested property by cloning the current and patching the required segments of the data, for example:\nsetState(current => { ...current, someProperty: { ...current.someProperty, flag: false } });\n\nOr you can use Immer library to simplify the cloning and patching of the object.\nOr you can use Hookstate library (disclaimer: I am an author) to simply the management of complex (local and global) state data entirely and improve the performance (read: not to worry about rendering optimization):\nimport { useStateLink } from '@hookstate/core' \nconst state = useStateLink({ someProperty: { flag: true, otherNestedProp: 1 }, otherProp: 2 })\n\nget the field to render:\nstate.nested.someProperty.nested.flag.get()\n// or \nstate.get().someProperty.flag\n\nset the nested field:\nstate.nested.someProperty.nested.flag.set(false)\n\nHere is the Hookstate example, where the state is deeply / recursively nested in tree-like data structure.\n \nTwo other options not mentioned yet:\n\nIf you have deeply nested state, consider if you can restructure the child objects to sit at the root. This makes the data easier to update. \nThere are many handy libraries available for handling immutable state listed in the Redux docs. I recommend Immer since it allows you to write code in a mutative manner but handles the necessary cloning behind the scenes. It also freezes the resulting object so you can't accidentally mutate it later.\n\n \nTo make things generic, I worked on @ShubhamKhatri's and @Qwerty's answers.\nstate object\nthis.state = {\n  name: '',\n  grandParent: {\n    parent1: {\n      child: ''\n    },\n    parent2: {\n      child: ''\n    }\n  }\n};\n\ninput controls\n<input\n  value={this.state.name}\n  onChange={this.updateState}\n  type=\"text\"\n  name=\"name\"\n/>\n<input\n  value={this.state.grandParent.parent1.child}\n  onChange={this.updateState}\n  type=\"text\"\n  name=\"grandParent.parent1.child\"\n/>\n<input\n  value={this.state.grandParent.parent2.child}\n  onChange={this.updateState}\n  type=\"text\"\n  name=\"grandParent.parent2.child\"\n/>\n\nupdateState method\nsetState as @ShubhamKhatri's answer\nupdateState(event) {\n  const path = event.target.name.split('.');\n  const depth = path.length;\n  const oldstate = this.state;\n  const newstate = { ...oldstate };\n  let newStateLevel = newstate;\n  let oldStateLevel = oldstate;\n\n  for (let i = 0; i < depth; i += 1) {\n    if (i === depth - 1) {\n      newStateLevel[path[i]] = event.target.value;\n    } else {\n      newStateLevel[path[i]] = { ...oldStateLevel[path[i]] };\n      oldStateLevel = oldStateLevel[path[i]];\n      newStateLevel = newStateLevel[path[i]];\n    }\n  }\n  this.setState(newstate);\n}\n\nsetState as @Qwerty's answer\nupdateState(event) {\n  const path = event.target.name.split('.');\n  const depth = path.length;\n  const state = { ...this.state };\n  let ref = state;\n  for (let i = 0; i < depth; i += 1) {\n    if (i === depth - 1) {\n      ref[path[i]] = event.target.value;\n    } else {\n      ref = ref[path[i]];\n    }\n  }\n  this.setState(state);\n}\n\nNote: These above methods won't work for arrays\n \nI take very seriously the concerns already voiced around creating a complete copy of your component state. With that said, I would strongly suggest Immer.\nimport produce from 'immer';\n\n<Input\n  value={this.state.form.username}\n  onChange={e => produce(this.state, s => { s.form.username = e.target.value }) } />\n\nThis should work for React.PureComponent (i.e. shallow state comparisons by React) as Immer cleverly uses a proxy object to efficiently copy an arbitrarily deep state tree. Immer is also more typesafe compared to libraries like Immutability Helper, and is ideal for Javascript and Typescript users alike.\n\nTypescript utility function\nfunction setStateDeep<S>(comp: React.Component<any, S, any>, fn: (s: \nDraft<Readonly<S>>) => any) {\n  comp.setState(produce(comp.state, s => { fn(s); }))\n}\n\nonChange={e => setStateDeep(this, s => s.form.username = e.target.value)}\n\n \nstateUpdate = () => {\n    let obj = this.state;\n    if(this.props.v12_data.values.email) {\n      obj.obj_v12.Customer.EmailAddress = this.props.v12_data.values.email\n    }\n    this.setState(obj)\n}\n\n \nI found this to work for me, having a project form in my case where for example you have an id, and a name and I'd rather maintain state for a nested project.\nreturn (\n  <div>\n      <h2>Project Details</h2>\n      <form>\n        <Input label=\"ID\" group type=\"number\" value={this.state.project.id} onChange={(event) => this.setState({ project: {...this.state.project, id: event.target.value}})} />\n        <Input label=\"Name\" group type=\"text\" value={this.state.project.name} onChange={(event) => this.setState({ project: {...this.state.project, name: event.target.value}})} />\n      </form> \n  </div>\n)\n\nLet me know! \n \nSomething like this might suffice,\nconst isObject = (thing) => {\n    if(thing && \n        typeof thing === 'object' &&\n        typeof thing !== null\n        && !(Array.isArray(thing))\n    ){\n        return true;\n    }\n    return false;\n}\n\n/*\n  Call with an array containing the path to the property you want to access\n  And the current component/redux state.\n\n  For example if we want to update `hello` within the following obj\n  const obj = {\n     somePrimitive:false,\n     someNestedObj:{\n        hello:1\n     }\n  }\n\n  we would do :\n  //clone the object\n  const cloned = clone(['someNestedObj','hello'],obj)\n  //Set the new value\n  cloned.someNestedObj.hello = 5;\n\n*/\nconst clone = (arr, state) => {\n    let clonedObj = {...state}\n    const originalObj = clonedObj;\n    arr.forEach(property => {\n        if(!(property in clonedObj)){\n            throw new Error('State missing property')\n        }\n\n        if(isObject(clonedObj[property])){\n            clonedObj[property] = {...originalObj[property]};\n            clonedObj = clonedObj[property];\n        }\n    })\n    return originalObj;\n}\n\nconst nestedObj = {\n    someProperty:true,\n    someNestedObj:{\n        someOtherProperty:true\n    }\n}\n\nconst clonedObj = clone(['someProperty'], nestedObj);\nconsole.log(clonedObj === nestedObj) //returns false\nconsole.log(clonedObj.someProperty === nestedObj.someProperty) //returns true\nconsole.log(clonedObj.someNestedObj === nestedObj.someNestedObj) //returns true\n\nconsole.log()\nconst clonedObj2 = clone(['someProperty','someNestedObj','someOtherProperty'], nestedObj);\nconsole.log(clonedObj2 === nestedObj) // returns false\nconsole.log(clonedObj2.someNestedObj === nestedObj.someNestedObj) //returns false\n//returns true (doesn't attempt to clone because its primitive type)\nconsole.log(clonedObj2.someNestedObj.someOtherProperty === nestedObj.someNestedObj.someOtherProperty) \n\n \nI know it is an old question but still wanted to share how i achieved this. Assuming state in constructor looks like this:\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      loading: false,\n      user: {\n        email: \"\"\n      },\n      organization: {\n        name: \"\"\n      }\n    };\n\n    this.handleChange = this.handleChange.bind(this);\n  }\n\nMy handleChange function is like this:\n  handleChange(e) {\n    const names = e.target.name.split(\".\");\n    const value = e.target.type === \"checkbox\" ? e.target.checked : e.target.value;\n    this.setState((state) => {\n      state[names[0]][names[1]] = value;\n      return {[names[0]]: state[names[0]]};\n    });\n  }\n\nAnd make sure you name inputs accordingly:\n<input\n   type=\"text\"\n   name=\"user.email\"\n   onChange={this.handleChange}\n   value={this.state.user.firstName}\n   placeholder=\"Email Address\"\n/>\n\n<input\n   type=\"text\"\n   name=\"organization.name\"\n   onChange={this.handleChange}\n   value={this.state.organization.name}\n   placeholder=\"Organization Name\"\n/>\n\n \nI do nested updates with a reduce search:\nExample:\nThe nested variables in state:\nstate = {\n    coords: {\n        x: 0,\n        y: 0,\n        z: 0\n    }\n}\n\nThe function:\nhandleChange = nestedAttr => event => {\n  const { target: { value } } = event;\n  const attrs = nestedAttr.split('.');\n\n  let stateVar = this.state[attrs[0]];\n  if(attrs.length>1)\n    attrs.reduce((a,b,index,arr)=>{\n      if(index==arr.length-1)\n        a[b] = value;\n      else if(a[b]!=null)\n        return a[b]\n      else\n        return a;\n    },stateVar);\n  else\n    stateVar = value;\n\n  this.setState({[attrs[0]]: stateVar})\n}\n\nUse:\n<input\nvalue={this.state.coords.x}\nonChange={this.handleTextChange('coords.x')}\n/>\n\n \nThis is my initialState\n    const initialStateInput = {\n        cabeceraFamilia: {\n            familia: '',\n            direccion: '',\n            telefonos: '',\n            email: ''\n        },\n        motivoConsulta: '',\n        fechaHora: '',\n        corresponsables: [],\n    }\n\nThe hook or you can replace it with the state (class component)\nconst [infoAgendamiento, setInfoAgendamiento] = useState(initialStateInput);\n\nThe method for handleChange\nconst actualizarState = e => {\n    const nameObjects = e.target.name.split('.');\n    const newState = setStateNested(infoAgendamiento, nameObjects, e.target.value);\n    setInfoAgendamiento({...newState});\n};\n\nMethod for set state with nested states\nconst setStateNested = (state, nameObjects, value) => {\n    let i = 0;\n    let operativeState = state;\n    if(nameObjects.length > 1){\n        for (i = 0; i < nameObjects.length - 1; i++) {\n            operativeState = operativeState[nameObjects[i]];\n        }\n    }\n    operativeState[nameObjects[i]] = value;\n    return state;\n}\n\nFinally this is the input that I use\n<input type=\"text\" className=\"form-control\" name=\"cabeceraFamilia.direccion\" placeholder=\"Direcci\u00f3n\" defaultValue={infoAgendamiento.cabeceraFamilia.direccion} onChange={actualizarState} />\n\n \nIf you are using formik in your project it has some easy way to handle this stuff. Here is the most easiest way to do with formik.\nFirst set your initial values inside the formik initivalues attribute or in the react. state\nHere, the initial values is define in react state\n   state = { \n     data: {\n        fy: {\n            active: \"N\"\n        }\n     }\n   }\n\ndefine above initialValues for formik field inside formik initiValues attribute\n<Formik\n initialValues={this.state.data}\n onSubmit={(values, actions)=> {...your actions goes here}}\n>\n{({ isSubmitting }) => (\n  <Form>\n    <Field type=\"checkbox\" name=\"fy.active\" onChange={(e) => {\n      const value = e.target.checked;\n      if(value) setFieldValue('fy.active', 'Y')\n      else setFieldValue('fy.active', 'N')\n    }}/>\n  </Form>\n)}\n</Formik>\n\nMake a console to the check the state updated into string instead of booleanthe formik setFieldValue function to set the state or go with react debugger tool to see the changes iniside formik state values.\n \ntry this code:\nthis.setState({ someProperty: {flag: false} });\n\n \nThis is clearly not the right or best way to do, however it is cleaner to my view:\nthis.state.hugeNestedObject = hugeNestedObject; \nthis.state.anotherHugeNestedObject = anotherHugeNestedObject; \n\nthis.setState({})\n\nHowever, React itself should iterate thought nested objects and update state and DOM accordingly which is not there yet.\n \ni saw following in a book:\nthis.setState(state => state.someProperty.falg = false);\n\nbut i'm not sure if it's right..\n", "\nI want to add an element to the end of a state array, is this the correct way to do it?\nthis.state.arrayvar.push(newelement);\nthis.setState({arrayvar:this.state.arrayvar});\n\nI am concerned that modifying the array in-place with push might cause trouble - is it safe?\nThe alternative of making a copy of the array, and setStateing that seems wasteful.\n \nThe React docs says:\n\nTreat this.state as if it were immutable.\n\nYour push will mutate the state directly and that could potentially lead to error prone code, even if you are \"resetting\" the state again afterwards. F.ex, it could lead to that some lifecycle methods like componentDidUpdate won\u2019t trigger.\nThe recommended approach in later React versions is to use an updater function when modifying states to prevent race conditions:\nthis.setState(prevState => ({\n  arrayvar: [...prevState.arrayvar, newelement]\n}))\n\nThe memory \"waste\" is not an issue compared to the errors you might face using non-standard state modifications.\nAlternative syntax for earlier React versions\nYou can use concat to get a clean syntax since it returns a new array:\nthis.setState({ \n  arrayvar: this.state.arrayvar.concat([newelement])\n})\n\nIn ES6 you can use the Spread Operator:\nthis.setState({\n  arrayvar: [...this.state.arrayvar, newelement]\n})\n\n \nEasiest, if you are using ES6.\ninitialArray = [1, 2, 3];\n\nnewArray = [ ...initialArray, 4 ]; // --> [1,2,3,4]\n\nNew array will be [1,2,3,4]\nto update your state in React\nthis.setState({\n  arrayvar:[...this.state.arrayvar, newelement]\n});\n\nLearn more about array destructuring\n \nThe simplest way with ES6:\nthis.setState(prevState => ({\n    array: [...prevState.array, newElement]\n}))\n\n \nReact may batch updates, and therefore the correct approach is to provide setState with a function that performs the update.\nFor the React update addon, the following will reliably work:\nthis.setState( state => update(state, {array: {$push: [4]}}) );\n\nor for concat():\nthis.setState( state => ({\n    array: state.array.concat([4])\n}));\n\nThe following shows what https://jsbin.com/mofekakuqi/7/edit?js,output as an example of what happens if you get it wrong.\nThe setTimeout() invocation correctly adds three items because React will not batch updates within a setTimeout callback (see https://groups.google.com/d/msg/reactjs/G6pljvpTGX0/0ihYw2zK9dEJ).\nThe buggy onClick will only add \"Third\", but the fixed one, will add F, S and T as expected.\nclass List extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: []\n    }\n\n    setTimeout(this.addSome, 500);\n  }\n\n  addSome = () => {\n      this.setState(\n        update(this.state, {array: {$push: [\"First\"]}}));\n      this.setState(\n        update(this.state, {array: {$push: [\"Second\"]}}));\n      this.setState(\n        update(this.state, {array: {$push: [\"Third\"]}}));\n    };\n\n  addSomeFixed = () => {\n      this.setState( state => \n        update(state, {array: {$push: [\"F\"]}}));\n      this.setState( state => \n        update(state, {array: {$push: [\"S\"]}}));\n      this.setState( state => \n        update(state, {array: {$push: [\"T\"]}}));\n    };\n\n\n\n  render() {\n\n    const list = this.state.array.map((item, i) => {\n      return <li key={i}>{item}</li>\n    });\n       console.log(this.state);\n\n    return (\n      <div className='list'>\n        <button onClick={this.addSome}>add three</button>\n        <button onClick={this.addSomeFixed}>add three (fixed)</button>\n        <ul>\n        {list}\n        </ul>\n      </div>\n    );\n  }\n};\n\n\nReactDOM.render(<List />, document.getElementById('app'));\n\n \nAs @nilgun mentioned in the comment, you can use the react immutability helpers. I've found this to be super useful.\nFrom the docs:\nSimple push\nvar initialArray = [1, 2, 3];\nvar newArray = update(initialArray, {$push: [4]}); // => [1, 2, 3, 4]\n\ninitialArray is still [1, 2, 3].\n \nIf you are using functional component please use this as below.\nconst [chatHistory, setChatHistory] = useState([]); // define the state\n\nconst chatHistoryList = [...chatHistory, {'from':'me', 'message':e.target.value}]; // new array need to update\nsetChatHistory(chatHistoryList); // update the state\n\n \nFor added new element into the array, push() should be the answer.\nFor remove element and update state of array, below code works for me. splice(index, 1) can not work.\nconst [arrayState, setArrayState] = React.useState<any[]>([]);\n...\n\n// index is the index for the element you want to remove\nconst newArrayState = arrayState.filter((value, theIndex) => {return index !== theIndex});\nsetArrayState(newArrayState);\n\n \nThis worked for me to add an array within an array\nthis.setState(prevState => ({\n    component: prevState.component.concat(new Array(['new', 'new']))\n}));\n\n \nHere's a 2020, Reactjs Hook example that I thought could help others. I am using it to add new rows to a Reactjs table. Let me know if I could improve on something.\nAdding a new element to a functional state component:\nDefine the state data:\n    const [data, setData] = useState([\n        { id: 1, name: 'John', age: 16 },\n        { id: 2, name: 'Jane', age: 22 },\n        { id: 3, name: 'Josh', age: 21 }\n    ]);\n\nHave a button trigger a function to add a new element\n<Button\n    // pass the current state data to the handleAdd function so we can append to it.\n    onClick={() => handleAdd(data)}>\n    Add a row\n</Button>\n\nfunction handleAdd(currentData) {\n\n        // return last data array element\n        let lastDataObject = currentTableData[currentTableData.length - 1]\n\n        // assign last elements ID to a variable.\n        let lastID = Object.values(lastDataObject)[0] \n\n        // build a new element with a new ID based off the last element in the array\n        let newDataElement = {\n            id: lastID + 1,\n            name: 'Jill',\n            age: 55,\n        }\n\n        // build a new state object \n        const newStateData = [...currentData, newDataElement ]\n\n        // update the state\n        setData(newStateData);\n\n        // print newly updated state\n        for (const element of newStateData) {\n            console.log('New Data: ' + Object.values(element).join(', '))\n        }\n\n}\n\n \nOption one is using\nthis.setState(prevState => ({\n  arrayvar: [...prevState.arrayvar, newelement]\n}))\n\nOption 2:\nthis.setState({ \n  arrayvar: this.state.arrayvar.concat([newelement])\n})\n\nOption 3:\nfunction abc() {\n   const data = this.state.myarray;\n   data.push({a:1,b:2})\n   this.setState({myarray:data})\n}\n\n \nthis.setState({\n  arrayvar: [...this.state.arrayvar, ...newelement]\n})\n\n \nI am trying to push value in an array state and set value like this and define state array and push value by map function.\n this.state = {\n        createJob: [],\n        totalAmount:Number=0\n    }\n\n\n your_API_JSON_Array.map((_) => {\n                this.setState({totalAmount:this.state.totalAmount += _.your_API_JSON.price})\n                this.state.createJob.push({ id: _._id, price: _.your_API_JSON.price })\n                return this.setState({createJob: this.state.createJob})\n            })\n\n \n//------------------code is return in typescript \n\nconst updateMyData1 = (rowIndex:any, columnId:any, value:any) => {\n\n    setItems(old => old.map((row, index) => {\n        if (index === rowIndex) {\n        return Object.assign(Object.assign({}, old[rowIndex]), { [columnId]: value });\n    }\n    return row;\n}));\n\n \nThis code work for me:\nfetch('http://localhost:8080')\n  .then(response => response.json())\n  .then(json => {\n    this.setState({mystate: this.state.mystate.push.apply(this.state.mystate, json)})\n  })\n\n", "\nI'm trying to send data from a child component to it's parent as follow:\nconst ParentComponent = React.createClass({\n    getInitialState() {\n        return {\n            language: '',\n        };\n    },\n    handleLanguageCode: function(langValue) {\n        this.setState({language: langValue});\n    },\n\n    render() {\n         return (\n                <div className=\"col-sm-9\" >\n                    <SelectLanguage onSelectLanguage={this.handleLanguage}/> \n                </div>\n        );\n});\n\nand here is the child component:\nexport const SelectLanguage = React.createClass({\n    getInitialState: function(){\n        return{\n            selectedCode: '',\n            selectedLanguage: '',\n        };\n    },\n\n    handleLangChange: function (e) {\n        var lang = this.state.selectedLanguage;\n        var code = this.state.selectedCode;\n        this.props.onSelectLanguage({selectedLanguage: lang});   \n        this.props.onSelectLanguage({selectedCode: code});           \n    },\n\n    render() {\n        var json = require(\"json!../languages.json\");\n        var jsonArray = json.languages;\n        return (\n            <div >\n                <DropdownList ref='dropdown'\n                    data={jsonArray} \n                    value={this.state.selectedLanguage}\n                    caseSensitive={false} \n                    minLength={3}\n                    filter='contains'\n                    onChange={this.handleLangChange} />\n            </div>            \n        );\n    }\n});\n\nWhat I need is to get the selected value by user in the parent component. I'm getting this error:\nUncaught TypeError: this.props.onSelectLanguage is not a function\n\nCan anyone help me to find the problem? \nP.S. The child component is creating a dropdown from a json file, and I need the dropdown list to show both elements of the json array next to each other(like: \"aaa,english\" as the first choice!) \n{  \n   \"languages\":[  \n      [  \n         \"aaa\",\n         \"english\"\n      ],\n      [  \n         \"aab\",\n         \"swedish\"\n      ],\n}\n\n \nThis should work. While sending the prop back you are sending that as an object rather send that as a value or alternatively use it as an object in the parent component. Secondly you need to format your json object to contain name value pairs and use valueField and textField attribute of DropdownList\nShort Answer\nParent: \n<div className=\"col-sm-9\">\n     <SelectLanguage onSelectLanguage={this.handleLanguage} /> \n</div>\n\nChild:\nhandleLangChange = () => {\n    var lang = this.dropdown.value;\n    this.props.onSelectLanguage(lang);            \n}\n\n\nDetailed:\nEDIT:\nConsidering React.createClass is deprecated from v16.0 onwards, It is better to go ahead and create a React Component by extending React.Component. Passing data from child to parent component with this syntax will look like\nParent\nclass ParentComponent extends React.Component {\n\n    state = { language: '' }\n\n    handleLanguage = (langValue) => {\n        this.setState({language: langValue});\n    }\n\n    render() {\n         return (\n                <div className=\"col-sm-9\">\n                    <SelectLanguage onSelectLanguage={this.handleLanguage} /> \n                </div>\n        )\n     }\n}\n\nChild\nvar json = require(\"json!../languages.json\");\nvar jsonArray = json.languages;\n\nexport class SelectLanguage extends React.Component {\n    state = {\n            selectedCode: '',\n            selectedLanguage: jsonArray[0],\n        }\n\n    handleLangChange = () => {\n        var lang = this.dropdown.value;\n        this.props.onSelectLanguage(lang);            \n    }\n\n    render() {\n        return (\n            <div>\n                <DropdownList ref={(ref) => this.dropdown = ref}\n                    data={jsonArray} \n                    valueField='lang' textField='lang'\n                    caseSensitive={false} \n                    minLength={3}\n                    filter='contains'\n                    onChange={this.handleLangChange} />\n            </div>            \n        );\n    }\n}\n\n\nUsing createClass syntax which the OP used in his answer\nParent\nconst ParentComponent = React.createClass({\n    getInitialState() {\n        return {\n            language: '',\n        };\n    },\n\n    handleLanguage: function(langValue) {\n        this.setState({language: langValue});\n    },\n\n    render() {\n         return (\n                <div className=\"col-sm-9\">\n                    <SelectLanguage onSelectLanguage={this.handleLanguage} /> \n                </div>\n        );\n});\n\nChild\nvar json = require(\"json!../languages.json\");\nvar jsonArray = json.languages;\n\nexport const SelectLanguage = React.createClass({\n    getInitialState: function() {\n        return {\n            selectedCode: '',\n            selectedLanguage: jsonArray[0],\n        };\n    },\n\n    handleLangChange: function () {\n        var lang = this.refs.dropdown.value;\n        this.props.onSelectLanguage(lang);            \n    },\n\n    render() {\n\n        return (\n            <div>\n                <DropdownList ref='dropdown'\n                    data={jsonArray} \n                    valueField='lang' textField='lang'\n                    caseSensitive={false} \n                    minLength={3}\n                    filter='contains'\n                    onChange={this.handleLangChange} />\n            </div>            \n        );\n    }\n});\n\nJSON:\n{ \n\"languages\":[ \n\n    { \n    \"code\": \"aaa\", \n    \"lang\": \"english\" \n    }, \n    { \n    \"code\": \"aab\", \n    \"lang\": \"Swedish\" \n    }, \n  ] \n}\n\n \nTo pass data from child component to parent component\nIn Parent Component: \ngetData(val){\n    // do not forget to bind getData in constructor\n    console.log(val);\n}\nrender(){\n return(<Child sendData={this.getData}/>);\n}\n\nIn Child Component: \ndemoMethod(){\n   this.props.sendData(value);\n }\n\n \nConsidering React Function Components and using Hooks are getting more popular these days , I will give a simple example of how to Passing data from child to parent component\nin Parent Function Component we will have :\nimport React, { useState, useEffect } from \"react\";\n\nthen\nconst [childData, setChildData] = useState(\"\");\n\nand passing setChildData (which do a job similar to this.setState in Class Components) to Child \nreturn( <ChildComponent passChildData={setChildData} /> )\n\nin Child Component first we get the receiving props\nfunction ChildComponent(props){ return (...) }\n\nthen you can pass data anyhow like using a handler function\nconst functionHandler = (data) => {\n\nprops.passChildData(data);\n\n}\n\n \nI found the approach how to get data from child component in parents when i need it.\nParent:\nclass ParentComponent extends Component{\n  onSubmit(data) {\n    let mapPoint = this.getMapPoint();\n  }\n\n  render(){\n    return (\n      <form onSubmit={this.onSubmit.bind(this)}>\n        <ChildComponent getCurrentPoint={getMapPoint => {this.getMapPoint = getMapPoint}} />\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    )\n  }\n}\n\nChild:\nclass ChildComponent extends Component{\n  constructor(props){\n    super(props);\n\n    if (props.getCurrentPoint){\n      props.getCurrentPoint(this.getMapPoint.bind(this));\n    }\n  }\n\n  getMapPoint(){\n    return this.Point;\n  }\n}\n\nThis example showing how to pass function from child component to parent and use this function to get data from child.\n \nfrom child component to parent component as below\nparent component\nclass Parent extends React.Component {\n   state = { message: \"parent message\" }\n   callbackFunction = (childData) => {\n       this.setState({message: childData})\n   },\n   render() {\n        return (\n            <div>\n                 <Child parentCallback = {this.callbackFunction}/>\n                 <p> {this.state.message} </p>\n            </div>\n        );\n   }\n}\n\nchild component\nclass Child extends React.Component{\n    sendBackData = () => {\n         this.props.parentCallback(\"child message\");\n    },\n    render() { \n       <button onClick={sendBackData}>click me to send back</button>\n    }\n};\n\nI hope this work\n \nin React v16.8+ function component, you can use useState() to create a function state that lets you update the parent state, then pass it on to child as a props attribute, then inside the child component you can trigger the parent state function, the following is a working snippet:\n\n\nconst { useState , useEffect } = React;\r\n\r\nfunction Timer({ setParentCounter }) {\r\n  const [counter, setCounter] = React.useState(0);\r\n\r\n  useEffect(() => {\r\n    let countersystem;\r\n    countersystem = setTimeout(() => setCounter(counter + 1), 1000);\r\n\r\n    return () => {\r\n      clearTimeout(countersystem);\r\n    };\r\n  }, [counter]);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <button\r\n        onClick={() => {\r\n          setParentCounter(counter);\r\n        }}\r\n      >\r\n        Set parent counter value\r\n      </button>\r\n      <hr />\r\n      <div>Child Counter: {counter}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction App() {\r\n  const [parentCounter, setParentCounter] = useState(0);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      Parent Counter: {parentCounter}\r\n      <hr />\r\n      <Timer setParentCounter={setParentCounter} />\r\n    </div>\r\n  );\r\n}\r\n\r\nReactDOM.render(<App />, document.getElementById('react-root'));\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.8.4/umd/react.production.min.js\"></script>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.4/umd/react-dom.production.min.js\"></script>\r\n<div id=\"react-root\"></div>\n\n\n\n \nReact.createClass method has been deprecated in the new version of React, you can do it very simply in the following way make one functional component and another class component to maintain state:\nParent:\n\n\nconst ParentComp = () => {\r\n  \r\n  getLanguage = (language) => {\r\n    console.log('Language in Parent Component: ', language);\r\n  }\r\n  \r\n  <ChildComp onGetLanguage={getLanguage}\r\n};\n\n\n\nChild:\n\n\nclass ChildComp extends React.Component {\r\n    state = {\r\n      selectedLanguage: ''\r\n    }\r\n    \r\n    handleLangChange = e => {\r\n        const language = e.target.value;\r\n        thi.setState({\r\n          selectedLanguage = language;\r\n        });\r\n        this.props.onGetLanguage({language}); \r\n    }\r\n\r\n    render() {\r\n        const json = require(\"json!../languages.json\");\r\n        const jsonArray = json.languages;\r\n        const selectedLanguage = this.state;\r\n        return (\r\n            <div >\r\n                <DropdownList ref='dropdown'\r\n                    data={jsonArray} \r\n                    value={tselectedLanguage}\r\n                    caseSensitive={false} \r\n                    minLength={3}\r\n                    filter='contains'\r\n                    onChange={this.handleLangChange} />\r\n            </div>            \r\n        );\r\n    }\r\n};\n\n\n\n \nYou can even avoid the function at the parent updating the state directly\nIn Parent Component: \nrender(){\n return(<Child sendData={ v => this.setState({item: v}) } />);\n}\n\nIn the Child Component: \ndemoMethod(){\n   this.props.sendData(value);\n}\n\n \nThe idea is to send a callback to the child which  will be called to give the data back\nA complete and minimal example using functions: \nApp will create a Child which will compute a random number and send it back directly to the parent, which will console.log the result\nconst Child = ({ handleRandom }) => {\n  handleRandom(Math.random())\n\n  return <span>child</span>\n}\n\nconst App = () => <Child handleRandom={(num) => console.log(num)}/>\n\n \nPass data from child to parent Component using Callback\nYou need to pass from parent to child callback function, and then call it in the child.\n\nParent Component:-TimeModal\n  handleTimeValue = (timeValue) => {\n      this.setState({pouringDiff: timeValue});\n  }\n\n  <TimeSelection \n        prePourPreHours={prePourPreHours}\n        setPourTime={this.setPourTime}\n        isPrePour={isPrePour}\n        isResident={isResident}\n        isMilitaryFormatTime={isMilitaryFormatTime}\n        communityDateTime={moment(communityDT).format(\"MM/DD/YYYY hh:mm A\")}\n        onSelectPouringTimeDiff={this.handleTimeValue}\n     />\n\nNote:- onSelectPouringTimeDiff={this.handleTimeValue}\nIn the Child Component call props when required\n componentDidMount():void{\n      // Todo use this as per your scenrio\n       this.props.onSelectPouringTimeDiff(pouringDiff);  \n  }\n\n", "\nOk, i'll try and make this quick because it SHOULD be an easy fix...\nI've read a bunch of similar questions, and the answer seems to be quite obvious. Nothing I would ever have to look up in the first place! But... I am having an error that I cannot fathom how to fix or why its happening.\nAs follows:\nclass NightlifeTypes extends Component {\nconstructor(props) {\n    super(props);\n\n    this.state = {\n        barClubLounge: false,\n        seeTheTown: true,\n        eventsEntertainment: true,\n        familyFriendlyOnly: false\n    }\n    this.handleOnChange = this.handleOnChange.bind(this);\n}\n\nhandleOnChange = (event) => {   \n    if(event.target.className == \"barClubLounge\") {\n        this.setState({barClubLounge: event.target.checked});\n        console.log(event.target.checked)\n        console.log(this.state.barClubLounge)\n    }\n}\n\nrender() {\n    return (\n        <input className=\"barClubLounge\" type='checkbox' onChange={this.handleOnChange} checked={this.state.barClubLounge}/>\n    )\n}\n\nMore code surrounds this but this is where my problem lies. Should work, right? \nI've also tried this:\nhandleOnChange = (event) => {   \nif(event.target.className == \"barClubLounge\") {\n    this.setState({barClubLounge: !this.state.barClubLounge});\n    console.log(event.target.checked)\n    console.log(this.state.barClubLounge)\n}\n\nSo I have those two console.log()'s, both should be the same. I'm literally setting the state to be the same as the event.target.checked in the line above it!\nBut it always returns the opposite of what it should.\nSame goes for when I use !this.state.barClubLounge; If it starts false, on my first click it remains false, even though whether the checkbox is checked or not is based off of the state!!\nIt's a crazy paradox and I have no idea whats going on, please help!\n \nReason is setState is asynchronous, you can't expect the updated state value just after the setState, if you want to check the value use a callback method. Pass a method as callback that will be get executed after the setState complete its task. \n\nWhy setState is asynchronous ?\n\nThis is because setState alters the state and causes re rendering. This can be an expensive operation and making it synchronous might leave the browser unresponsive. \nThus the setState calls are asynchronous as well as batched for better UI experience and performance.\nFrom Doc:\n\nsetState() does not immediately mutate this.state but creates a\n  pending state transition. Accessing this.state after calling this\n  method can potentially return the existing value. There is no\n  guarantee of synchronous operation of calls to setState and calls may\n  be batched for performance gains.\n\nUsing callback method with setState:\nTo check the updated state value just after the setState, use a callback method like this:\nsetState({ key: value }, () => {\n     console.log('updated state value', this.state.key)\n})\n\nCheck this:\n\n\nclass NightlifeTypes extends React.Component {\r\n   constructor(props) {\r\n      super(props);\r\n\r\n      this.state = {\r\n         barClubLounge: false,\r\n         seeTheTown: true,\r\n         eventsEntertainment: true,\r\n         familyFriendlyOnly: false\r\n      }\r\n   }\r\n\r\n   handleOnChange = (event) => {  // Arrow function binds `this`\r\n      let value = event.target.checked;\r\n\r\n      if(event.target.className == \"barClubLounge\") {\r\n\r\n         this.setState({ barClubLounge: value}, () => {  //here\r\n             console.log(value);\r\n             console.log(this.state.barClubLounge);\r\n             //both will print same value\r\n         });        \r\n\r\n      }\r\n   }\r\n\r\n   render() {\r\n      return (\r\n          <input className=\"barClubLounge\" type='checkbox' onChange={this.handleOnChange} checked={this.state.barClubLounge}/>\r\n      )\r\n   }\r\n}\r\n\r\nReactDOM.render(<NightlifeTypes/>, document.getElementById('app'))\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js\"></script>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js\"></script>\r\n\r\n<div id='app'/>\n\n\n\n \nSince setState is a async function. That means after calling setState state variable does not immediately change. So if you want to perform other actions immediately after changing the state you should use callback method of setstate inside your setState update function. \nhandleOnChange = (event) => { \n     let inputState = event.target.checked;\n      if(event.target.className == \"barClubLounge\") {\n         this.setState({ barClubLounge: inputState}, () => {  //here\n             console.log(this.state.barClubLounge);\n             //here you can call other functions which use this state \n             variable //\n         });        \n      }\n   }\n\n \nThis is by-design due to performance considerations. setState in React is a function guaranteed to re-render Component, which is a costly CPU process. As such, its designers wanted to optimize by gathering multiple rendering actions into one, hence setState is asynchronous. \n", "\nI have two components.\n\nParent component \nChild component\n\nI was trying to call child's method from Parent, I tried this way but couldn't get a result\nclass Parent extends Component {\n  render() {\n    return (\n      <Child>\n        <button onClick={Child.getAlert()}>Click</button>\n      </Child>\n      );\n    }\n  }\n\nclass Child extends Component {\n  getAlert() {\n    alert('clicked');\n  }\n\n  render() {\n    return (\n      <h1 ref=\"hello\">Hello</h1>\n    );\n  }\n}\n\nIs there a way to call child's method from the parent ?\nNote: Child and Parent components are in two different files \n \nFirst off, let me express that this is generally not the way to go about things in React land. Usually what you want to do is pass down functionality to children in props, and pass up notifications from children in events (or better yet: dispatch).\nBut if you must expose an imperative method on a child component, you can use refs. Remember this is an escape hatch and usually indicates a better design is available.\n\nPreviously, refs were only supported for Class-based components. \n  With the advent of React Hooks, that's no longer the case\n\nUsing Hooks and Function Components (>= react@16.8)\n\n\nconst { forwardRef, useRef, useImperativeHandle } = React;\r\n\r\n// We need to wrap component in `forwardRef` in order to gain\r\n// access to the ref object that is assigned using the `ref` prop.\r\n// This ref is passed as the second parameter to the function component.\r\nconst Child = forwardRef((props, ref) => {\r\n\r\n  // The component instance will be extended\r\n  // with whatever you return from the callback passed\r\n  // as the second argument\r\n  useImperativeHandle(ref, () => ({\r\n\r\n    getAlert() {\r\n      alert(\"getAlert from Child\");\r\n    }\r\n\r\n  }));\r\n\r\n  return <h1>Hi</h1>;\r\n});\r\n\r\nconst Parent = () => {\r\n  // In order to gain access to the child component instance,\r\n  // you need to assign it to a `ref`, so we call `useRef()` to get one\r\n  const childRef = useRef();\r\n\r\n  return (\r\n    <div>\r\n      <Child ref={childRef} />\r\n      <button onClick={() => childRef.current.getAlert()}>Click</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nReactDOM.render(\r\n  <Parent />,\r\n  document.getElementById('root')\r\n);\n<script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script>\r\n<script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script>\r\n\r\n<div id=\"root\"></div>\n\n\n\nDocumentation for useImperativeHandle() is here:\n\nuseImperativeHandle customizes the instance value that is exposed to parent components when using ref.\n\nUsing Class Components (>= react@16.4)\n\n\nconst { Component } = React;\r\n\r\nclass Parent extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.child = React.createRef();\r\n  }\r\n\r\n  onClick = () => {\r\n    this.child.current.getAlert();\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Child ref={this.child} />\r\n        <button onClick={this.onClick}>Click</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Child extends Component {\r\n  getAlert() {\r\n    alert('getAlert from Child');\r\n  }\r\n\r\n  render() {\r\n    return <h1>Hello</h1>;\r\n  }\r\n}\r\n\r\nReactDOM.render(<Parent />, document.getElementById('root'));\n<script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script>\r\n<script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script>\r\n<div id=\"root\"></div>\n\n\n\nLegacy API (<= react@16.3)\nFor historical purposes, here's the callback-based style you'd use with React versions before 16.3:\n\n\nconst { Component } = React;\r\nconst { render } = ReactDOM;\r\n\r\nclass Parent extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Child ref={instance => { this.child = instance; }} />\r\n        <button onClick={() => { this.child.getAlert(); }}>Click</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Child extends Component {\r\n  getAlert() {\r\n    alert('clicked');\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <h1>Hello</h1>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nrender(\r\n  <Parent />,\r\n  document.getElementById('app')\r\n);\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js\"></script>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js\"></script>\r\n\r\n<div id=\"app\"></div>\n\n\n\n \nYou can use another pattern here:\nclass Parent extends Component {\n render() {\n  return (\n    <div>\n      <Child setClick={click => this.clickChild = click}/>\n      <button onClick={() => this.clickChild()}>Click</button>\n    </div>\n  );\n }\n}\n\nclass Child extends Component {\n constructor(props) {\n    super(props);\n    this.getAlert = this.getAlert.bind(this);\n }\n componentDidMount() {\n    this.props.setClick(this.getAlert);\n }\n getAlert() {\n    alert('clicked');\n }\n render() {\n  return (\n    <h1 ref=\"hello\">Hello</h1>\n  );\n }\n}\n\nWhat it does is to set the parent's clickChild method when child is mounted. In this way when you click the button in parent it will call clickChild which calls child's getAlert.\nThis also works if your child is wrapped with connect() so you don't need the getWrappedInstance() hack.\nNote you can't use onClick={this.clickChild} in parent because when parent is rendered child is not mounted so this.clickChild is not assigned yet. Using onClick={() => this.clickChild()} is fine because when you click the button this.clickChild should already be assigned.\n \nAlternative method with useEffect:\nParent:\nconst [refresh, doRefresh] = useState(0);\n<Button onClick={() => doRefresh(prev => prev + 1)} />\n<Children refresh={refresh} />\n\nChildren:\nuseEffect(() => {\n    performRefresh(); //children function of interest\n  }, [props.refresh]);\n\n \nhttps://facebook.github.io/react/tips/expose-component-functions.html\nfor more answers ref here Call methods on React children components\nBy looking into the refs of the \"reason\" component, you're breaking encapsulation and making it impossible to refactor that component without carefully examining all the places it's used. Because of this, we strongly recommend treating refs as private to a component, much like state.\nIn general, data should be passed down the tree via props. There are a few exceptions to this (such as calling .focus() or triggering a one-time animation that doesn't really \"change\" the state) but any time you're exposing a method called \"set\", props are usually a better choice. Try to make it so that the inner input component worries about its size and appearance so that none of its ancestors do.\n \nWe can use refs in another way as-\nWe are going to create a Parent element, it will render a <Child/> component.   As you can see, the component that will be rendered, you need to add the ref attribute and provide a name for it.\nThen, the triggerChildAlert function, located in the parent class will access the refs property of the this context (when the triggerChildAlert function is triggered will access the child reference and it will has all the functions of the child element).  \nclass Parent extends React.Component {\n    triggerChildAlert(){\n        this.refs.child.callChildMethod();\n        // to get child parent returned  value-\n        // this.value = this.refs.child.callChildMethod();\n        // alert('Returned value- '+this.value);\n    }\n\n    render() {\n        return (\n            <div>\n                {/* Note that you need to give a value to the ref parameter, in this case child*/}\n                <Child ref=\"child\" />\n                <button onClick={this.triggerChildAlert}>Click</button>\n            </div>\n        );\n    }\n}  \n\nNow, the child component, as theoretically designed previously, will look like:  \nclass Child extends React.Component {\n    callChildMethod() {\n        alert('Hello World');\n        // to return some value\n        // return this.state.someValue;\n    }\n\n    render() {\n        return (\n            <h1>Hello</h1>\n        );\n    }\n}\n\nHere is the source code-\nHope will help you !\n \nIf you are doing this simply because you want the Child to provide a re-usable trait to its parents, then you might consider doing that using render-props instead.\nThat technique actually turns the structure upside down.  The Child now wraps the parent, so I have renamed it to AlertTrait below.  I kept the name Parent for continuity, although it is not really a parent now.\n// Use it like this:\n\n  <AlertTrait renderComponent={Parent}/>\n\n\nclass AlertTrait extends Component {\n  // You will need to bind this function, if it uses 'this'\n  doAlert() {\n    alert('clicked');\n  }\n  render() {\n    return this.props.renderComponent({ doAlert: this.doAlert });\n  }\n}\n\nclass Parent extends Component {\n  render() {\n    return (\n      <button onClick={this.props.doAlert}>Click</button>\n    );\n  }\n}\n\nIn this case, the AlertTrait provides one or more traits which it passes down as props to whatever component it was given in its renderComponent prop.\nThe Parent receives doAlert as a prop, and can call it when needed.\n(For clarity, I called the prop renderComponent in the above example.  But in the React docs linked above, they just call it render.)\nThe Trait component can render stuff surrounding the Parent, in its render function, but it does not render anything inside the parent.  Actually it could render things inside the Parent, if it passed another prop (e.g. renderChild) to the parent, which the parent could then use during its render method.\nThis is somewhat different from what the OP asked for, but some people might end up here (like we did) because they wanted to create a reusable trait, and thought that a child component was a good way to do that.\n \nI wasn't satisfied with any of the solutions presented here. There is actually a very simple solution that can be done using pure Javascript without relying upon some React functionality other than the basic props object - and it gives you the benefit of communicating in either direction (parent -> child, child -> parent). You need to pass an object from the parent component to the child component. This object is what I refer to as a \"bi-directional reference\" or biRef for short. Basically, the object contains a reference to methods in the parent that the parent wants to expose. And the child component attaches methods to the object that the parent can call. Something like this:\n// Parent component.\nfunction MyParentComponent(props) {\n\n   function someParentFunction() {\n      // The child component can call this function.\n   }\n\n   function onButtonClick() {\n       // Call the function inside the child component.\n       biRef.someChildFunction();\n   }\n\n   // Add all the functions here that the child can call.\n   var biRef = {\n      someParentFunction: someParentFunction\n   }\n\n   return <div>\n       <MyChildComponent biRef={biRef} />\n       <Button onClick={onButtonClick} />\n   </div>;\n}\n\n\n// Child component\nfunction MyChildComponent(props) {\n\n   function someChildFunction() {\n      // The parent component can call this function.\n   }\n\n\n   function onButtonClick() {\n      // Call the parent function.\n      props.biRef.someParentFunction();\n   }\n\n   // Add all the child functions to props.biRef that you want the parent\n   // to be able to call.\n   props.biRef.someChildFunction = someChildFunction;\n\n   return <div>\n       <Button onClick={onButtonClick} />\n   </div>;\n}\n\nThe other advantage to this solution is that you can add a lot more functions in the parent and child while passing them from the parent to the child using only a single property.\nAn improvement over the code above is to not add the parent and child functions directly to the biRef object but rather to sub members. Parent functions should be added to a member called \"parent\" while the child functions should be added to a member called \"child\".\n// Parent component.\nfunction MyParentComponent(props) {\n\n   function someParentFunction() {\n      // The child component can call this function.\n   }\n\n   function onButtonClick() {\n       // Call the function inside the child component.\n       biRef.child.someChildFunction();\n   }\n\n   // Add all the functions here that the child can call.\n   var biRef = {\n      parent: {\n          someParentFunction: someParentFunction\n      }\n   }\n\n   return <div>\n       <MyChildComponent biRef={biRef} />\n       <Button onClick={onButtonClick} />\n   </div>;\n}\n\n\n// Child component\nfunction MyChildComponent(props) {\n\n   function someChildFunction() {\n      // The parent component can call this function.\n   }\n\n\n   function onButtonClick() {\n      // Call the parent function.\n      props.biRef.parent.someParentFunction();\n   }\n\n   // Add all the child functions to props.biRef that you want the parent\n   // to be able to call.\n   props.biRef {\n       child: {\n            someChildFunction: someChildFunction\n       }\n   }\n\n   return <div>\n       <Button onClick={onButtonClick} />\n   </div>;\n}\n\nBy placing parent and child functions into separate members of the biRef object, you 'll have a clean separation between the two and easily see which ones belong to parent or child. It also helps to prevent a child component from accidentally overwriting a parent function if the same function appears in both.\nOne last thing is that if you note, the parent component creates the biRef object with var whereas the child component accesses it through the props object. It might be tempting to not define the biRef object in the parent and access it from its parent through its own props parameter (which might be the case in a hierarchy of UI elements). This is risky because the child may think a function it is calling on the parent belongs to the parent when it might actually belong to a grandparent. There's nothing wrong with this as long as you are aware of it. Unless you have a reason for supporting some hierarchy beyond a parent/child relationship, it's best to create the biRef in your parent component.\n \nI hope I'm not repeating anything from above but what about passing a callback prop that sets the function in the parent? This works and is pretty easy. (Added code is between the ////'s)\nclass Parent extends Component {\n  ///// \n  getAlert = () => {} // initial value for getAlert\n\n  setGetAlertMethod = (newMethod) => {\n    this.getAlert = newMethod;\n  }\n  /////\n\n  render() {\n    return (\n      <Child setGetAlertMethod={this.setGetAlertMethod}>\n        <button onClick={this.getAlert}>Click</button>\n      </Child>\n      );\n    }\n  }\n\n\n\nclass Child extends Component {\n  /////\n  componentDidMount() {\n    this.props.setGetAlertMethod(this.getAlert);\n  }\n  /////\n\n  getAlert() => {\n    alert('clicked');\n  }\n\n  render() {\n    return (\n      <h1 ref=\"hello\">Hello</h1>\n    );\n  }\n}\n\n \nYou can achieve this easily in this way\nSteps-\n\nCreate a boolean variable in the state in the parent class. Update this when you want to call a function.\nCreate a prop variable and assign the boolean variable.\nFrom the child component access that variable using props and execute the method you want by having an if condition.\nclass Child extends Component {\n   Method=()=>{\n   --Your method body--\n   }\n   render() {\n     return (\n    //check whether the variable has been updated or not\n      if(this.props.updateMethod){\n        this.Method();\n      }\n     )\n   }\n}\n\nclass Parent extends Component {\n\nconstructor(){\n  this.state={\n   callMethod:false\n  }\n\n}\nrender() {\n   return (\n\n     //update state according to your requirement\n     this.setState({\n        callMethod:true\n     }}\n     <Child updateMethod={this.state.callMethod}></Child>\n    );\n   }\n}\n\n\n \nI'm using useEffect hook to overcome the headache of doing all this so now I pass a variable down to child like this:\n<ParentComponent>\n <ChildComponent arbitrary={value} />\n</ParentComponent>\nuseEffect(() => callTheFunctionToBeCalled(value) , [value]);\n\n \nHere my demo: https://stackblitz.com/edit/react-dgz1ee?file=styles.css\nI am using useEffect to call the children component's methods. I have tried with Proxy and Setter_Getter but sor far useEffect seems to be the more convenient way to call a child method from parent. To use Proxy and Setter_Getter it seems there is some subtlety to overcome first, because the element firstly rendered is an objectLike's element through the ref.current return => <div/>'s specificity. \nConcerning useEffect, you can also leverage on this approach to set the parent's state depending on what you want to do with the children. \nIn the demo's link I have provided, you will find my full ReactJS' code with my draftwork inside's so you can appreciate the workflow of my solution.\nHere I am providing you my ReactJS' snippet with the relevant code only. :\nimport React, {\n  Component,\n  createRef,\n  forwardRef,\n  useState,\n  useEffect\n} from \"react\"; \n\n{...}\n\n// Child component\n// I am defining here a forwardRef's element to get the Child's methods from the parent\n// through the ref's element.\nlet Child = forwardRef((props, ref) => {\n  // I am fetching the parent's method here\n  // that allows me to connect the parent and the child's components\n  let { validateChildren } = props;\n  // I am initializing the state of the children\n  // good if we can even leverage on the functional children's state\n  let initialState = {\n    one: \"hello world\",\n    two: () => {\n      console.log(\"I am accessing child method from parent :].\");\n      return \"child method achieve\";\n    }\n  };\n  // useState initialization\n  const [componentState, setComponentState] = useState(initialState);\n  // useEffect will allow me to communicate with the parent\n  // through a lifecycle data flow\n  useEffect(() => {\n    ref.current = { componentState };\n    validateChildren(ref.current.componentState.two);\n  });\n\n{...}\n\n});\n\n{...}\n\n// Parent component\nclass App extends Component {\n  // initialize the ref inside the constructor element\n  constructor(props) {\n    super(props);\n    this.childRef = createRef();\n  }\n\n  // I am implementing a parent's method\n  // in child useEffect's method\n  validateChildren = childrenMethod => {\n    // access children method from parent\n    childrenMethod();\n    // or signaling children is ready\n    console.log(\"children active\");\n  };\n\n{...}\nrender(){\n       return (\n          {\n            // I am referencing the children\n            // also I am implementing the parent logic connector's function\n            // in the child, here => this.validateChildren's function\n          }\n          <Child ref={this.childRef} validateChildren={this.validateChildren} />\n        </div>\n       )\n}\n\n \nWe're happy with a custom hook we call useCounterKey.  It just sets up a counterKey, or a key that counts up from zero.  The function it returns resets the key (i.e. increment).  (I believe this is the most idiomatic way in React to reset a component - just bump the key.)\nHowever this hook also works in any situation where you want to send a one-time message to the client to do something.  E.g. we use it to focus a control in the child on a certain parent event - it just autofocuses anytime the key is updated.  (If more props are needed they could be set prior to resetting the key so they're available when the event happens.)\nThis method has a bit of a learning curve b/c it's not as straightforward as a typical event handler, but it seems the most idiomatic way to handle this in React that we've found (since keys already function this way).  Def open to feedback on this method but it is working well!\n// Main helper hook:\nexport function useCounterKey() {\n  const [key, setKey] = useState(0);\n  return [key, () => setKey(prev => prev + 1)] as const;\n}\n\nSample usages:\n// Sample 1 - normal React, just reset a control by changing Key on demand\nfunction Sample1() {\n  const [inputLineCounterKey, resetInputLine] = useCounterKey();\n\n  return <>\n    <InputLine key={inputLineCounterKey} />\n    <button onClick={() => resetInputLine()} />\n  <>;\n}\n\n// Second sample - anytime the counterKey is incremented, child calls focus() on the input\nfunction Sample2() {\n  const [amountFocusCounterKey, focusAmountInput] = useCounterKey();\n\n  // ... call focusAmountInput in some hook or event handler as needed\n\n  return <WorkoutAmountInput focusCounterKey={amountFocusCounterKey} />\n}\n\nfunction WorkoutAmountInput(props) {\n  useEffect(() => {\n    if (counterKey > 0) {\n      // Don't focus initially\n      focusAmount();\n    }\n  }, [counterKey]);\n\n  // ...\n}\n\n(Credit to Kent Dodds for the counterKey concept.)\n \nYou can make Inheritance Inversion (look it up here: https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e). That way you have access to instance of the component that you would be wrapping (thus you'll be able to access it's functions)\n \nI think that the most basic way to call methods is by setting a request on the child component. Then as soon as the child handles the request, it calls a callback method to reset the request.\nThe reset mechanism is necessary to be able to send the same request multiple times after each other.\nIn parent component\nIn the render method of the parent:\nconst { request } = this.state;\nreturn (<Child request={request} onRequestHandled={()->resetRequest()}/>);\n\nThe parent needs 2 methods, to communicate with its child in 2 directions.\nsendRequest() {\n  const request = { param: \"value\" };\n  this.setState({ request });\n}\n\nresetRequest() {\n  const request = null;\n  this.setState({ request });\n}\n\nIn child component\nThe child updates its internal state, copying the request from the props.\nconstructor(props) {\n  super(props);\n  const { request } = props;\n  this.state = { request };\n}\n\nstatic getDerivedStateFromProps(props, state) {\n  const { request } = props;\n  if (request !== state.request ) return { request };\n  return null;\n}\n\nThen finally it handles the request, and sends the reset to the parent:\ncomponentDidMount() {\n  const { request } = this.state;\n  // todo handle request.\n\n  const { onRequestHandled } = this.props;\n  if (onRequestHandled != null) onRequestHandled();\n}\n\n \nAnother way of triggering a child function from parent is to make use of the componentDidUpdate function in child Component. I pass a prop triggerChildFunc from Parent to Child, which initially is null. The value changes to a function when the button is clicked and Child notice that change in componentDidUpdate and calls its own internal function. \nSince prop triggerChildFunc changes to a function, we also get a callback to the Parent. If Parent don't need to know when the function is called the value triggerChildFunc could for example change from null to true instead.\n\n\nconst { Component } = React;\r\nconst { render } = ReactDOM;\r\n\r\nclass Parent extends Component {\r\n  state = {\r\n    triggerFunc: null\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Child triggerChildFunc={this.state.triggerFunc} />\r\n        <button onClick={() => {\r\n          this.setState({ triggerFunc: () => alert('Callback in parent')})\r\n        }}>Click\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Child extends Component {\r\n  componentDidUpdate(prevProps) {\r\n    if (this.props.triggerChildFunc !== prevProps.triggerChildFunc) {\r\n      this.onParentTrigger();\r\n    }\r\n  }\r\n\r\n  onParentTrigger() {\r\n    alert('parent triggered me');\r\n\r\n    // Let's call the passed variable from parent if it's a function\r\n    if (this.props.triggerChildFunc && {}.toString.call(this.props.triggerChildFunc) === '[object Function]') {\r\n      this.props.triggerChildFunc();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <h1>Hello</h1>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nrender(\r\n  <Parent />,\r\n  document.getElementById('app')\r\n);\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.6.3/umd/react.production.min.js\"></script>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.6.3/umd/react-dom.production.min.js\"></script>\r\n<div id='app'></div>\n\n\n\nCodePen: https://codepen.io/calsal/pen/NWPxbJv?editors=1010\n \nHere's a bug? to look out for: \nI concur with rossipedia's solution using forwardRef, useRef, useImperativeHandle\nThere's some misinformation online that says refs can only be created from React Class components, but you can indeed use Function Components if you use the aforementioned hooks above.  A note, the hooks only worked for me after I changed the file to not use withRouter() when exporting the component. I.e. a change from \nexport default withRouter(TableConfig);\n\nto instead be\nexport default TableConfig;\n\nIn hindsight the withRouter() is not needed for such a component anyway, but usually it doesn't hurt anything having it in. My use case is that I created a component to create a Table to handle the viewing and editing of config values, and I wanted to be able to tell this Child component to reset it's state values whenever the Parent form's Reset button was hit.  UseRef() wouldn't properly get the ref or ref.current (kept on getting null) until I removed withRouter() from the file containing my child component TableConfig\n", "\nI understand that React tutorials and documentation warn in no uncertain terms that state should not be directly mutated and that everything should go through setState.\nI would like to understand why, exactly, I can't just directly change state and then (in the same function) call this.setState({}) just to trigger the render.\nE.g.: The below code seems to work just fine:\nconst React = require('react');\n\nconst App = React.createClass({\n    getInitialState: function() {\n        return {\n            some: {\n                rather: {\n                    deeply: {\n                        embedded: {\n                            stuff: 1\n                        }}}}};\n    },\n    updateCounter: function () {\n        this.state.some.rather.deeply.embedded.stuff++;\n        this.setState({}); // just to trigger the render ...\n    },\n    render: function() {\n        return (\n                <div>\n                Counter value: {this.state.some.rather.deeply.embedded.stuff}\n                <br></br>\n                <button onClick={this.updateCounter}>inc</button>\n                </div>\n        );\n    }\n});\n\nexport default App;\n\nI am all for following conventions but I would like to enhance my further understanding of how ReactJS actually works and what can go wrong or is it sub-optimal with the above code.\nThe notes under the this.setState documentation basically identify two gotchas:\n\nThat if you mutate state directly and then subsequently call this.setState this may replace (overwrite?) the mutation you made. I don't see how this can happen in the above code.\nThat setState may mutate this.state effectively in an asynchronous / deferred way and so when accessing this.state right after calling this.setState you are not guaranteed to access the final mutated state. I get that, by this is not an issue if this.setState is the last call of the update function.\n\n \nThe React docs for setState have this to say:\n\nNEVER mutate this.state directly, as calling setState() afterwards may replace the mutation you made. Treat this.state as if it were immutable.\nsetState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value.\nThere is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.\nsetState() will always trigger a re-render unless conditional rendering logic is implemented in shouldComponentUpdate(). If mutable objects are being used and the logic cannot be implemented in shouldComponentUpdate(), calling setState() only when the new state differs from the previous state will avoid unnecessary re-renders.\n\nBasically, if you modify this.state directly, you create a situation where those modifications might get overwritten.\nRelated to your extended questions 1) and 2), setState() is not immediate. It queues a state transition based on what it thinks is going on which may not include the direct changes to this.state. Since it's queued rather than applied immediately, it's entirely possible that something is modified in between such that your direct changes get overwritten.\nIf nothing else, you might be better off just considering that not directly modifying this.state can be seen as good practice. You may know personally that your code interacts with React in such a way that these over-writes or other issues can't happen but you're creating a situation where other developers or future updates can suddenly find themselves with weird or subtle issues.\n \nThis answer is to provide enough information to not change/mutate the state directly in React.\nReact follows Unidirectional Data Flow. Meaning, the data flow inside react should and will be expected to be in a circular path.\nReact's Data flow without flux\n\nTo make React work like this, developers made the React similar to functional programming. The thumb rule of functional programming is immutability. Let me explain it loud and clear.\nHow does the unidirectional flow works?\n\nstates are a data store which contains the data of a component.\nThe view of a component renders based on the state.\nWhen the view needs to change something on the screen, that value should be supplied from the store.\nTo make this happen, React provides setState() function which takes in an object of new states and does an compare and merge(similar to object.assign()) over the previous state and adds the new state to the state data store.\nWhenever the data in the state store changes, react will trigger an re-render with the new state which the view consumes and shows it on the screen.\n\nThis cycle will continue throughout the component's lifetime.\nIf you see the above steps, it clearly shows a lot of things are happening behind when you change the state. So, when you mutate the state directly and call setState() with an empty object. The previous state will be polluted with your mutation. Due to which, the shallow compare and merge of two states will be disturbed or won't happen, because you'll have only one state now. This will disrupt all the React's Lifecycle Methods.\nAs a result, your app will behave abnormal or even crash. Most of the times, it won't affect your app because all the apps which we use for testing this are pretty small.\nAnd another downside of mutation of Objects and Arrays in JavaScript is, when you assign an object or an array, you're just making a reference of that object or that array. When you mutate them, all the reference to that object or that array will be affected. React handles this in a intelligent way in the background and simply give us an API to make it work.\nMost common errors done when handling states in React\n//original state\nthis.state = {\n   a: [1,2,3,4,5]\n}\n\n//changing the state in react\n//need to add '6' in the array\n\n//bad approach\nconst b = this.state.a.push(6)\nthis.setState({\n  a: b\n}) \n\nIn the above example, this.state.a.push(6) will mutate the state directly. Assigning it to another variable and calling setState is same as what's shown below. As we mutated the state anyway, there's no point assigning it to another variable and calling setState with that variable.\n //same as \n this.state.a.push(6)\n this.setState({})\n\nMost of the people does this. This is so wrong. This breaks the beauty of React and it'll make you a bad programmer.\nSo, What's the best way to handle states in React? Let me explain.\nWhen you need to change 'something' in the existing state, first get a copy of that 'something' from the current state.\n//original state\n    this.state = {\n       a: [1,2,3,4,5]\n    }\n\n //changing the state in react\n //need to add '6' in the array\n\n //create a copy of this.state.a\n //you can use ES6's destructuring or loadash's _.clone()\n const currentStateCopy = [...this.state.a]\n\nNow, mutating currentStateCopy won't mutate the original state. Do operations over currentStateCopy and set it as the new state using setState().\ncurrentStateCopy.push(6)\nthis.state({\n a: currentStateCopy\n})\n\nThis is beautify, right?\nBy doing this, all the references of this.state.a won't get affected until we use setState. This gives you control over your code and this'll help you write elegant test and make you confident about the performance of the code in production.\nTo answer your question,\n\nWhy can't I directly modify a component's state?\n\n\nYes, you can. But, you need to face the following consequences.\n\nWhen you scale, you'll be writing unmanageable code.\nYou'll lose control of state across components.\nInstead of using React, you'll be writing custom codes over React.\n\nImmutability is not necessary thing because JavaScript is single threaded. But, It's a good to follow practice which will help you in the long run.\nPS. I've written about 10000 lines of mutable React JS code. If it breaks now, I don't know where to look into because all the values are mutated somewhere. When I realized this, I started writing immutable code. Trust me! That's the best thing you can do it to a product or an app.\nHope this helps!\n \nthe simplest answer to \"\n\nWhy can't I directly modify a component's state:\n\nis all about Updating phase.\nwhen we update the state of a component all it's children are going to be rendered as well. or our entire component tree rendered.\nbut when i say our entire component tree is rendered that doesn\u2019t mean that the entire DOM is updated.\nwhen a component is rendered we basically get a react element, so that is updating our virtual dom.\nReact will then look at the virtual DOM, it also has a copy of the old virtual DOM, that is why we shouldn\u2019t update the state directly, so we can have two different object references in memory, we have the old virtual DOM as well as the new virtual DOM.\nthen react will figure out what is changed and based on that it will update the real DOM accordingly .\nhope it helps.\n \nTo avoid every time to create a copy of this.state.element you can use update with $set or $push or many others from immutability-helper\ne.g.:\nimport update from 'immutability-helper';\n\nconst newData = update(myData, {\n  x: {y: {z: {$set: 7}}},\n  a: {b: {$push: [9]}}\n});\n\n \nsetState trigger re rendering of the components.when we want to update state again and again we must need to setState otherwise it doesn't work correctly.\n \nMy current understanding is based on this and this answer: \nIF you don't use shouldComponentUpdate or any other lifecycle methods (like componentWillReceiveProps, componentWillUpdate, and componentDidUpdate)  where you compare the old and new props/state \nTHEN \nits fine to mutate state and then call setState(), otherwise it is not fine.\n", "\nI am developing an application in which I check if the user is not loggedIn. I have to display the login form, else dispatch an action that would change the route and load other component. Here is my code:\nrender() {\n    if (isLoggedIn) {\n        // dispatch an action to change the route\n    }\n    // return login component\n    <Login />\n}\n\nHow can I achieve this as I cannot change states inside the render function.\n \nConsidering you are using react-router v4\nUse your component with withRouter and use history.push from props to change the route. You need to make use of withRouter only when your component is not receiving the Router props, this may happen in cases when your component is a nested child of a component rendered by the Router and you haven't passed the Router props to it or when the component is not linked to the Router at all and is rendered as a separate component from the Routes.\nimport {withRouter} from 'react-router';\n\nclass App extends React.Component {\n     ...\n     componenDidMount() {\n        // get isLoggedIn from localStorage or API call\n        if (isLoggedIn) {\n             // dispatch an action to change the route\n             this.props.history.push('/home');\n        }\n     }\n     render() {\n         // return login component\n         return <Login />\n    }\n}\n\n\nexport default withRouter(App);\n\n\nImportant Note\nIf you are using withRouter to prevent updates from being blocked by\n  shouldComponentUpdate, it is important that withRouter wraps the\n  component that implements shouldComponentUpdate. For example, when\n  using Redux:\n// This gets around shouldComponentUpdate\nwithRouter(connect(...)(MyComponent))\n\n// This does not \nconnect(...)(withRouter(MyComponent))\n\n\nor you could use Redirect\nimport {withRouter} from 'react-router';\n\nclass App extends React.Component {\n     ...\n     render() {\n         if(isLoggedIn) {\n              return <Redirect to=\"/home\"/>\n         }\n         // return login component\n         return <Login />\n    }\n}\n\nWith react-router v2 or react-router v3, you can make use of context to dynamically change the route like\nclass App extends React.Component {\n     ...\n     render() {\n         if (isLoggedIn) {\n             // dispatch an action to change the route\n             this.context.router.push('/home');\n         }\n         // return login component\n         return <Login />\n    }\n}\n\nApp.contextTypes = {\n    router: React.PropTypes.object.isRequired\n}\nexport default App;\n\nor use \nimport { browserHistory } from 'react-router';\nbrowserHistory.push('/some/path');\n\n \nIn react-router version 4:\nimport React from 'react'\nimport { BrowserRouter as Router, Route, Redirect} from 'react-router-dom'\n\nconst Example = () => (\n\n  if (isLoggedIn) {\n    <OtherComponent />\n\n  } else {\n\n    <Router>\n      <Redirect push to=\"/login\" />\n      <Route path=\"/login\" component={Login}/>\n    </Router>\n\n  }\n)\n\nconst Login = () => (\n    <h1>Form Components</h1>\n    ...\n)\n\nexport default Example;\n\n \nAnother alternative is to handle this using Thunk-style asynchronous actions (which are safe/allowed to have side-effects).\nIf you use Thunk, you can inject the same history object into both your <Router> component and Thunk actions using thunk.withExtraArgument, like this:\nimport React from 'react'\nimport { BrowserRouter as Router, Route, Redirect} from 'react-router-dom'\nimport { createBrowserHistory } from \"history\"\nimport { applyMiddleware, createStore } from \"redux\"\nimport thunk from \"redux-thunk\"\n\nconst history = createBrowserHistory()\n\nconst middlewares = applyMiddleware(thunk.withExtraArgument({history}))\nconst store = createStore(appReducer, middlewares)\n\nrender(\n  <Provider store={store}\n    <Router history={history}>\n      <Route path=\"*\" component={CatchAll} />\n    </Router\n  </Provider>,\nappDiv)\n\nThen in your action-creators, you will have a history instance that is safe to use with ReactRouter, so you can just trigger a regular Redux event if you're not logged in:\n// meanwhile... in action-creators.js\nexport const notLoggedIn = () => {\n  return (dispatch, getState, {history}) => {\n    history.push(`/login`)\n  }\n}\n\nAnother advantage of this is that the url is easier to handle, now, so we can put redirect info on the query string, etc.\nYou can try still doing this check in your Render methods, but if it causes problems, you might consider doing it in componentDidMount, or elsewhere in the lifecycle (although also I understand the desire to stick with Stateless Functional Compeonents!)\nYou can still use Redux and mapDispatchToProps to inject the action creator into your comptonent, so your component is still only loosely connected to Redux.\n \nThose who are facing issues in implementing this on react-router v4. Here is a working solution for navigating through the react app programmatically.\nhistory.js\nimport createHistory from 'history/createBrowserHistory'\n\nexport default createHistory()\n\nApp.js OR Route.jsx. Pass history as a prop to your Router.\nimport { Router, Route } from 'react-router-dom'\nimport history from './history'\n...\n<Router history={history}>\n <Route path=\"/test\" component={Test}/>\n</Router>\n\nYou can use push() to navigate.\nimport history from './history' \n\n...\n\nrender() {\n     if (isLoggedIn) {\n         history.push('/test') // this should change the url and re-render Test component\n     }\n     // return login component\n     <Login />\n}\n\nAll thanks to this comment: https://github.com/ReactTraining/react-router/issues/3498#issuecomment-301057248\n \nThis is my handle loggedIn. react-router v4 \nPrivateRoute is allow enter path if user is loggedIn and save the token to localStorge \n    function PrivateRoute({ component: Component, ...rest }) {\n     return (\n        <Route\n          {...rest}\n          render={props => (localStorage.token) ? <Component {...props} /> : (\n            <Redirect\n              to={{\n                pathname: '/signin',\n                state: { from: props.location },\n              }}\n            />\n          )\n          }\n        />\n      );\n    }\n\nDefine all paths in your app in here\nexport default (\n  <main>\n    <Switch>\n      <Route exact path=\"/signin\" component={SignIn} />\n      <Route exact path=\"/signup\" component={SignUp} />\n      <PrivateRoute path=\"/\" component={Home} />\n    </Switch>\n  </main>\n);\n\n \nrender(){ \n\n    return (\n        <div>  \n            { this.props.redirect ? <Redirect to=\"/\" /> :'' } \n            <div>\n                add here component codes\n            </div>\n        </div>\n    );\n} \n\n \nI would suggest you to use connected-react-router https://github.com/supasate/connected-react-router \nwhich helps to perform navigation even from reducers/actions if you want.\nit is well documented and easy to configure\n \nI was able to use history within stateless functional component, using withRouter following way (needed to ignore typescript warning):\nimport { withRouter } from 'react-router-dom';\n\n...\n\ntype Props = { myProp: boolean };\n\n// @ts-ignore\nexport const MyComponent: FC<Props> = withRouter(({ myProp, history }) => {\n\n...\n\n})\n\n", "\nI have just found that in react this.setState() function in any component is asynchronous or is called after the completion of the function that it was called in.\nNow I searched and found this blog (setState() State Mutation Operation May Be Synchronous In ReactJS)\nHere he found that setState is async(called when stack is empty) or sync(called as soon as called) depending on how the change of state was triggered.\nNow these two things are hard to digest \n\nIn the blog the setState function is called inside a function updateState, but what triggered the updateState function is not something that a called function would know about.\nWhy would they make setState async as JS is single threaded language and this setState is not a WebAPI or server call so has to be done on JS's thread only. Are they doing this so that Re-Rendering does not stop all the event listeners and stuff, or there is some other design issue.\n\n \nYou can call a function after the state value has updated:\nthis.setState({foo: 'bar'}, () => { \n    // Do something here. \n});\n\nAlso, if you have lots of states to update at once, group them all within the same setState:\nInstead of:\nthis.setState({foo: \"one\"}, () => {\n    this.setState({bar: \"two\"});\n});\n\nJust do this:\nthis.setState({\n    foo: \"one\",\n    bar: \"two\"\n});\n\n \n1) setState actions are asynchronous and are batched for performance gains. This is explained in the documentation of setState.\n\nsetState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value.\n  There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.\n\n\n2) Why would they make setState async as JS is a single threaded language and this setState is not a WebAPI or server call?\nThis is because setState alters the state and causes rerendering. This can be an expensive operation and making it synchronous might leave the browser unresponsive.\n\nThus the setState calls are asynchronous as well as batched for better UI experience and performance.\n \nI know this question is old, but it has been causing a lot of confusion for many reactjs users for a long time, including me.\nRecently Dan Abramov (from the react team) just wrote up a great explanation as to why the nature of setState is async:\nhttps://github.com/facebook/react/issues/11527#issuecomment-360199710\nsetState is meant to be asynchronous, and there are a few really good reasons for that in the linked explanation by Dan Abramov. This doesn't mean it will always be asynchronous - it mainly means that you just can't depend on it being synchronous. ReactJS takes into consideration many variables in the scenario that you're changing the state in, to decide when the state should actually be updated and your component rerendered.\nA simple example to demonstrate this, is that if you call setState as a reaction to a user action, then the state will probably be updated immediately (although, again, you can't count on it), so the user won't feel any delay, but if you call setState in reaction to an ajax call response or some other event that isn't triggered by the user, then the state might be updated with a slight delay, since the user won't really feel this delay, and it will improve performance by waiting to batch multiple state updates together and rerender the DOM fewer times.\n \nGood article here  https://github.com/vasanthk/react-bits/blob/master/patterns/27.passing-function-to-setState.md\n// assuming this.state.count === 0\nthis.setState({count: this.state.count + 1});\nthis.setState({count: this.state.count + 1});\nthis.setState({count: this.state.count + 1});\n// this.state.count === 1, not 3\n\nSolution\nthis.setState((prevState, props) => ({\n  count: prevState.count + props.increment\n}));\n\nor pass callback  this.setState ({.....},callback)\nhttps://medium.com/javascript-scene/setstate-gate-abc10a9b2d82\nhttps://medium.freecodecamp.org/functional-setstate-is-the-future-of-react-374f30401b6b\n \nYou can use the following wrap to make sync call\n\n\nthis.setState((state =>{\r\n  return{\r\n    something\r\n  }\r\n})\n\n\n\n \nImagine incrementing a counter in some component:\n  class SomeComponent extends Component{\n\n    state = {\n      updatedByDiv: '',\n      updatedByBtn: '',\n      counter: 0\n    }\n\n    divCountHandler = () => {\n      this.setState({\n        updatedByDiv: 'Div',\n        counter: this.state.counter + 1\n      });\n      console.log('divCountHandler executed');\n    }\n\n    btnCountHandler = () => {\n      this.setState({\n        updatedByBtn: 'Button',\n        counter: this.state.counter + 1\n      });\n      console.log('btnCountHandler executed');\n    }\n    ...\n    ...\n    render(){\n      return (\n        ...\n        // a parent div\n        <div onClick={this.divCountHandler}>\n          // a child button\n          <button onClick={this.btnCountHandler}>Increment Count</button>\n        </div>\n        ...\n      )\n    }\n  }\n\nThere is a count handler attached to both the parent and the child components. This is done purposely so we can execute the setState() twice within the same click event bubbling context, but from within 2 different handlers. \nAs we would imagine, a single click event on the button would now trigger both these handlers since the event bubbles from target to the outermost container during the bubbling phase. \nTherefore the btnCountHandler() executes first, expected to increment the count to 1 and then the divCountHandler() executes, expected to increment the count to 2. \nHowever the count only increments to 1 as you can inspect in React Developer tools.\nThis proves that react \n\nqueues all the setState calls\ncomes back to this queue after executing the last method in the context(the divCountHandler in this case)\nmerges all the object mutations happening within multiple setState calls in the same context(all method calls within a single event phase is same context for e.g.) into one single object mutation syntax (merging makes sense because this is why we can update the state properties independently in setState() in the first place)\nand passes it into one single setState() to prevent re-rendering due to multiple setState() calls (this is a very primitive description of batching). \n\nResultant code run by react:\nthis.setState({\n  updatedByDiv: 'Div',\n  updatedByBtn: 'Button',\n  counter: this.state.counter + 1\n})\n\nTo stop this behaviour, instead of passing objects as arguments to the setState method, callbacks are passed.\n    divCountHandler = () => {\n          this.setState((prevState, props) => {\n            return {\n              updatedByDiv: 'Div',\n              counter: prevState.counter + 1\n            };\n          });\n          console.log('divCountHandler executed');\n        }\n\n    btnCountHandler = () => {\n          this.setState((prevState, props) => {\n            return {\n              updatedByBtn: 'Button',\n              counter: prevState.counter + 1\n            };\n          });\n      console.log('btnCountHandler executed');\n    }\n\nAfter the last method finishes execution and when react returns to process the setState queue, it simply calls the callback for each setState queued, passing in the previous component state.\nThis way react ensures that the last callback in the queue gets to update the state that all of its previous counterparts have laid hands on.\n \nYes, setState() is asynchronous.\nFrom the link: https://reactjs.org/docs/react-component.html#setstate\n\n\nReact does not guarantee that the state changes are applied immediately.  \nsetState() does not always immediately update the component.  \nThink of setState() as a request rather than an immediate command to update the component.\n\n\nBecause they think\nFrom the link: https://github.com/facebook/react/issues/11527#issuecomment-360199710\n\n... we agree that setState() re-rendering synchronously would be inefficient in many cases\n\nAsynchronous setState() makes life very difficult for those getting started and even experienced unfortunately:\n- unexpected rendering issues: delayed rendering or no rendering (based on program logic)\n- passing parameters is a big deal\namong other issues.\nBelow example helped:\n// call doMyTask1 - here we set state\n// then after state is updated...\n//     call to doMyTask2 to proceed further in program\n\nconstructor(props) {\n    // ..\n\n    // This binding is necessary to make `this` work in the callback\n    this.doMyTask1 = this.doMyTask1.bind(this);\n    this.doMyTask2 = this.doMyTask2.bind(this);\n}\n\nfunction doMyTask1(myparam1) {\n    // ..\n\n    this.setState(\n        {\n            mystate1: 'myvalue1',\n            mystate2: 'myvalue2'\n            // ...\n        },    \n        () => {\n            this.doMyTask2(myparam1); \n        }\n    );\n}\n\nfunction doMyTask2(myparam2) {\n    // ..\n}\n\nHope that helps.\n", "\nI'm new to using ES6 classes with React, previously I've been binding my methods to the current object (show in first example), but does ES6 allow me to permanently bind a class function to a class instance with arrows? (Useful when passing as a callback function.) I get errors when I try to use them as you can with CoffeeScript:\nclass SomeClass extends React.Component {\n\n  // Instead of this\n  constructor(){\n    this.handleInputChange = this.handleInputChange.bind(this)\n  }\n\n  // Can I somehow do this? Am i just getting the syntax wrong?\n  handleInputChange (val) => {\n    console.log('selectionMade: ', val);\n  }\n\nSo that if I were to pass SomeClass.handleInputChange to, for instance setTimeout, it would be scoped to the class instance, and not the window object.\n \nYour syntax is slightly off, just missing an equals sign after the property name.\nclass SomeClass extends React.Component {\n  handleInputChange = (val) => {\n    console.log('selectionMade: ', val);\n  }\n}\n\nThis is an experimental feature. You will need to enable experimental features in Babel to get this to compile. Here is a demo with experimental enabled. \nTo use experimental features in babel you can install the relevant plugin from here. For this specific feature, you need the transform-class-properties plugin:\n{\n  \"plugins\": [\n    \"transform-class-properties\"\n  ]\n}\n\nYou can read more about the proposal for Class Fields and Static Properties here\n\n \nNo, if you want to create bound, instance-specific methods you will have to do that in the constructor. However, you can use arrow functions for that, instead of using .bind on a prototype method:\nclass SomeClass extends React.Component {\n  constructor() {\n    super();\n    this.handleInputChange = (val) => {\n      console.log('selectionMade: ', val, this);\n    };\n    \u2026\n  }\n}\n\nThere is an proposal which might allow you to omit the constructor() and directly put the assignment in the class scope with the same functionality, but I wouldn't recommend to use that as it's highly experimental.\nAlternatively, you can always use .bind, which allows you to declare the method on the prototype and then bind it to the instance in the constructor. This approach has greater flexibility as it allows modifying the method from the outside of your class.\nclass SomeClass extends React.Component {\n  constructor() {\n    super();\n    this.handleInputChange = this.handleInputChange.bind(this);\n    \u2026\n  }\n  handleInputChange(val) {\n    console.log('selectionMade: ', val, this);\n  }\n}\n\n \nI know this question has been sufficiently answered, but I just have a small contribution to make (for those who don't want to use the experimental feature). Because of the problem of having to bind multiple function binds in the constructor and making it look messy, I came up with a utility method that once bound and called in the constructor, does all the necessary method bindings for you automatically.\nAssume I have this class with the constructor:\n\n\n//src/components/PetEditor.jsx\r\nimport React from 'react';\r\nclass PetEditor extends React.Component {\r\n  \r\n   constructor(props){\r\n        super(props);\r\n        this.state = props.currentPet || {tags:[], photoUrls: []};\r\n     \r\n        this.tagInput = null;\r\n        this.htmlNode = null;\r\n\r\n        this.removeTag = this.removeTag.bind(this);\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.modifyState = this.modifyState.bind(this);\r\n        this.handleKeyUp = this.handleKeyUp.bind(this);\r\n        this.addTag = this.addTag.bind(this);\r\n        this.removeTag = this.removeTag.bind(this);\r\n        this.savePet = this.savePet.bind(this);\r\n        this.addPhotoInput = this.addPhotoInput.bind(this);\r\n        this.handleSelect = this.handleSelect.bind(this);\r\n        \r\n    }\r\n    // ... actual method declarations omitted\r\n}\n\n\n\nIt looks messy, doesn't it?\nNow I created this utility method\n\n\n//src/utils/index.js\r\n/**\r\n *  NB: to use this method, you need to bind it to the object instance calling it\r\n */\r\nexport function bindMethodsToSelf(objClass, otherMethodsToIgnore=[]){\r\n    const self = this;\r\n    Object.getOwnPropertyNames(objClass.prototype)\r\n        .forEach(method => {\r\n              //skip constructor, render and any overrides of lifecycle methods\r\n              if(method.startsWith('component') \r\n                 || method==='constructor' \r\n                 || method==='render') return;\r\n              //any other methods you don't want bound to self\r\n              if(otherMethodsToIgnore.indexOf(method)>-1) return;\r\n              //bind all other methods to class instance\r\n              self[method] = self[method].bind(self);\r\n         });\r\n}\n\n\n\nAll I now need to do is import that utility, and add a call to my constructor, and I don't need to bind each new method in the constructor anymore.\nNew constructor now looks clean, like this:\n\n\n//src/components/PetEditor.jsx\r\nimport React from 'react';\r\nimport { bindMethodsToSelf } from '../utils';\r\nclass PetEditor extends React.Component {\r\n    constructor(props){\r\n        super(props);\r\n        this.state = props.currentPet || {tags:[], photoUrls: []};\r\n        this.tagInput = null;\r\n        this.htmlNode = null;\r\n        bindMethodsToSelf.bind(this)(PetEditor);\r\n    }\r\n    // ...\r\n}\n\n\n\n \nYou are using arrow function and also binding it in constructor. So you no need to do binding when you use arrow functions \nclass SomeClass extends React.Component {\n  handleInputChange = (val) => {\n    console.log('selectionMade: ', val);\n  }\n}\n\nOR you need to bind a function only in constructor when you use normal function like below\nclass SomeClass extends React.Component {\n   constructor(props){\n      super(props);\n      this.handleInputChange = this.handleInputChange.bind(this);\n   }\n\n  handleInputChange(val){\n    console.log('selectionMade: ', val);\n  }\n}\n\nAlso binding a function directly in render is not recommended. It should always be in constructor\n", "\nI'm trying to do something like the following in React JSX (where ObjectRow is a separate component):\n<tbody>\n    for (var i=0; i < numrows; i++) {\n        <ObjectRow/>\n    } \n</tbody>\n\nI realize and understand why this isn't valid JSX, since JSX maps to function calls. However, coming from template land and being new to JSX, I am unsure how I would achieve the above (adding a component multiple times).\n \nThink of it like you're just calling JavaScript functions. You can't use a for loop where the arguments to a function call would go:\nreturn tbody(\n    for (var i = 0; i < numrows; i++) {\n        ObjectRow()\n    } \n)\n\nSee how the function tbody is being passed a for loop as an argument \u2013 leading to a syntax error.\nBut you can make an array, and then pass that in as an argument:\nvar rows = [];\nfor (var i = 0; i < numrows; i++) {\n    rows.push(ObjectRow());\n}\nreturn tbody(rows);\n\n\nYou can basically use the same structure when working with JSX:\nvar rows = [];\nfor (var i = 0; i < numrows; i++) {\n    // note: we are adding a key prop here to allow react to uniquely identify each\n    // element in this array. see: https://reactjs.org/docs/lists-and-keys.html\n    rows.push(<ObjectRow key={i} />);\n}\nreturn <tbody>{rows}</tbody>;\n\nIncidentally, my JavaScript example is almost exactly what that example of JSX transforms into. Play around with Babel REPL to get a feel for how JSX works.\n \nNot sure if this will work for your situation, but often map is a good answer.\nIf this was your code with the for loop:\n<tbody>\n    for (var i=0; i < objects.length; i++) {\n        <ObjectRow obj={objects[i]} key={i}>\n    } \n</tbody>\n\nYou could write it like this with map:\n<tbody>\n    {objects.map(function(object, i){\n        return <ObjectRow obj={object} key={i} />;\n    })}\n</tbody>\n\nES6 syntax:\n<tbody>\n    {objects.map((object, i) => <ObjectRow obj={object} key={i} />)}\n</tbody>\n\n \nIf you don't already have an array to map() like @FakeRainBrigand's answer, and want to inline this so the source layout corresponds to the output closer than @SophieAlpert's answer:\nWith ES2015 (ES6) syntax (spread and arrow functions)\nhttp://plnkr.co/edit/mfqFWODVy8dKQQOkIEGV?p=preview\n<tbody>\n  {[...Array(10)].map((x, i) =>\n    <ObjectRow key={i} />\n  )}\n</tbody>\n\nRe: transpiling with Babel, its caveats page says that Array.from is required for spread, but at present (v5.8.23) that does not seem to be the case when spreading an actual Array. I have a documentation issue open to clarify that. But use at your own risk or polyfill.\nVanilla ES5\nArray.apply\n<tbody>\n  {Array.apply(0, Array(10)).map(function (x, i) {\n    return <ObjectRow key={i} />;\n  })}\n</tbody>\n\nInline IIFE\nhttp://plnkr.co/edit/4kQjdTzd4w69g8Suu2hT?p=preview\n<tbody>\n  {(function (rows, i, len) {\n    while (++i <= len) {\n      rows.push(<ObjectRow key={i} />)\n    }\n    return rows;\n  })([], 0, 10)}\n</tbody>\n\nCombination of techniques from other answers\nKeep the source layout corresponding to the output, but make the inlined part more compact:\nrender: function () {\n  var rows = [], i = 0, len = 10;\n  while (++i <= len) rows.push(i);\n\n  return (\n    <tbody>\n      {rows.map(function (i) {\n        return <ObjectRow key={i} index={i} />;\n      })}\n    </tbody>\n  );\n}\n\nWith ES2015 syntax & Array methods\nWith Array.prototype.fill you could do this as an alternative to using spread as illustrated above:\n<tbody>\n  {Array(10).fill(1).map((el, i) =>\n    <ObjectRow key={i} />\n  )}\n</tbody>\n\n(I think you could actually omit any argument to fill(), but I'm not 100% on that.) Thanks to @FakeRainBrigand for correcting my mistake in an earlier version of the fill() solution (see revisions).\nkey\nIn all cases the key attr alleviates a warning with the development build, but isn't accessible in the child. You can pass an extra attr if you want the index available in the child. See Lists and Keys for discussion.\n \nSimply using map Array method with ES6 syntax:\n<tbody>\n  {items.map(item => <ObjectRow key={item.id} name={item.name} />)} \n</tbody>\n\nDon't forget the key property.\n \nUsing Array map function is a very common way to loop through an Array of elements and create components according to them in React, this is a great way to do a loop which is a pretty efficient and tidy way to do your loops in JSX, It's not the only way to do it, but the preferred way. \nAlso, don't forget having a unique Key for each iteration as required. Map function creates a unique index from 0 but it's not recommended using the produced index but if your value is unique or if there is a unique key, you can use them:\n<tbody>\n  {numrows.map(x=> <ObjectRow key={x.id} />)}\n</tbody>\n\nAlso, few lines from MDN if you not familiar with map function on Array:\n\nmap calls a provided callback function once for each element in an\narray, in order, and constructs a new array from the results. callback\nis invoked only for indexes of the array which have assigned values,\nincluding undefined. It is not called for missing elements of the\narray (that is, indexes that have never been set, which have been\ndeleted or which have never been assigned a value).\ncallback is invoked with three arguments: the value of the element,\nthe index of the element, and the Array object being traversed.\nIf a thisArg parameter is provided to the map, it will be used as\ncallback's this value. Otherwise, the value undefined will be used as\nits this value. This value ultimately observable by the callback is\ndetermined according to the usual rules for determining the this seen\nby a function.\nmap does not mutate the array on which it is called (although\ncallback, if invoked, may do so).\n\n \nIf you're already using lodash, the _.times function is handy.\nimport React, { Component } from \"react\";\nimport Select from \"./Select\";\nimport _ from \"lodash\";\n\nexport default class App extends Component {\n  render() {\n    return (\n      <div className=\"container\">\n        <ol>\n          {_.times(3, (i) => (\n            <li key={i}>\n              <Select onSelect={this.onSelect}>\n                <option value=\"1\">bacon</option>\n                <option value=\"2\">cheez</option>\n              </Select>\n            </li>\n          ))}\n        </ol>\n      </div>\n    );\n  }\n}\n\n \nYou can also extract outside the return block:\nrender: function() {\n    var rows = [];\n    for (var i = 0; i < numrows; i++) {\n        rows.push(<ObjectRow key={i}/>);\n    } \n\n    return (<tbody>{rows}</tbody>);\n}\n\n \nI know this is an old thread, but you might want to checkout React Templates, which does let you use jsx-style templates in react, with a few directives (such as rt-repeat).\nYour example, if you used react-templates, would be:\n<tbody>\n     <ObjectRow rt-repeat=\"obj in objects\"/>\n</tbody>\n\n \nThere are multiple ways to go about doing this. JSX eventually gets compiled to JavaScript, so as long as you're writing valid JavaScript, you'll be good.\nMy answer aims to consolidate all the wonderful ways already presented here:\nIf you do not have an array of object, simply the number of rows:\nwithin the return block, creating an Array and using Array.prototype.map:\nrender() {\n  return (\n    <tbody>\n      {Array(numrows).fill(null).map((value, index) => (\n        <ObjectRow key={index}>\n      ))}\n    </tbody>\n  );\n}\n\noutside the return block, simply use a normal JavaScript for-loop:\nrender() {\n  let rows = [];\n  for (let i = 0; i < numrows; i++) {\n    rows.push(<ObjectRow key={i}/>);\n  } \n  return (\n    <tbody>{rows}</tbody>\n  );\n}\n\nimmediately invoked function expression:\nrender() {\n  return (\n    <tbody>\n      {() => {\n        let rows = [];\n        for (let i = 0; i < numrows; i++) {\n          rows.push(<ObjectRow key={i}/>);\n        }\n        return rows;\n      }}\n    </tbody>\n  );\n}\n\nIf you have an array of objects\nwithin the return block, .map() each object to a <ObjectRow> component:\nrender() {\n  return (\n    <tbody>\n      {objectRows.map((row, index) => (\n        <ObjectRow key={index} data={row} />\n      ))}\n    </tbody>\n  );\n}\n\noutside the return block, simply use a normal JavaScript for-loop:\nrender() {\n  let rows = [];\n  for (let i = 0; i < objectRows.length; i++) {\n    rows.push(<ObjectRow key={i} data={objectRows[i]} />);\n  } \n  return (\n    <tbody>{rows}</tbody>\n  );\n}\n\nimmediately invoked function expression:\nrender() {\n  return (\n    <tbody>\n      {(() => {\n        const rows = [];\n        for (let i = 0; i < objectRows.length; i++) {\n          rows.push(<ObjectRow key={i} data={objectRows[i]} />);\n        }\n        return rows;\n      })()}\n    </tbody>\n  );\n}\n\n \nif numrows is a array, and it's very simple.\n<tbody>\n   {numrows.map(item => <ObjectRow />)}\n</tbody>\n\nArray data type in React is very better, array can back new array, and support filter, reduce etc.\n \nThere are several answers pointing to using the map statement. Here is a complete example using an iterator within the FeatureList component to list Feature components based on a JSON data structure called features.\nconst FeatureList = ({ features, onClickFeature, onClickLikes }) => (\n  <div className=\"feature-list\">\n    {features.map(feature =>\n      <Feature\n        key={feature.id}\n        {...feature}\n        onClickFeature={() => onClickFeature(feature.id)}\n        onClickLikes={() => onClickLikes(feature.id)}\n      />\n    )}\n  </div>\n); \n\nYou can view the complete FeatureList code on GitHub. The features fixture is listed here.\n \nTo loop for a number of times and return, you can achieve it with the help of from and map:\n<tbody>\n  {\n    Array.from(Array(i)).map(() => <ObjectRow />)\n  }\n</tbody>\n\nwhere i = number of times\n\nIf you want to assign unique key IDs into the rendered components, you can use React.Children.toArray as proposed in the React documentation\nReact.Children.toArray\nReturns the children opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice this.props.children before passing it down.\n\nNote:\nReact.Children.toArray() changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, toArray prefixes each key in the returned array so that each element\u2019s key is scoped to the input array containing it.\n\n<tbody>\n  {\n    React.Children.toArray(\n      Array.from(Array(i)).map(() => <ObjectRow />)\n    )\n  }\n</tbody>\n\n \nlet us say we have an array of items in your state:\n[{name: \"item1\", id: 1}, {name: \"item2\", id: 2}, {name: \"item3\", id: 3}]\n\n<tbody>\n    {this.state.items.map((item) => {\n        <ObjectRow key={item.id} name={item.name} />\n    })} \n</tbody>\n\n \nIf you opt to convert this inside return( ) of render method, easiest option would be using map( ) method. Map your array into JSX syntax using map() function, as shown below (ES6 syntax is used).\n\nInside parent component:\n<tbody>\n   { objectArray.map(object => <ObjectRow key={object.id} object={object.value}>) }\n</tbody>\n\nPlease note the key attribute added to your child component. If you didn't provide a key attribute, you can see the following warning on your console.\n\nWarning: Each child in an array or iterator should have\n  a unique \"key\" prop.\n\nNote: One common mistake people do is using index as key when iterating, using index of the element as a key is an anti-pattern and you can read more about it here. In short, if it's NOT a static list never use index as key.\n\nNow at the ObjectRow component, you can access the object from its properties.\nInside ObjectRow component\nconst { object } = this.props\nor \nconst object = this.props.object\nThis should fetch you the object you passed from parent component to the variable object in ObjectRow component. Now you can spit out the values in that object according to your purpose.\n\nReferences : \nmap() method in Javascript\nECMA Script 6 or ES6\n \nAn ES2015 / Babel possibility is using a generator function to create an array of JSX:\nfunction* jsxLoop(times, callback)\n{\n    for(var i = 0; i < times; ++i)\n        yield callback(i);\n}\n\n...\n\n<tbody>\n    {[...jsxLoop(numrows, i =>\n        <ObjectRow key={i}/>\n    )]}\n</tbody>\n\n \n...Or you can also prepare an array of objects and map it to a function to have the desired output. I prefer this, because it helps me to maintain the good practice of coding with no logic inside the return of render. \nrender() {\nconst mapItem = [];\nfor(let i =0;i<item.length;i++) \n  mapItem.push(i);\nconst singleItem => (item, index) {\n // item the single item in the array \n // the index of the item in the array\n // can implement any logic here\n return (\n  <ObjectRow/>\n)\n\n}\n  return(\n   <tbody>{mapItem.map(singleItem)}</tbody>\n  )\n}\n\n \nSimply use .map() to loop through your collection and return <ObjectRow> items with props from each iteration.\nAssuming objects is an array somewhere...\n<tbody>\n  { objects.map((obj, index) => <ObjectRow obj={ obj } key={ index }/> ) }\n</tbody>\n\n \nES2015 Array.from with the map function + key\nIf you have nothing to .map() you can use Array.from() with the map function to repeat elements:\n<tbody>\n  {Array.from({ length: 5 }, (value, key) => <ObjectRow key={key} />)}\n</tbody>\n\n \nI use this:\ngridItems = this.state.applications.map(app =>\n          <ApplicationItem key={app.Id} app={app } />\n);\n\nPS: never forget the key or you will have a lot of warnings!\n \nI tend to favor an approach where programming logic happens outside the return value of render.  This helps keep what is actually rendered easy to grok.\nSo I'd probably do something like:\nimport _ from 'lodash';\n\n...\n\nconst TableBody = ({ objects }) => {\n  const objectRows = objects.map(obj => <ObjectRow object={obj} />);      \n\n  return <tbody>{objectRows}</tbody>;\n} \n\nAdmittedly this is such a small amount of code that inlining it might work fine.\n \nyou can of course solve with a .map as suggested by the other answer. If you already use babel, you could think about using jsx-control-statements \nThey require a little of setting, but I think it's worth in terms of readability (especially for non-react developer).\nIf you use a linter, there's also eslint-plugin-jsx-control-statements\n \nYour JSX code will compile into pure JavaScript code, any tags will be replaced by ReactElement objects. In JavaScript, you cannot call a function multiple times to collect their returned variables.\nIt is illegal, the only way is to use an array to store the function returned variables.\nOr you can use Array.prototype.map which is available since JavaScript ES5 to handle this situation.\nMaybe we can write other compiler to recreate a new JSX syntax to implement a repeat function just like Angular's ng-repeat.\n \nThis can be done in multple ways.\n\nAs suggested above, before return store all elements in the array\n\nLoop inside return\nMethod 1\n let container =[];\n    let arr = [1,2,3] //can be anything array, object \n\n    arr.forEach((val,index)=>{\n      container.push(<div key={index}>\n                     val\n                     </div>)\n        /** \n        * 1. All loop generated elements require a key \n        * 2. only one parent element can be placed in Array\n        * e.g. container.push(<div key={index}>\n                                    val\n                              </div>\n                              <div>\n                              this will throw error\n                              </div>  \n                            )\n        **/   \n    });\n    return (\n      <div>\n         <div>any things goes here</div>\n         <div>{container}</div>\n      </div>\n    )\n\nMethod 2\n   return(\n     <div>\n     <div>any things goes here</div>\n     <div>\n        {(()=>{\n          let container =[];\n          let arr = [1,2,3] //can be anything array, object \n          arr.forEach((val,index)=>{\n            container.push(<div key={index}>\n                           val\n                           </div>)\n                         });\n                    return container;     \n        })()}\n\n     </div>\n  </div>\n)\n\n\n\n \nHere's a simple solution to it.\nvar Object_rows = [];\nfor (var i = 0; i < numrows; i++) {\n  Object_rows.push(<ObjectRow />);\n}\n<tbody>{Object_rows}</tbody>;\n\n\nNo mapping and complex code required. You just need to push the rows to the array and return the values to render it.\n \nSince you are writing Javascript syntax inside JSX code, you need to wrap your Javascript in curly braces.\nrow = () => {\n   var rows = [];\n   for (let i = 0; i<numrows; i++) {\n       rows.push(<ObjectRow/>);\n   }\n   return rows;\n}\n<tbody>\n{this.row()}  \n</tbody>\n\n \nYou can also use a self-invoking function:     \nreturn <tbody>\n           {(() => {\n              let row = []\n              for (var i = 0; i < numrows; i++) {\n                  row.push(<ObjectRow key={i} />)\n              }\n              return row\n\n           })()}\n        </tbody>\n\n \nHere is a sample from React doc:JavaScript Expressions as Children\nfunction Item(props) {\n  return <li>{props.message}</li>;\n}\n\nfunction TodoList() {\n  const todos = ['finish doc', 'submit pr', 'nag dan to review'];\n  return (\n    <ul>\n      {todos.map((message) => <Item key={message} message={message} />)}\n    </ul>\n  );\n}\n\nas your case, I suggest writing like this:\nfunction render() {\n  return (\n    <tbody>\n      {numrows.map((roe, index) => <ObjectRow key={index} />)}\n    </tbody>\n  );\n}\n\nPlease notice the Key is very important, because React use Key to differ data in array.\n \nI use it like\n<tbody>\n  { numrows ? (\n     numrows.map(obj => { return <ObjectRow /> }) \n    ) : null\n  }\n</tbody>\n\n \nYou can do something like:\nlet foo = [1,undefined,3]\n{ foo.map(e => !!e ? <Object /> : null )}\n\n \nGreat question.\nWhat I do when I want to add a certain number of components is use a helper function.\nDefine a function that returns JSX:\nconst myExample = () => {\n    let myArray = []\n    for(let i = 0; i<5;i++) {\n        myArray.push(<MyComponent/>)\n    }\n    return myArray\n}\n\n//... in JSX\n\n<tbody>\n    {myExample()}\n</tbody>\n\n", "\nWhen a react component state changes, the render method is called. Hence for any state change, an action can be performed in the render methods body. Is there a particular use case for the setState callback then?\n \nYes there is, since setState works in an asynchronous way. That means after calling setState the this.state variable is not immediately changed. so if you want to perform an action immediately after setting state on a state variable and then return a result, a callback will be useful\nConsider the example below\n....\nchangeTitle: function changeTitle (event) {\n  this.setState({ title: event.target.value });\n  this.validateTitle();\n},\nvalidateTitle: function validateTitle () {\n  if (this.state.title.length === 0) {\n    this.setState({ titleError: \"Title can't be blank\" });\n  }\n},\n....\n\nThe above code may not work as expected since the title variable may not have mutated before validation is performed on it. Now you may wonder that we can perform the validation in the render() function itself but it would be better and a cleaner way if we can handle this in the changeTitle function itself since that would make your code more organised and understandable\nIn this case callback is useful \n....\nchangeTitle: function changeTitle (event) {\n  this.setState({ title: event.target.value }, function() {\n    this.validateTitle();\n  });\n\n},\nvalidateTitle: function validateTitle () {\n  if (this.state.title.length === 0) {\n    this.setState({ titleError: \"Title can't be blank\" });\n  }\n},\n....\n\nAnother example will be when you want to dispatch and action when the state changed. you will want to do it in a callback and not the render() as it will be called everytime rerendering occurs and hence many such scenarios are possible where you will need callback.\nAnother case is a API Call\nA case may arise when you need to make an API call based on a particular state change, if you do that in the render method, it will be called on every render onState change or because some Prop passed down to the Child Component changed.\nIn this case you would want to use a setState callback to pass the updated state value to the API call\n....\nchangeTitle: function (event) {\n  this.setState({ title: event.target.value }, () => this.APICallFunction());\n},\nAPICallFunction: function () {\n  // Call API with the updated value\n}\n....\n\n \nthis.setState({\n    name:'value' \n},() => {\n    console.log(this.state.name);\n});\n\n \nThe 1. usecase which comes into my mind, is an api call, which should't go into the render, because it will run for each state change. And the API call should be only performed on special state change, and not on every render.\nchangeSearchParams = (params) => {\n  this.setState({ params }, this.performSearch)\n} \n\nperformSearch = () => {\n  API.search(this.state.params, (result) => {\n    this.setState({ result })\n  });\n}\n\n\nHence for any state change, an action can be performed in the render methods body.\n\nVery bad practice, because the render-method should be pure, it means no actions, state changes, api calls, should be performed, just composite your view and return it. Actions should be performed on some events only. Render is not an event, but componentDidMount for example.\n \nConsider setState call\nthis.setState({ counter: this.state.counter + 1 })\n\nIDEA\n\nsetState may be called in async function\n\nSo you cannot rely on this. If the above call was made inside a async function this will refer to state of component at that point of time but we expected this to refer to property inside state at time setState calling or beginning of async task. And as task was async call thus that property may have changed in time being. Thus it is unreliable to use this keyword to refer to some property of state thus we use callback function whose arguments are previousState and props which means when async task was done and it was time to update state using setState call prevState will refer to state now when setState has not started yet. Ensuring reliability that nextState would not be corrupted.\nWrong Code: would lead to corruption of data\nthis.setState(\n   {counter:this.state.counter+1}\n );\n\nCorrect Code with setState  having call back function:\n this.setState(\n       (prevState,props)=>{\n           return {counter:prevState.counter+1};\n        }\n    );\n\nThus whenever we need to update our current state to next state based on value possed by property just now and all this is happening in async fashion it is good idea to use setState as callback function.\nI have tried to explain it in codepen here CODE PEN\n", "\nWhat does the ... do in this React (using JSX) code and what is it called?\n<Modal {...this.props} title='Modal heading' animation={false}>\n\n \nThat's property spread notation. It was added in ES2018 (spread for arrays/iterables was earlier, ES2015), but it's been supported in React projects for a long time via transpilation (as \"JSX spread attributes\" even though you could do it elsewhere, too, not just attributes).\n{...this.props} spreads out the \"own\" enumerable properties in props as discrete properties on the Modal element you're creating. For instance, if this.props contained a: 1 and b: 2, then\n<Modal {...this.props} title='Modal heading' animation={false}>\n\nwould be the same as\n<Modal a={this.props.a} b={this.props.b} title='Modal heading' animation={false}>\n\nBut it's dynamic, so whatever \"own\" properties are in props are included.\nSince children is an \"own\" property in props, spread will include it. So if the component where this appears had child elements, they'll be passed on to Modal. Putting child elements between the opening tag and closing tags is just syntactic sugar\u00a0\u2014 the good kind\u00a0\u2014 for putting a children property in the opening tag. Example:\n\n\nclass Example extends React.Component {\r\n  render() {\r\n    const { className, children } = this.props;\r\n    return (\r\n      <div className={className}>\r\n      {children}\r\n      </div>\r\n    );\r\n  }\r\n}\r\nReactDOM.render(\r\n  [\r\n    <Example className=\"first\">\r\n      <span>Child in first</span>\r\n    </Example>,\r\n    <Example className=\"second\" children={<span>Child in second</span>} />\r\n  ],\r\n  document.getElementById(\"root\")\r\n);\n.first {\r\n  color: green;\r\n}\r\n.second {\r\n  color: blue;\r\n}\n<div id=\"root\"></div>\r\n\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.6.3/umd/react.production.min.js\"></script>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.6.3/umd/react-dom.production.min.js\"></script>\n\n\n\nSpread notation is handy not only for that use case, but for creating a new object with most (or all) of the properties of an existing object\u00a0\u2014 which comes up a lot when you're updating state, since you can't modify state directly:\nthis.setState(prevState => {\n    return {foo: {...prevState.foo, a: \"updated\"}};\n});\n\nThat replaces this.state.foo with a new object with all the same properties as foo except the a property, which becomes \"updated\":\n\n\nconst obj = {\r\n  foo: {\r\n    a: 1,\r\n    b: 2,\r\n    c: 3\r\n  }\r\n};\r\nconsole.log(\"original\", obj.foo);\r\n// Creates a NEW object and assigns it to `obj.foo`\r\nobj.foo = {...obj.foo, a: \"updated\"};\r\nconsole.log(\"updated\", obj.foo);\n.as-console-wrapper {\r\n  max-height: 100% !important;\r\n}\n\n\n\n \nAs you know  ... are called Spread Attributes which the name represents it allows an expression to be expanded.\nvar parts = ['two', 'three'];\nvar numbers = ['one', ...parts, 'four', 'five']; // [\"one\", \"two\", \"three\", \"four\", \"five\"]\n\nAnd in this case(I'm gonna simplify it). \n//just assume we have an object like this:\nvar person= {\n    name: 'Alex',\n    age: 35 \n}\n\nThis:\n<Modal {...person} title='Modal heading' animation={false} />\n\nis equal to\n<Modal name={person.name} age={person.age} title='Modal heading' animation={false} />\n\nSo in short, it's a neat short-cut, we can say.\n \nThe three dots represent the Spread Operator in ES6. It allows us to do quite a few things in Javascript:\n\nConcatenate arrays \nvar shooterGames = ['Call of Duty', 'Far Cry', 'Resident Evil'];\nvar racingGames = ['Need For Speed', 'Gran Turismo', 'Burnout'];\nvar games = [...shooterGames, ...racingGames];\n\nconsole.log(games)  // ['Call of Duty', 'Far Cry', 'Resident Evil',  'Need For Speed', 'Gran Turismo', 'Burnout']\n\nDestructuring an array \n  var shooterGames = ['Call of Duty', 'Far Cry', 'Resident Evil'];\n  var [first, ...remaining] = shooterGames;\n  console.log(first); //Call of Duty\n  console.log(remaining); //['Far Cry', 'Resident Evil']\n\nCombining two objects\nvar myCrush = {\n  firstname: 'Selena',\n  middlename: 'Marie'\n};\n\nvar lastname = 'my last name';\n\nvar myWife = {\n  ...myCrush,\n  lastname\n}\n\nconsole.log(myWife); // {firstname: 'Selena',\n                     //   middlename: 'Marie',\n                     //   lastname: 'my last name'}\n\n\nThere's another use for the three dots which is known as Rest Parameters and it makes it possible to take all of the arguments to a function in as one array.\n\nFunction arguments as array\n function fun1(...params) { \n\n }  \n\n\n \nThe three dots in JavaScript are spread / rest operator. \nSpread operator\nThe spread syntax allows an expression to be expanded in places where multiple arguments are expected.\nmyFunction(...iterableObj);\n\n[...iterableObj, 4, 5, 6]\n\n[...Array(10)]\n\nRest parameters\nThe rest parameter syntax is used for functions with variable number of arguments. \nfunction(a, b, ...theArgs) {\n  // ...\n}\n\nThe spread / rest operator for arrays was introduced in ES6. There's a State 2 proposal for object spread / rest properties.\nTypeScript also supports the spread syntax and can transpile that into older versions of ECMAScript with minor issues.  \n \nThis is a feature of ES6, which is used in React as well. Look at the below example:\nfunction Sum(x,y,z) {\n   return x + y + z;\n}\nconsole.log(Sum(1,2,3)); //6\n\nThis way is fine if we have a maximum of 3 parameters. But, what if we need to add for example 110 parameters. Should we define them all and add them one by one?\nOf course there is an easier way to do, which is called SPREAD.\nInstead of passing all those parameters you write :\nfunction (...numbers){} \n\nWe have no idea how many parameters we have, but we know there are heaps of those.\nBased on ES6, we can rewrite the above function as below and use the spread and mapping between them to make it as easy as a piece of cake:\nlet Sum = (...numbers) => {\nreturn numbers.reduce((prev, current) => prev + current );\n}\nconsole.log(Sum(1, 2, 3, 4, 5, 6, 7, 8, 9));//45\n\n \nIt's just defining props in a different way in JSX for you! \nIt's using ... array and object operator in ES6 (object one not fully supported yet), so basically if you already define your props, you can pass it to your element this way. \nSo in your case, the code should be something like this:\nfunction yourA() {\n  const props = {name='Alireza', age='35'};\n  <Modal {...props} title='Modal heading' animation={false} />\n}\n\nso the props you defined, now separated and can be reused if necessary.\nIt's equal to:\nfunction yourA() {\n  <Modal name='Alireza' age='35' title='Modal heading' animation={false} />\n}\n\nThese are the quotes from React team about spread operator in JSX:\n\nJSX Spread Attributes\n  If you know all the properties that you want to place on a component\n  ahead of time, it is easy to use JSX:\n\nvar component = <Component foo={x} bar={y} />;\n\n\nMutating Props is Bad If you don't know which properties you want to set, you might be tempted to add them onto the object later:\n\nvar component = <Component />;\ncomponent.props.foo = x; // bad\ncomponent.props.bar = y; // also bad\n\n\nThis is an anti-pattern because it means that we can't help you check\n  the right propTypes until way later. This means that your propTypes\n  errors end up with a cryptic stack trace.\nThe props should be considered immutable. Mutating the props object\n  somewhere else could cause unexpected consequences so ideally it would\n  be a frozen object at this point.\nSpread Attributes Now you can use a new feature of JSX called spread attributes:\n\nvar props = {};\n    props.foo = x;\n    props.bar = y;\n    var component = <Component {...props} />;\n\n\nThe properties of the object that you pass in are copied onto the\n  component's props.\nYou can use this multiple times or combine it with other attributes.\n  The specification order is important. Later attributes override\n  previous ones.\n\nvar props = { foo: 'default' };\nvar component = <Component {...props} foo={'override'} />;\nconsole.log(component.props.foo); // 'override'\n\n\nWhat's with the weird ... notation? The ... operator (or spread operator) is already supported for arrays in ES6. There is also\n  an ECMAScript proposal for Object Rest and Spread Properties. We're\n  taking advantage of these supported and developing standards in order\n  to provide a cleaner syntax in JSX.\n\n \nFor those who come from the Python world, JSX Spread Attributes are equivalent to\nUnpacking Argument Lists (the Python **-operator).\nI'm aware this is a JSX question, but working with analogies sometimes helps to get it faster.\n \nThree dots ... represents Spread Operators or Rest Parameters,\nIt allows an array expression or string or anything which can be iterating to be expanded in places where zero or more arguments for function calls or elements for array are expected. \n\nMerge two arrays\n\n\n\nvar arr1 = [1,2,3];\r\nvar arr2 = [4,5,6];\r\n\r\narr1 = [...arr1, ...arr2];\r\nconsole.log(arr1);  //[1, 2, 3, 4, 5, 6]\n\n\n\n\nCopying array:\n\n\n\nvar arr = [1, 2, 3];\r\nvar arr2 = [...arr];\r\n\r\nconsole.log(arr); //[1, 2, 3]\n\n\n\n\nNote: Spread syntax effectively goes one level deep while copying an\n  array. Therefore, it may be unsuitable for copying multidimensional\n  arrays as the following example shows (it's the same with\n  Object.assign() and spread syntax).\n\n\nAdd values of one array to other at specific index e.g 3:\n\n\n\nvar arr1 = [4,5]\r\nvar arr2 = [1,2,3,...arr1,6]\r\nconsole.log(arr2);\t// [1, 2, 3, 4, 5, 6]\n\n\n\n\nWhen calling a constructor with new:\n\n\n\nvar dateFields = [1970, 0, 1];  // 1 Jan 1970\r\nvar d = new Date(...dateFields);\r\n\r\nconsole.log(d);\n\n\n\n\nSpread in object literals:\n\n\n\nvar obj1 = { foo: 'bar', x: 42 };\r\nvar obj2 = { foo: 'baz', y: 13 };\r\n\r\nvar clonedObj = { ...obj1 };\r\nconsole.log(clonedObj);\t//{foo: \"bar\", x: 42}\r\n\r\nvar mergedObj = { ...obj1, ...obj2 };\r\nconsole.log(mergedObj);\t//{foo: \"baz\", x: 42, y: 13}\n\n\n\nNote that foo property of obj1 has been overwritten by obj2 foo property \n\nAs a rest parameter syntax which allows us to represent an indefinite number of arguments as an array:\n\n\n\nfunction sum(...theArgs) {\r\n  return theArgs.reduce((previous, current) => {\r\n    return previous + current;\r\n  });\r\n}\r\n\r\nconsole.log(sum(1, 2, 3));\t//6\r\nconsole.log(sum(1, 2, 3, 4));\t//10\n\n\n\nNote:Spread syntax (other than in the case of spread properties) can be applied only to iterable objects:\nSo following will throw error\n\n\nvar obj = {'key1': 'value1'};\r\nvar array = [...obj]; // TypeError: obj is not iterable\n\n\n\nReference1\nReference2\n \nThe ...(spread operator) is used in react to:\nprovide a neat way to pass props from parent to child components. e.g given these props in a parent component,\nthis.props = {\n  username: \"danM\",\n  email: \"dan@mail.com\"\n}\n\nthey could be passed in the following manner to the child,\n<ChildComponent {...this.props} />\n\nwhich is similar to this\n<ChildComponent username={this.props.username} email={this.props.email} />\n\nbut way cleaner.\n \nKudos to Brandon Morelli. He explained perfectly here, but links may die so I am just pasting the content below:\nThe spread syntax is simply three dots: ...\nIt allows an iterable to expand in places where 0+ arguments are expected.\nDefinitions are tough without context. Let's explore some different use cases to help understand what this means.\nExample #1 \u2014 Inserting Arrays\nTake a look at the code below. In this code, we don\u2019t use the spread syntax:\n\n\nvar mid = [3, 4];\r\nvar arr = [1, 2, mid, 5, 6];\r\n\r\nconsole.log(arr);\n\n\n\nAbove, we\u2019ve created an array named mid. We then create a second array which contains our mid array. Finally, we log out the result. What do you expect arr to print? Click run above to see what happens. Here is the output:\n[1, 2, [3, 4], 5, 6]\n\nIs that the result you expected?\nBy inserting the mid array into the arr array, we\u2019ve ended up with an array within an array. That\u2019s fine if that was the goal. But what if you want only a single array with the values of 1 through 6? To accomplish this, we can use the spread syntax! Remember, the spread syntax allows the elements of our array to expand.\nLets look at the code below. Everything is the same \u2014 except we\u2019re now using the spread syntax to insert the mid array into the arr array:\n\n\nvar mid = [3, 4];\r\nvar arr = [1, 2, ...mid, 5, 6];\r\n\r\nconsole.log(arr);\n\n\n\nAnd when you hit the run button, here\u2019s the result:\n[1, 2, 3, 4, 5, 6]\n\nAwesome!\nRemember the spread syntax definition you just read above? Here\u2019s where it comes into play. As you can see, when we create the arr array and use the spread operator on the mid array, instead of just being inserted, the mid array expands. This expansion means that each and every element in the mid array is inserted into the arr array. Instead of nested arrays, the result is a single array of numbers ranging from 1 to 6.\nExample #2 \u2014 Math\nJavaScript has a built in math object that allows us to do some fun math calculations. In this example we\u2019ll be looking at Math.max(). If you\u2019re unfamiliar, Math.max() returns the largest of zero or more numbers. Here are a few examples:\nMath.max();\n// -Infinity\nMath.max(1, 2, 3);\n// 3\nMath.max(100, 3, 4);\n// 100\n\nAs you can see, if you want to find the maximum value of multiple numbers, Math.max() requires multiple parameters. You unfortunately can\u2019t simply use a single array as input. Before the spread syntax, the easiest way to use Math.max() on an array is to use .apply()\n\n\nvar arr = [2, 4, 8, 6, 0];\r\n\r\nfunction max(arr) {\r\n  return Math.max.apply(null, arr);\r\n}\r\n\r\nconsole.log(max(arr));\n\n\n\nIt works, it\u2019s just really annoying.\nNow take a look at how we do the same exact thing with the spread syntax:\n\n\nvar arr = [2, 4, 8, 6, 0];\r\nvar max = Math.max(...arr);\r\n\r\nconsole.log(max);\n\n\n\nInstead of having to create a function and utilize the apply method to return the result of Math.max() , we only need two lines of code! The spread syntax expands our array elements and inputs each element in our array individually into the Math.max() method!\nExample #3 \u2014 Copy an Array\nIn JavaScript, you can\u2019t just copy an array by setting a new variable equal to already existing array. Consider the following code example:\n\n\nvar arr = ['a', 'b', 'c'];\r\nvar arr2 = arr;\r\n\r\nconsole.log(arr2);\n\n\n\nWhen you press run, you\u2019ll get the following output:\n['a', 'b', 'c']\n\nNow, at first glance, it looks like it worked \u2014 it looks like we\u2019ve copied the values of arr into arr2. But that\u2019s not what has happened. You see, when working with objects in javascript (arrays are a type of object) we assign by reference, not by value. This means that arr2 has been assigned to the same reference as arr. In other words, anything we do to arr2 will also affect the original arr array (and vice versa). Take a look below:\n\n\nvar arr = ['a', 'b', 'c'];\r\nvar arr2 = arr;\r\n\r\narr2.push('d');\r\n\r\nconsole.log(arr);\n\n\n\nAbove, we\u2019ve pushed a new element d into arr2. Yet, when we log out the value of arr, you\u2019ll see that the d value was also added to that array:\n['a', 'b', 'c', 'd']\n\nNo need to fear though! We can use the spread operator!\nConsider the code below. It\u2019s almost the same as above. Instead though, we\u2019ve used the spread operator within a pair of square brackets:\n\n\nvar arr = ['a', 'b', 'c'];\r\nvar arr2 = [...arr];\r\n\r\nconsole.log(arr2);\n\n\n\nHit run, and you\u2019ll see the expected output:\n['a', 'b', 'c']\n\nAbove, the array values in arr expanded to become individual elements which were then assigned to arr2. We can now change the arr2 array as much as we\u2019d like with no consequences on the original arr array:\n\n\nvar arr = ['a', 'b', 'c'];\r\nvar arr2 = [...arr];\r\n\r\narr2.push('d');\r\n\r\nconsole.log(arr);\n\n\n\nAgain, the reason this works is because the value of arr is expanded to fill the brackets of our arr2 array definition. Thus, we are setting arr2 to equal the individual values of arr instead of the reference to arr like we did in the first example.\nBonus Example \u2014 String to Array\nAs a fun final example, you can use the spread syntax to convert a string into an array. Simply use the spread syntax within a pair of square brackets:\n\n\nvar str = \"hello\";\r\nvar chars = [...str];\r\n\r\nconsole.log(chars);\n\n\n\n \nThe three dots (...) are called the spread operator, and this is conceptually similar to the ES6 array spread operator, JSX\ntaking advantage of these supported and developing standards in order to provide a cleaner syntax in JSX\n\nSpread properties in object initializers copies own enumerable\n  properties from a provided object onto the newly created object.\nlet n = { x, y, ...z };\nn; // { x: 1, y: 2, a: 3, b: 4 }\n\n\nReference: \n1) https://github.com/sebmarkbage/ecmascript-rest-spread#spread-properties\n2) https://facebook.github.io/react/docs/jsx-spread.html\n \n... (three dots in Javascript) is called the Spread Syntax or Spread Operator. This allows an iterable such as an array expression or string to be expanded or an object expression to be expanded wherever placed. This is not specific to React. It is a Javascript operator.\nAll these answers here are helpful, but I want to list down the mostly used practical Use Cases of the Spread Syntax (Spread Operator).\n1. Combine Arrays (Concatenate Arrays)\nThere are a variety of ways to combine arrays, but the spread operator allows you to place this at any place in an array. If you'd like to combine two arrays and place elements at any point within the array, you can do as follows:\nvar arr1 = ['two', 'three'];\nvar arr2 = ['one', ...arr1, 'four', 'five'];\n\n// arr2 = [\"one\", \"two\", \"three\", \"four\", \"five\"]\n\n2. Copying Arrays\nWhen we wanted a copy of an array, we used to have the Array.prototypr.slice() method. But, you can do the same with the spread operator.\nvar arr = [1,2,3];\nvar arr2 = [...arr];\n// arr2 = [1,2,3]\n\n3. Calling Functions without Apply\nIn ES5, to pass an array of two numbers to the doStuff() function, you often use the Function.prototype.apply() method as follows:\nfunction doStuff (x, y, z) { }\nvar args = [0, 1, 2];\n\n// Call the function, passing args\ndoStuff.apply(null, args);\n\nHowever, by using the spread operator, you can pass an array into the function.\ndoStuff(...args);\n\n4. Destructuring Arrays\nYou can use destructuring and the rest operator together to extract the information into variables as you'd like them:\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nconsole.log(x); // 1\nconsole.log(y); // 2\nconsole.log(z); // { a: 3, b: 4 }\n\n5. Function Arguments as Rest Parameters\nES6 also has the three dots ( ...) which is a rest parameter that collects all remaining arguments of a function into an array.\nfunction f(a, b, ...args) {\n  console.log(args);\n}\n\nf(1,2,3,4,5);\n// [ 3, 4, 5 ]\n\n6. Using Math Functions\nAny function where spread is used as the argument can be used by functions that can accept any number of arguments.\nlet numbers = [9, 4, 7, 1];\nMath.min(...numbers); // 1\n\n7. Combining Two Objects\nYou can use the spread operator to combine two objects. This is an easy and cleaner way to do it.\nvar carType = {\n  model: 'Toyota',\n  yom: '1995'\n};\n\nvar carFuel = 'Petrol';\n\nvar carData = {\n  ...carType,\n  carFuel\n}\n\nconsole.log(carData); \n// {\n//  model: 'Toyota',\n//  yom: '1995',\n//  carFuel = 'Petrol'\n// }\n\n8. Separate a String into Separate Characters\nYou can use the spread operator to spread a string into separate characters.\nlet chars = ['A', ...'BC', 'D'];\nconsole.log(chars); // [\"A\", \"B\", \"C\", \"D\"]\n\nYou can think of more ways to use the Spread Operator. What I have listed here are the popular use cases of it.\n \nThe meaning of ... depends on where you use it in the code,\n\nUsed for spreading/copying the array/object  - It helps to copy array/object and also add new array values/add new properties to object, which is optional.\n\n\n\nconst numbers = [1,2,3];\r\nconst newNumbers = [...numbers, 4];\r\nconsole.log(newNumbers) //prints [1,2,3,4] \n\n\n\n\n\nconst person = {\r\n name: 'Max'\r\n};\r\n\r\nconst newPerson = {...person, age:28};\r\nconsole.log(newPerson); //prints {name:'Max', age:28}\n\n\n\n\nUsed for merging the function arguments into a single array - You can then use array functions on it.\n\n\n\nconst filter = (...args) => {\r\n   return args.filter(el => el ===1);\r\n}\r\n\r\nconsole.log(filter(1,2,3)); //prints [1] \n\n\n\n \nThis a spread operator... \nFor example if you have an array first=[1,2,3,4,5] and another second=[6,7,8]. \n[...first, ...second] //result is [1,2,3,4,5,6,7,8]\nThe same can also be done with json objects. \n \nIn a short, the three dots ... is a spread operator in ES6(ES2015). Spread operator will fetch all the data.\nlet a = [1, 2, 3, 4];\nlet b = [...a, 4, 5, 6];\nlet c = [7,8,...a];\n\n\nconsole.log(b);\n\nWill give the result [1,2,3,4,5,6]\nconsole.log(c);\n\nWill give the result [7,8,1,2,3,4]\n \n\nSpread Attributes used to Pass the multiple Properties in a Simple Way\n\n{ ... this.props } is Holding the property of this.props\n\nUse of the { ... } Spread Operator with below props\nthis.props = \n { \n    firstName: 'Dan', \n    lastName: 'Abramov', \n    city: 'New York',\n    country: 'USA' \n}\n\n\nWithout { ... } Spread\n\n<Child \n  firstName={this.props.firstName}\n  lastName={this.props.lastName}\n  city={this.props.city}\n  country={this.props.country}\n\n> \n\n\nWith { ... } Spread\n\n<Child { ...this.props } />\n\nDan Abramov's  Tweet about Spread operator (Creator of Redux)\n\n \nIs usually called spread operator, it is use to expand wherever is required\nexample \nconst SomeStyle = {\n   margin:10,\n   background:#somehexa\n}\n\nyou can use this where ever you requires it\nmore about spread operator Spread syntax.  \n \n...  this syntax is part of ES6 and not something which you can use only in React.It can be used in two different ways; as a spread operator OR as a rest parameter.You can find more from this article: https://www.techiediaries.com/react-spread-operator-props-setstate/ \nwhat you have mentioned in the question is something like this,\nlet's assume like this,\n    function HelloUser() {\n      return <Hello Name=\"ABC\" City=\"XYZ\" />;\n    }\n\nwith the use of spread operator you can pass props to the component like this.\n     function HelloUser() {\n       const props = {Name: 'ABC', City: 'XYZ'};\n       return <Hello {...props} />;\n     }\n\n \nIt is common practice to pass props around in a React application.  In doing this we able to apply state changes to the child component regardless of whether it is Pure or Impure (stateless or stateful).  There are times when the best approach, when passing in props, is to pass in singular properties or an entire object of properties.  With the support for arrays in ES6 we were given the \"...\" notation and with this we are now able to achieve passing an entire object to a child.  \nThe typical process of passing props to a child is noted with this syntax:\nvar component = <Component foo={x} bar={y} />;\n\nThis is fine to use when the number of props is minimal but becomes unmanageable when the prop numbers get too much higher.  A problem with this method occurs when you do not know the properties needed within a child component and the typical JavaScript method is to simple set those properties and bind to the object later.  This causes issues with propType checking and cryptic stack trace errors that are not helpful and cause delays in debugging.  The following is an example of this practice, and what not to do:\nvar component = <Component />;\ncomponent.props.foo = x; // bad\ncomponent.props.bar = y;\n\nThis same result can be achieved but with more appropriate success by doing this:\nvar props = {};\nprops.foo = x;\nprops.bar = y;\nvar component = Component(props); // Where did my JSX go?\n\nBut does not use JSX spread or JSX so to loop this back into the equation we can now do something like this: \nvar props = {};\nprops.foo = x;\nprops.bar = y;\nvar component = <Component {...props} />;\n\nThe properties included in \"...props\" are foo: x, bar: y.  This can be combined with other attributes to override the properties of \"...props\" using this syntax:\nvar props = { foo: 'default' };\nvar component = <Component {...props} foo={'override'} />;\nconsole.log(component.props.foo); // 'override'\n\nIn addition we can copy other property objects onto each other or combine them in this manner:\nvar oldObj = { foo: 'hello', bar: 'world' };\nvar newObj = { ...oldObj, foo: 'hi' };\nconsole.log(newObj.foo); // 'hi';\nconsole.log(newObj.bar); // 'world';\n\nOr merge two different objects like this (this is not yet available in all react versions): \nvar ab = { ...a, ...b }; // merge(a, b)\n\nAnother way of explaining this, according to Facebook's react/docs site is:\nIf you already have \"props\" as an object, and you want to pass it in JSX, you can use \"...\" as a SPREAD operator to pass the whole props object.  The following two examples are equivalent: \nfunction App1() {\n  return <Greeting firstName=\"Ben\" lastName=\"Hector\" />;\n}\n\n\n\nfunction App2() {\n  const props = {firstName: 'Ben', lastName: 'Hector'};\n  return <Greeting {...props} />;\n}\n\nSpread attributes can be useful when you are building generic containers.  However, they can also make your code messy by making it easy to pass a lot of irrelevant props to components that don't care about them.  This syntax should be used sparingly.\n \nIts called spread operator.\nFor eg\nlet hello={name: '',msg:''}\nlet hello1={...hello}\nNow hello object properties is copied to hello1.\n \nIt is called spreads syntax in javascript. \nIt use for destructuring an array or object in javascript.\nexample:\nconst objA = { a: 1, b: 2, c: 3 }\nconst objB = { ...objA, d: 1 }\n/* result of objB will be { a: 1, b: 2, c: 3, d: 1 } */\nconsole.log(objB)\n\nconst objC = { ....objA, a: 3 }\n/* result of objC will be { a: 3, b: 2, c: 3, d: 1 } */\nconsole.log(objC)\n\nYou can do it same result with Object.assign() function in javascript.\nReference:Spread syntax\n \nThis will be compiled into:\nReact.createElement(Modal, { ...this.props, title: \"Modal heading\", animation: false }, child0, child1, child2, ...)\n\nwhere it gives more two properties title & animation beyond the props the host element has.\n... is the ES6 operator called Spread.\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\n \nspread operator(triple operator) introduce in ecama script 6(ES6).Ecama script(ES6) is a wrapper of javascript.\nspread operator enumerable properties in props.\nthis.props = \n { \n    firstName: 'Dan', \n    lastName: 'Abramov', \n    city: 'New York',\n    country: 'USA' \n}\n\n\n{...this.props} = { firstName: 'Dan', \n      lastName: 'Abramov', \n      city: 'New York',\n      country: 'USA' }\n\nBut the main feature spread operator is used for a reference type.\nFor example\nlet person= {\n    name: 'Alex',\n    age: 35 \n}\nperson1= person;\n\nperson1.name = \"Raheel\";\n\nconsole.log( person.name); // output: Raheel\n\nThis is called reference type, one object affects other objects because they are shareable in memory. If you getting value independently mean spread memory both use spread operator.\n let person= {\n        name: 'Alex',\n        age: 35 \n    }\nperson2 = {...person};\n\nperson2.name = \"Shahzad\";\n\nconsole.log(person.name); // output: Alex\n\n \nif you have an array of elements and you want to display the elements you just use ...arrayemaments and it will iterate over all the elements \n \nconst Profile =  {\n          firstName: \"kazi\",\n          lastName: \"ahsan\"\n   }\n\nconst ProfileUpdate =  {\n          firstName: \"kazi\",\n          lastName: \"ahsan\"\n }\n\n\nconst newProfile = {...Profile, ...ProfileUpdate}\n\nHope this helps someone.\n \nThese three dots are called spread operator.\nSpread operator helps us to create a copy state or props in react.\nUsing spread operator in react state\nconst [myState, setMyState] = useState({\n    variable1: 'test',\n    variable2: '',\n    variable3: ''\n});\n\nsetMyState({...myState, variable2: 'new value here'});\n\nin the above code spread operator will maintain a copy of current state and we will also add new value at same time, if we don't do this then state will have only value of variable2\nspread operator helps us to write optimize code\n \nThis is a new feature in ES6/Harmony. It is called the Spread Operator.\nIt lets you either separate the constituent parts of an array/object, or take multiple items/parameters and glue them together.\nHere is an example:\nlet array = [1,2,3]\nlet array2 = [...array]\n// array2 is now filled with the items from array\n\nAnd with an object/keys:\n// lets pass an object as props to a react component\nlet myParameters = {myKey: 5, myOtherKey: 7}\nlet component = <MyComponent {...myParameters}/>\n// this is equal to <MyComponent myKey=5 myOtherKey=7 />\n\nWhat's really cool is you can use it to mean \"the rest of the values\".\nconst myFunc = (value1, value2, ...values) {\n    // Some code\n}\n\nmyFunc(1, 2, 3, 4, 5)\n// when myFunc is called, the rest of the variables are placed into the \"values\" array\n\n \nFor someone who wants to understand this simple and fast:\nFirst of all, this is not a syntax only to react. this is a syntax from ES6 called Spread syntax which iterate(merge, add..etc) array and object. read more about here\nSo answer to the question:\nlet's imagine you have this tag:\n<UserTag name=\"Supun\" age=\"66\" gender=\"male\" />\nand You do this:\nconst user = {\n  \"name\"=>\"Joe\",\n  \"age\"=>\"50\"      \n  \"test\"=>\"test-val\"\n};\n\n<UserTag name=\"Supun\" gender=\"male\"  {...user} age=\"66\" />\n\nthen the tag will equal this:\n<UserTag name=\"Joe\" gender=\"male\" test=\"test-val\" age=\"66\" />\n\nSo what happened was when you use Spread syntax in a react tag it takes tag's attribute as object attributes which merge(replace if it exists) with the given object user. also, you might have noticed one thing that it only replaces before attribute, not after attributes. so in this example age remains as it is.\nHopes this helps :)\n \nThose are called spreads. Just as the name implies. It means it's putting whatever the value of it in those array or objects. \nSuch as :\nlet a = [1, 2, 3];\nlet b = [...a, 4, 5, 6];\nconsole.log(b);\n> [1, 2, 3, 4, 5, 6]\n\n", "\nI'm trying to find the proper way to define some components which could be used in a generic way:\n<Parent>\n  <Child value=\"1\">\n  <Child value=\"2\">\n</Parent>\n\nThere is a logic going on for rendering between parent and children components of course, you can imagine <select> and <option> as an example of this logic.\nThis is a dummy implementation for the purpose of the question:\nvar Parent = React.createClass({\n  doSomething: function(value) {\n  },\n  render: function() {\n    return (<div>{this.props.children}</div>);\n  }\n});\n\nvar Child = React.createClass({\n  onClick: function() {\n    this.props.doSomething(this.props.value); // doSomething is undefined\n  },\n  render: function() {\n    return (<div onClick={this.onClick}></div>);\n  }\n});\n\nThe question is whenever you use {this.props.children} to define a wrapper component, how do you pass down some property to all its children?\n \nCloning children with new props\nYou can use React.Children to iterate over the children, and then clone each element with new props (shallow merged) using React.cloneElement. For example:\nconst Child = ({ doSomething, value }) => (\n    <button onClick={() => doSomething(value)}>Click Me</button>\n);\n\nclass Parent extends React.Component{\n    doSomething = value => {\n        console.log(\"doSomething called by child with value:\", value);\n    }\n\n    render() {\n        const childrenWithProps = React.Children.map(this.props.children, child => {\n            // checking isValidElement is the safe way and avoids a typescript error too\n            const props = { doSomething };\n            if (React.isValidElement(child)) {\n                return React.cloneElement(child, props);\n            }\n            return child;\n        });\n\n        return <div>{childrenWithProps}</div>;\n    }\n}\n\nfunction App() {\n    return (\n        <Parent>\n            <Child value={1} />\n            <Child value={2} />\n        </Parent>\n    );\n}\n\nReactDOM.render(<App />, document.getElementById(\"container\"));\n\nFiddle: https://jsfiddle.net/2q294y43/2/\nCalling children as a function\nAlternatively, you can pass props to children with render props. In this approach, the children (which can be children or any other prop name) is a function which can accept any arguments you want to pass and returns the children:\nconst Child = ({ doSomething, value }) => (\n    <button onClick={() => doSomething(value)}>Click Me</button>\n);\n\nclass Parent extends React.Component{\n    doSomething = value => {\n        console.log(\"doSomething called by child with value:\", value);\n    }\n\n    render(){\n        // note that children is called as a function and we can pass args to it\n        return <div>{this.props.children(doSomething)}</div>\n    }\n};\n\nfunction App(){\n    return (\n        <Parent>\n            {doSomething => (\n                <React.Fragment>\n                    <Child doSomething={doSomething} value={1} />\n                    <Child doSomething={doSomething} value={2} />\n                </React.Fragment>\n            )}\n        </Parent>\n    );\n}\n \nReactDOM.render(<App />, document.getElementById(\"container\"));\n\nInstead of <React.Fragment> or simply <> you can also return an array if you prefer.\nFiddle: https://jsfiddle.net/ferahl/y5pcua68/7/\n \nFor a slightly cleaner way to do it, try:\n<div>\n    {React.cloneElement(this.props.children, { loggedIn: this.state.loggedIn })}\n</div>\n\nEdit:\nTo use with multiple individual children (the child must itself be a component) you can do. Tested in 16.8.6\n<div>\n    {React.cloneElement(props.children[0], { loggedIn: true, testingTwo: true })}\n    {React.cloneElement(props.children[1], { loggedIn: true, testProp: false })}\n</div>\n\n \nTry this\n<div>{React.cloneElement(this.props.children, {...this.props})}</div>\n\nIt worked for me using react-15.1.\n \nPass props to direct children.\nSee all other answers\nPass shared, global data through the component tree via context\n\nContext is designed to share data that can be considered \u201cglobal\u201d for a tree of React components, such as the current authenticated user, theme, or preferred language. 1\n\nDisclaimer: This is an updated answer, the previous one used the old context API\nIt is based on Consumer / Provide principle. First, create your context \nconst { Provider, Consumer } = React.createContext(defaultValue);\n\nThen use via\n<Provider value={/* some value */}>\n  {children} /* potential consumers */\n<Provider />\n\nand \n<Consumer>\n  {value => /* render something based on the context value */}\n</Consumer>\n\n\nAll Consumers that are descendants of a Provider will re-render whenever the Provider\u2019s value prop changes. The propagation from Provider to its descendant Consumers is not subject to the shouldComponentUpdate method, so the Consumer is updated even when an ancestor component bails out of the update.  1 \n\nFull example, semi-pseudo code.\nimport React from 'react';\n\nconst { Provider, Consumer } = React.createContext({ color: 'white' });\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      value: { color: 'black' },\n    };\n  }\n\n  render() {\n    return (\n      <Provider value={this.state.value}>\n        <Toolbar />\n      </Provider>\n    );\n  }\n}\n\nclass Toolbar extends React.Component {\n  render() {\n    return ( \n      <div>\n        <p> Consumer can be arbitrary levels deep </p>\n        <Consumer> \n          {value => <p> The toolbar will be in color {value.color} </p>}\n        </Consumer>\n      </div>\n    );\n  }\n}\n\n1 https://facebook.github.io/react/docs/context.html\n \nPassing Props to Nested Children\nWith the update to React 16.6 you can now use React.createContext and contextType. \nimport * as React from 'react';\n\n// React.createContext accepts a defaultValue as the first param\nconst MyContext = React.createContext(); \n\nclass Parent extends React.Component {\n  doSomething = (value) => {\n    // Do something here with value\n  };\n\n  render() {\n    return (\n       <MyContext.Provider value={{ doSomething: this.doSomething }}>\n         {this.props.children}\n       </MyContext.Provider>\n    );\n  }\n}\n\nclass Child extends React.Component {\n  static contextType = MyContext;\n\n  onClick = () => {\n    this.context.doSomething(this.props.value);\n  };      \n\n  render() {\n    return (\n      <div onClick={this.onClick}>{this.props.value}</div>\n    );\n  }\n}\n\n\n// Example of using Parent and Child\n\nimport * as React from 'react';\n\nclass SomeComponent extends React.Component {\n\n  render() {\n    return (\n      <Parent>\n        <Child value={1} />\n        <Child value={2} />\n      </Parent>\n    );\n  }\n}\n\n\nReact.createContext shines where React.cloneElement case couldn't handle nested components\n\nclass SomeComponent extends React.Component {\n\n  render() {\n    return (\n      <Parent>\n        <Child value={1} />\n        <SomeOtherComp><Child value={2} /></SomeOtherComp>\n      </Parent>\n    );\n  }\n}\n\n \nYou can use React.cloneElement, it's better to know how it works before you start using it in your application. It's introduced in React v0.13, read on for more information, so something along with this work for you:\n<div>{React.cloneElement(this.props.children, {...this.props})}</div>\n\nSo bring the lines from React documentation for you to understand how it's all working and how you can make use of them:\n\nIn React v0.13 RC2 we will introduce a new API, similar to\n  React.addons.cloneWithProps, with this signature:\n\nReact.cloneElement(element, props, ...children);\n\n\nUnlike cloneWithProps, this new function does not have any magic\n  built-in behavior for merging style and className for the same reason\n  we don't have that feature from transferPropsTo. Nobody is sure what\n  exactly the complete list of magic things are, which makes it\n  difficult to reason about the code and difficult to reuse when style\n  has a different signature (e.g. in the upcoming React Native).\nReact.cloneElement is almost equivalent to:\n\n<element.type {...element.props} {...props}>{children}</element.type>\n\n\nHowever, unlike JSX and cloneWithProps, it also preserves refs. This\n  means that if you get a child with a ref on it, you won't accidentally\n  steal it from your ancestor. You will get the same ref attached to\n  your new element.\nOne common pattern is to map over your children and add a new prop.\n  There were many issues reported about cloneWithProps losing the ref,\n  making it harder to reason about your code. Now following the same\n  pattern with cloneElement will work as expected. For example:\n\nvar newChildren = React.Children.map(this.props.children, function(child) {\n  return React.cloneElement(child, { foo: true })\n});\n\n\nNote: React.cloneElement(child, { ref: 'newRef' }) DOES override the\n  ref so it is still not possible for two parents to have a ref to the\n  same child, unless you use callback-refs.\nThis was a critical feature to get into React 0.13 since props are now\n  immutable. The upgrade path is often to clone the element, but by\n  doing so you might lose the ref. Therefore, we needed a nicer upgrade\n  path here. As we were upgrading callsites at Facebook we realized that\n  we needed this method. We got the same feedback from the community.\n  Therefore we decided to make another RC before the final release to\n  make sure we get this in.\nWe plan to eventually deprecate React.addons.cloneWithProps. We're not\n  doing it yet, but this is a good opportunity to start thinking about\n  your own uses and consider using React.cloneElement instead. We'll be\n  sure to ship a release with deprecation notices before we actually\n  remove it so no immediate action is necessary.\n\nmore here...\n \nThe best way, which allows you to make property transfer is children like a function pattern\nhttps://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9\nCode snippet: https://stackblitz.com/edit/react-fcmubc\nExample:\nconst Parent = ({ children }) => {\n    const somePropsHere = {\n      style: {\n        color: \"red\"\n      }\n      // any other props here...\n    }\n    return children(somePropsHere)\n}\n\nconst ChildComponent = props => <h1 {...props}>Hello world!</h1>\n\nconst App = () => {\n  return (\n    <Parent>\n      {props => (\n        <ChildComponent {...props}>\n          Bla-bla-bla\n        </ChildComponent>\n      )}\n    </Parent>\n  )\n}\n\n\n \nNone of the answers address the issue of having children that are NOT React components, such as text strings. A workaround could be something like this:\n// Render method of Parent component\nrender(){\n    let props = {\n        setAlert : () => {alert(\"It works\")}\n    };\n    let childrenWithProps = React.Children.map( this.props.children, function(child) {\n        if (React.isValidElement(child)){\n            return React.cloneElement(child, props);\n        }\n          return child;\n      });\n    return <div>{childrenWithProps}</div>\n\n}\n\n \nI needed to fix accepted answer above to make it work using that instead of this pointer. This within the scope of map function didn't have doSomething function defined.\nvar Parent = React.createClass({\ndoSomething: function() {\n    console.log('doSomething!');\n},\n\nrender: function() {\n    var that = this;\n    var childrenWithProps = React.Children.map(this.props.children, function(child) {\n        return React.cloneElement(child, { doSomething: that.doSomething });\n    });\n\n    return <div>{childrenWithProps}</div>\n}})\n\nUpdate: this fix is for ECMAScript 5, in ES6 there is no need in var that=this\n \nCleaner way considering one or more children\n<div>\n   { React.Children.map(this.props.children, child => React.cloneElement(child, {...this.props}))}\n</div>\n\n \nYou no longer need {this.props.children}. Now you can wrap your child component using render in Route and pass your props as usual:\n<BrowserRouter>\n  <div>\n    <ul>\n      <li><Link to=\"/\">Home</Link></li>\n      <li><Link to=\"/posts\">Posts</Link></li>\n      <li><Link to=\"/about\">About</Link></li>\n    </ul>\n\n    <hr/>\n\n    <Route path=\"/\" exact component={Home} />\n    <Route path=\"/posts\" render={() => (\n      <Posts\n        value1={1}\n        value2={2}\n        data={this.state.data}\n      />\n    )} />\n    <Route path=\"/about\" component={About} />\n  </div>\n</BrowserRouter>\n\n \nIf you have multiple children you want to pass props to, you can do it this way, using the React.Children.map:\nrender() {\n    let updatedChildren = React.Children.map(this.props.children,\n        (child) => {\n            return React.cloneElement(child, { newProp: newProp });\n        });\n\n    return (\n        <div>\n            { updatedChildren }\n        </div>\n    );\n}\n\nIf your component is having just one child, there's no need for mapping, you can just cloneElement straight away:\nrender() {\n    return (\n        <div>\n            {\n                React.cloneElement(this.props.children, {\n                    newProp: newProp\n                })\n            }\n        </div>\n    );\n}\n\n \nParent.jsx:\nimport React from 'react';\n\nconst doSomething = value => {};\n\nconst Parent = props => (\n  <div>\n    {\n      !props || !props.children \n        ? <div>Loading... (required at least one child)</div>\n        : !props.children.length \n            ? <props.children.type {...props.children.props} doSomething={doSomething} {...props}>{props.children}</props.children.type>\n            : props.children.map((child, key) => \n              React.cloneElement(child, {...props, key, doSomething}))\n    }\n  </div>\n);\n\nChild.jsx:\nimport React from 'react';\n\n/* but better import doSomething right here,\n   or use some flux store (for example redux library) */\nexport default ({ doSomething, value }) => (\n  <div onClick={() => doSomething(value)}/>\n);\n\nand main.jsx:\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Parent from './Parent';\nimport Child from './Child';\n\nrender(\n  <Parent>\n    <Child/>\n    <Child value='1'/>\n    <Child value='2'/>\n  </Parent>,\n  document.getElementById('...')\n);\n\nsee example here: https://plnkr.co/edit/jJHQECrKRrtKlKYRpIWl?p=preview\n \nMaybe you can also find useful this feature, though many people have considered this as an anti-pattern it still can be used if you're know what you're doing and design your solution well.\nFunction as Child Components\n \nAccording to the documentation of cloneElement()\nReact.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n\n\nClone and return a new React element using element as the starting\n  point. The resulting element will have the original element\u2019s props\n  with the new props merged in shallowly. New children will replace\n  existing children. key and ref from the original element will be\n  preserved.\nReact.cloneElement() is almost equivalent to:\n<element.type {...element.props} {...props}>{children}</element.type>\n\nHowever, it also preserves refs. This means that if you get a child\n  with a ref on it, you won\u2019t accidentally steal it from your ancestor.\n  You will get the same ref attached to your new element.\n\nSo cloneElement is what you would use to provide custom props to the children. However there can be multiple children in the component and you would need to loop over it. What other answers suggest is for you to map over them using React.Children.map. However React.Children.map unlike React.cloneElement changes the keys of the Element appending and extra .$ as the prefix. Check this question for more details: React.cloneElement inside React.Children.map is causing element keys to change\nIf you wish to avoid it, you should instead go for the forEach function like\nrender() {\n    const newElements = [];\n    React.Children.forEach(this.props.children, \n              child => newElements.push(\n                 React.cloneElement(\n                   child, \n                   {...this.props, ...customProps}\n                )\n              )\n    )\n    return (\n        <div>{newElements}</div>\n    )\n\n}\n\n \nMethod 1 - clone children\nconst Parent = (props) => {\n   const attributeToAddOrReplace= \"Some Value\"\n   const childrenWithAdjustedProps = React.Children.map(props.children, child =>\n      React.cloneElement(child, { attributeToAddOrReplace})\n   );\n\n   return <div>{childrenWithAdjustedProps }</div>\n}\n\nMethod 2 - use composable context\nContext allows you to pass a prop to a deep child component without explicitly passing it as a prop through the components in between.  \nContext comes with drawbacks: \n\nData doesn't flow in the regular way - via props. \nUsing context creates a contract between the consumer and the provider. It might be more difficult to understand and replicate the requirements needed to reuse a component. \n\nUsing a composable context\nexport const Context = createContext<any>(null);\n\nexport const ComposableContext = ({ children, ...otherProps }:{children:ReactNode, [x:string]:any}) => {\n    const context = useContext(Context)\n    return(\n      <Context.Provider {...context} value={{...context, ...otherProps}}>{children}</Context.Provider>\n    );\n}\n\nfunction App() {\n  return (\n      <Provider1>\n            <Provider2> \n                <Displayer />\n            </Provider2>\n      </Provider1>\n  );\n}\n\nconst Provider1 =({children}:{children:ReactNode}) => (\n    <ComposableContext greeting=\"Hello\">{children}</ComposableContext>\n)\n\nconst Provider2 =({children}:{children:ReactNode}) => (\n    <ComposableContext name=\"world\">{children}</ComposableContext>\n)\n\nconst Displayer = () => {\n  const context = useContext(Context);\n  return <div>{context.greeting}, {context.name}</div>;\n};\n\n\n \nFurther to @and_rest answer, this is how I clone the children and add a class.\n<div className=\"parent\">\n    {React.Children.map(this.props.children, child => React.cloneElement(child, {className:'child'}))}\n</div>\n\n \nI think a render prop is the appropriate way to handle this scenario\nYou let the Parent provide the necessary props used in child component, by refactoring the Parent code to look to something like this:\nconst Parent = ({children}) => {\n  const doSomething(value) => {}\n\n  return children({ doSomething })\n}\n\nThen in the child Component you can access the function provided by the parent this way:\nclass Child extends React {\n\n  onClick() => { this.props.doSomething }\n\n  render() { \n    return (<div onClick={this.onClick}></div>);\n  }\n\n}\n\nNow the fianl stucture will look like this:\n<Parent>\n  {(doSomething) =>\n   (<Fragment>\n     <Child value=\"1\" doSomething={doSomething}>\n     <Child value=\"2\" doSomething={doSomething}>\n    <Fragment />\n   )}\n</Parent>\n\n \nWhen using functional components, you will often get the TypeError: Cannot add property myNewProp, object is not extensible error when trying to set new properties on props.children. There is a work around to this by cloning the props and then cloning the child itself with the new props.\nconst MyParentComponent = (props) => {\n  return (\n    <div className='whatever'>\n      {props.children.map((child) => {\n        const newProps = { ...child.props }\n        // set new props here on newProps\n        newProps.myNewProp = 'something'\n        const preparedChild = { ...child, props: newProps }\n        return preparedChild\n      })}\n    </div>\n  )\n}\n\n \nThe slickest way to do this:\n    {React.cloneElement(this.props.children, this.props)}\n\n \nFor any one who has a single child element this should do it.\n{React.isValidElement(this.props.children)\n                  ? React.cloneElement(this.props.children, {\n                      ...prop_you_want_to_pass\n                    })\n                  : null}\n\n \nGot inspired by all the answers above and this is what I have done. I am passing some props like some data, and some components.\nimport React from \"react\";\n\nconst Parent = ({ children }) => {\n  const { setCheckoutData } = actions.shop;\n  const { Input, FieldError } = libraries.theme.components.forms;\n\n  const onSubmit = (data) => {\n    setCheckoutData(data);\n  };\n\n  const childrenWithProps = React.Children.map(\n    children,\n    (child) =>\n      React.cloneElement(child, {\n        Input: Input,\n        FieldError: FieldError,\n        onSubmit: onSubmit,\n      })\n  );\n\n  return <>{childrenWithProps}</>;\n};\n\n\n \nIs this what you required?  \nvar Parent = React.createClass({\n  doSomething: function(value) {\n  }\n  render: function() {\n    return  <div>\n              <Child doSome={this.doSomething} />\n            </div>\n  }\n})\n\nvar Child = React.createClass({\n  onClick:function() {\n    this.props.doSome(value); // doSomething is undefined\n  },  \n  render: function() {\n    return  <div onClick={this.onClick}></div>\n  }\n})\n\n \nSome reason React.children was not working for me. This is what worked for me.\nI wanted to just add a class to the child. similar to changing a prop\n var newChildren = this.props.children.map((child) => {\n const className = \"MenuTooltip-item \" + child.props.className;\n    return React.cloneElement(child, { className });\n });\n\n return <div>{newChildren}</div>;\n\nThe trick here is the React.cloneElement. You can pass any prop in a similar manner\n \nRender props is most accurate approach to this problem. Instead of passing the child component to parent component as children props, let parent render child component manually. Render is built-in props in react, which takes function parameter. In this function you can let parent component render whatever you want with custom parameters. Basically it does the same thing as child props but it is more customizable. \nclass Child extends React.Component {\n  render() {\n    return <div className=\"Child\">\n      Child\n      <p onClick={this.props.doSomething}>Click me</p>\n           {this.props.a}\n    </div>;\n  }\n}\n\nclass Parent extends React.Component {\n  doSomething(){\n   alert(\"Parent talks\"); \n  }\n\n  render() {\n    return <div className=\"Parent\">\n      Parent\n      {this.props.render({\n        anythingToPassChildren:1, \n        doSomething: this.doSomething})}\n    </div>;\n  }\n}\n\nclass Application extends React.Component {\n  render() {\n    return <div>\n      <Parent render={\n          props => <Child {...props} />\n        }/>\n    </div>;\n  }\n}\n\nExample at codepen\n \nI came to this post while researching for a similar need, but i felt cloning solution that is so popular, to be too raw and takes my focus away from the functionality.\nI found an article in react documents Higher Order Components\nHere is my sample:\nimport React from 'react';\n\nconst withForm = (ViewComponent) => {\n    return (props) => {\n\n        const myParam = \"Custom param\";\n\n        return (\n            <>\n                <div style={{border:\"2px solid black\", margin:\"10px\"}}>\n                    <div>this is poc form</div>\n                    <div>\n                        <ViewComponent myParam={myParam} {...props}></ViewComponent>\n                    </div>\n                </div>\n            </>\n        )\n    }\n}\n\nexport default withForm;\n\n\nconst pocQuickView = (props) => {\n    return (\n        <div style={{border:\"1px solid grey\"}}>\n            <div>this is poc quick view and it is meant to show when mouse hovers over a link</div>\n        </div>\n    )\n}\n\nexport default withForm(pocQuickView);\n\nFor me i found a flexible solution in implementing the pattern of Higher Order Components.\nOf course it depends on the functionality, but it is good if someone else is looking for a similar requirement, it is much better than being dependent on raw level react code like cloning.\nOther pattern that i actively use is the container pattern. do read about it, there are many articles out there.\n"]